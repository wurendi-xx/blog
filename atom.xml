<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Recorder</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-11T14:21:30.607Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Wu Rendi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络概述</title>
    <link href="http://yoursite.com/2019/03/11/%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2019/03/11/网络概述/</id>
    <published>2019-03-11T09:15:47.000Z</published>
    <updated>2019-03-11T14:21:30.607Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络概述</p><p>[TOC]</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h2><p>互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</p><p>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。</p><h2 id="主机之间的通信方式"><a href="#主机之间的通信方式" class="headerlink" title="主机之间的通信方式"></a>主机之间的通信方式</h2><p>客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。</p><p>对等（P2P）：不区分客户和服务器。</p><h2 id="电路交换与分组交换"><a href="#电路交换与分组交换" class="headerlink" title="电路交换与分组交换"></a>电路交换与分组交换</h2><ol><li><p>电路交换<br>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p></li><li><p>分组交换<br>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</p></li></ol><p>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。</p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</p><ol><li><p>排队时延<br>分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</p></li><li><p>处理时延<br>主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</p></li><li><p>传输时延<br>主机或路由器传输数据帧所需要的时间。<br>$delay=l(bit)/v(bit/s)$<br>其中$ l $表示数据帧的长度，$v ​$表示传输速率。</p></li><li><p>传播时延<br>电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。<br>$delay=l(m)/v(m/s)$<br>其中$l$表示信道长度，$v$表示电磁波在信道上的传播速度。</p></li></ol><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><ol><li><p>五层协议</p><ul><li>应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</li><li>传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li><li>网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li><li>数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li><li>物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul></li><li><p>OSI<br>OSI比五层协议在应用层多了表示层和会话层。<br>其中表示层和会话层用途如下：</p><ul><li>表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li><li>会话层 ：建立及管理会话。</li></ul></li></ol><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p><ol start="3"><li>TCP/IP</li></ol><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><ol start="4"><li>数据在各层之间的传递过程<br>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</li></ol><p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p><h1 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1.物理层"></a>1.物理层</h1><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p><ul><li>单工通信：单向传输</li><li>半双工通信：双向交替传输</li><li>全双工通信：双向同时传输</li></ul><h2 id="带通调制"><a href="#带通调制" class="headerlink" title="带通调制"></a>带通调制</h2><p>模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。</p><h1 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2.数据链路层"></a>2.数据链路层</h1><h2 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h2><ol><li><p>封装成帧<br>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p></li><li><p>透明传输<br>透明表示一个实际存在的事物看起来好像不存在一样。</p></li></ol><p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p><ol start="3"><li>差错检测<br>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</li></ol><p>CRC检验的原理：CRC 算法的基本思想是将传输的数据当做一个位数很长的数。将这个数除以另一个数。得到的余数作为校验数据附加到原数据后面。</p><h2 id="信道分类"><a href="#信道分类" class="headerlink" title="信道分类"></a>信道分类</h2><ol><li>广播信道<br>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</li></ol><p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p><p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</p><ol start="2"><li>点对点信道<br>一对一通信。</li></ol><p>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><ol><li><p>频分复用<br>频分复用的所有主机在相同的时间占用不同的频率带宽资源。</p></li><li><p>时分复用<br>时分复用的所有主机在不同的时间占用相同的频率带宽资源。</p></li></ol><p>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。</p><ol start="3"><li><p>统计时分复用<br>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。</p></li><li><p>波分复用<br>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p></li><li><p>码分复用<br>为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片$\vec{S}$和$\vec{T}$ 有<br>$$ 1/m \cdot\vec{S}\vec{T}=0 $$</p></li></ol><p>为了讨论方便，取 m=8，设码片$\vec{S}$为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。</p><p>在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到</p><p>$$ 1/m \cdot\vec{S}\vec{S}=1 $$</p><p>$$ 1/m \cdot\vec{S}\vec{S}^,=-1 $$</p><p>其中$\vec{S}^,$为$\vec{S}$的反码。</p><p>利用上面的式子我们知道，当接收端使用码片 $\vec{S}$对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。</p><p>码分复用需要发送的数据量为原先的 m 倍。</p><h2 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h2><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p><ul><li>多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li><li>载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li><li>碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。<br>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</li></ul><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p><h2 id="PPP-协议"><a href="#PPP-协议" class="headerlink" title="PPP 协议"></a>PPP 协议</h2><p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><p>PPP 的帧格式：</p><ul><li><p>F 字段为帧的定界符</p></li><li><p>A 和 C 字段暂时没有意义</p></li><li><p>FCS 字段是使用 CRC 的检验序列</p></li><li><p>信息部分的长度不超过 1500</p><p>F|A|C|协议|IP数据报|FCS|F<br>:–:|:–:|:–:|:–:|:–:|:–:|:–:<br>| | | | | | </p></li></ul><h2 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h2><p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p><p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p><p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p><p>可以按照网络拓扑结构对局域网进行分类：星型，环型，直线型</p><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>以太网是一种星型拓扑结构局域网。</p><p>早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。</p><p>目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。</p><p>以太网帧格式：</p><ul><li>类型 ：标记上层使用的协议；</li><li>数据 ：长度在 46-1500 之间，如果太小则需要填充；</li><li><p>FCS ：帧检验序列，使用的是 CRC 检验方法；</p><p>目的地址|源地址|类型|IP数据报|FCS<br>:–:|:–:|:–:|:–:|:–:<br>6|6|2|46-1500|4| </p></li></ul><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。</p><p>正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</p><p>交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p><h2 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h2><p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。</p><p>(A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。</p><p>使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。</p><h1 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3.网络层"></a>3.网络层</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。</p><p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议 IGMP（Internet Group Management Protocol）</li></ul><h2 id="IP-数据报格式"><a href="#IP-数据报格式" class="headerlink" title="IP 数据报格式"></a>IP 数据报格式</h2><p><img src="/2019/03/11/网络概述/ip.jpg" alt="ip"></p><ul><li>版本 : 有 4（IPv4）和 6（IPv6）两个值；</li><li>首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li><li>区分服务 : 用来获得更好的服务，一般情况下不使用。</li><li>总长度 : 包括首部长度和数据部分长度。</li><li>生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li><li>协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li><li>首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li><li>标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li><li>片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li></ul><h2 id="IP-地址编址方式"><a href="#IP-地址编址方式" class="headerlink" title="IP 地址编址方式"></a>IP 地址编址方式</h2><p>IP 地址的编址方式经历了三个历史阶段：</p><ul><li>分类</li><li>子网划分</li><li>无分类</li><li></li></ul><ol><li>分类<br>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</li></ol><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p><ol start="2"><li>子网划分<br>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</li></ol><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p><p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p><p>注意，外部网络看不到子网的存在。</p><ol start="3"><li>无分类<br>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</li></ol><p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p><p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p><p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p><p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。</p><p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p><h2 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议 ARP"></a>地址解析协议 ARP</h2><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p><p>ARP 实现由 IP 地址得到 MAC 地址。</p><p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p><p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p><h2 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h2><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p><p>ICMP 报文分为差错报告报文和询问报文。</p><ol><li><p>Ping<br>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。<br>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p></li><li><p>Traceroute<br>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。<br>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p><ul><li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li><li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li><li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ul></li></ol><h2 id="虚拟专用网-VPN"><a href="#虚拟专用网-VPN" class="headerlink" title="虚拟专用网 VPN"></a>虚拟专用网 VPN</h2><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p><p>有三个专用地址块：</p><p>10.0.0.0 ~ 10.255.255.255<br>172.16.0.0 ~ 172.31.255.255<br>192.168.0.0 ~ 192.168.255.255<br>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p><p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p><h2 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h2><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p><p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p><h2 id="路由器的结构"><a href="#路由器的结构" class="headerlink" title="路由器的结构"></a>路由器的结构</h2><p>路由器从功能上可以划分为：路由选择和分组转发。</p><p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p><h2 id="路由器分组转发流程"><a href="#路由器分组转发流程" class="headerlink" title="路由器分组转发流程"></a>路由器分组转发流程</h2><ul><li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li><li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li><li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li><li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li><li>报告转发分组出错。</li></ul><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p><p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p><p>可以把路由选择协议划分为两大类：</p><ul><li>自治系统内部的路由选择：RIP 和 OSPF</li><li>自治系统间的路由选择：BGP</li></ul><ol><li>内部网关协议 RIP<br>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</li></ol><p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p><p>距离向量算法：</p><pre><code>+ 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；+ 对修改后的 RIP 报文中的每一个项目，进行以下步骤：    + 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；    + 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。+ 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</code></pre><p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p><ol start="2"><li>内部网关协议 OSPF<br>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</li></ol><p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p><p>OSPF 具有以下特点：</p><ul><li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li><li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li><li>只有当链路状态发生变化时，路由器才会发送信息。</li></ul><p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p><ol start="3"><li>外部网关协议 BGP<br>BGP（Border Gateway Protocol，边界网关协议）</li></ol><p>AS 之间的路由选择很困难，主要是由于：</p><ul><li>互联网规模很大；</li><li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li><li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。<br>BGP 只能寻找一条比较好的路由，而不是最佳路由。</li></ul><p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p><h1 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4.传输层"></a>4.传输层</h1><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p><h2 id="UDP-和-TCP-的特点-bigstar"><a href="#UDP-和-TCP-的特点-bigstar" class="headerlink" title="UDP 和 TCP 的特点$\bigstar$"></a>UDP 和 TCP 的特点$\bigstar$</h2><ul><li><p>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p></li><li><p>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p></li></ul><h2 id="UDP-首部格式"><a href="#UDP-首部格式" class="headerlink" title="UDP 首部格式"></a>UDP 首部格式</h2><p><img src="/2019/03/11/网络概述/UDP格式.jpg" alt="UDP格式"></p><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p><h2 id="TCP-首部格式"><a href="#TCP-首部格式" class="headerlink" title="TCP 首部格式"></a>TCP 首部格式</h2><p><img src="/2019/03/11/网络概述/TCP格式.png" alt="TCP格式"></p><ul><li><p>序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p></li><li><p>确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p></li><li><p>数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p></li><li><p>确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p></li><li><p>同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p></li><li><p>终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p></li><li><p>窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p></li></ul><h2 id="TCP-的三次握手-bigstar"><a href="#TCP-的三次握手-bigstar" class="headerlink" title="TCP 的三次握手$\bigstar$"></a>TCP 的三次握手$\bigstar$</h2><p><img src="/2019/03/11/网络概述/TCP三次握手.png" alt="TCP三次握手"></p><p>假设 A 为客户端，B 为服务器端。</p><ul><li><p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p></li><li><p>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</p></li><li><p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</p></li><li><p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p></li><li><p>B 收到 A 的确认后，连接建立。</p></li></ul><p>三次握手的原因</p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><h2 id="TCP-的四次挥手-bigstar"><a href="#TCP-的四次挥手-bigstar" class="headerlink" title="TCP 的四次挥手$\bigstar$"></a>TCP 的四次挥手$\bigstar$</h2><p><img src="/2019/03/11/网络概述/TCP四次挥手.jpg" alt="TCP四次挥手"></p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li><p>A 发送连接释放报文，FIN=1。</p></li><li><p>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</p></li><li><p>当 B 不再需要连接时，发送连接释放报文，FIN=1。</p></li><li><p>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</p></li><li><p>B 收到 A 的确认后释放连接。</p></li></ul><h3 id="四次挥手的原因-bigstar"><a href="#四次挥手的原因-bigstar" class="headerlink" title="四次挥手的原因$\bigstar$"></a>四次挥手的原因$\bigstar$</h3><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><h3 id="TIME-WAIT-bigstar"><a href="#TIME-WAIT-bigstar" class="headerlink" title="TIME_WAIT$\bigstar$"></a>TIME_WAIT$\bigstar$</h3><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><p>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</p><p>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p><h2 id="TCP-可靠传输"><a href="#TCP-可靠传输" class="headerlink" title="TCP 可靠传输"></a>TCP 可靠传输</h2><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p><p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p><p>$$ RTTs=(1-a)<em>(RTTs)+a</em>RTT$$</p><p>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。</p><p>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：</p><p>$$ RTO=RTTs+4*RTT_d$$</p><p>其中 RTTd 为偏差的加权平均值。</p><h2 id="TCP-滑动窗口-bigstar"><a href="#TCP-滑动窗口-bigstar" class="headerlink" title="TCP 滑动窗口$\bigstar$"></a>TCP 滑动窗口$\bigstar$</h2><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><p><img src="/2019/03/11/网络概述/滑动窗口.jpg" alt="滑动窗口"></p><h2 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h2><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p><p><img src="/2019/03/11/网络概述/阻塞控制.jpg" alt="阻塞控制"></p><p>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p><p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p><p>为了便于讨论，做如下假设：</p><ul><li>接收方有足够大的接收缓存，因此不会发生流量控制；</li><li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li></ul><p><img src="/2019/03/11/网络概述/TCP拥塞变化.png" alt="TCP拥塞变化"></p><ol><li>慢开始与拥塞避免<br>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</li></ol><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p><ol start="2"><li>快重传与快恢复<br>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</li></ol><p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p><p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p><h1 id="5-应用层"><a href="#5-应用层" class="headerlink" title="5.应用层"></a>5.应用层</h1><h2 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h2><p>DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p><p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p><p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传来保证可靠性。在两种情况下会使用 TCP 进行传输：</p><p>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。<br>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</p><h2 id="文件传送协议"><a href="#文件传送协议" class="headerlink" title="文件传送协议"></a>文件传送协议</h2><p>FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：</p><p>控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。<br>数据连接：用来传送一个文件数据。<br>根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</p><p>主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</p><p>被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</p><p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p><h2 id="动态主机配置协议"><a href="#动态主机配置协议" class="headerlink" title="动态主机配置协议"></a>动态主机配置协议</h2><p>DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。</p><p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p><p>DHCP 工作过程如下：</p><ul><li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li><li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li><li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li><li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li></ul><h2 id="远程登录协议"><a href="#远程登录协议" class="headerlink" title="远程登录协议"></a>远程登录协议</h2><p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</p><p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p><h2 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h2><p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。</p><p>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p><ol><li><p>SMTP<br>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p></li><li><p>POP3<br>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。</p></li><li><p>IMAP<br>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p></li></ol><h2 id="常用端口"><a href="#常用端口" class="headerlink" title="常用端口"></a>常用端口</h2><table><thead><tr><th style="text-align:center">应用</th><th style="text-align:center">应用层协议</th><th style="text-align:center">端口号</th><th style="text-align:center">传输层协议</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">域名解析</td><td style="text-align:center">DNS</td><td style="text-align:center">53</td><td style="text-align:center">UDP/TCP</td><td style="text-align:center">长度超过 512 字节时使用 TCP</td></tr><tr><td style="text-align:center">动态主机配置协议</td><td style="text-align:center">DHCP</td><td style="text-align:center">67/68</td><td style="text-align:center">UDP    </td></tr><tr><td style="text-align:center">简单网络管理协议</td><td style="text-align:center">SNMP</td><td style="text-align:center">161/162</td><td style="text-align:center">UDP    </td></tr><tr><td style="text-align:center">文件传送协议</td><td style="text-align:center">FTP</td><td style="text-align:center">20/21</td><td style="text-align:center">TCP</td><td style="text-align:center">控制连接 21，数据连接 20</td></tr><tr><td style="text-align:center">远程终端协议</td><td style="text-align:center">TELNET</td><td style="text-align:center">23</td><td style="text-align:center">TCP    </td></tr><tr><td style="text-align:center">超文本传送协议</td><td style="text-align:center">HTTP</td><td style="text-align:center">80</td><td style="text-align:center">TCP    </td></tr><tr><td style="text-align:center">简单邮件传送协议</td><td style="text-align:center">SMTP</td><td style="text-align:center">25</td><td style="text-align:center">TCP    </td></tr><tr><td style="text-align:center">邮件读取协议</td><td style="text-align:center">POP3</td><td style="text-align:center">110</td><td style="text-align:center">TCP    </td></tr><tr><td style="text-align:center">网际报文存取协议</td><td style="text-align:center">IMAP</td><td style="text-align:center">143</td><td style="text-align:center">TCP    </td></tr></tbody></table><h2 id="Web-页面请求过程"><a href="#Web-页面请求过程" class="headerlink" title="Web 页面请求过程"></a>Web 页面请求过程</h2><ol><li>DHCP 配置主机信息</li></ol><p>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</p><p>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</p><p>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</p><p>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FFFFFFFFFF:FF，将广播到与交换机连接的所有设备。</p><p>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</p><p>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</p><p>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</p><ol start="2"><li>ARP 解析 MAC 地址</li></ol><p>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</p><p>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</p><p>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</p><p>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</p><p>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</p><p>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FFFFFFFFFF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</p><p>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</p><ol start="3"><li>DNS 解析域名</li></ol><p>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</p><p>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</p><p>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</p><p>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</p><p>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</p><ol start="4"><li>HTTP 请求页面</li></ol><p>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</p><p>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</p><p>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</p><p>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</p><p>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</p><p>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机网络概述&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;ISP&quot;&gt;&lt;a href=&quot;#ISP&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>why</title>
    <link href="http://yoursite.com/2019/03/07/why/"/>
    <id>http://yoursite.com/2019/03/07/why/</id>
    <published>2019-03-07T13:55:08.000Z</published>
    <updated>2019-03-07T14:02:08.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于我为什么写这个博客"><a href="#关于我为什么写这个博客" class="headerlink" title="关于我为什么写这个博客"></a>关于我为什么写这个博客</h1><p>一直以来的学习太宽泛了，啥都学啥都不会，临近找工作时发现自己的专业技能深度还不够，写这个博客一方面是为了记录学习过程，一方面是经营博客的新奇感，还有就是为了养成良好的学习习惯。先给自己立一个一年内不荒废的毒誓吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于我为什么写这个博客&quot;&gt;&lt;a href=&quot;#关于我为什么写这个博客&quot; class=&quot;headerlink&quot; title=&quot;关于我为什么写这个博客&quot;&gt;&lt;/a&gt;关于我为什么写这个博客&lt;/h1&gt;&lt;p&gt;一直以来的学习太宽泛了，啥都学啥都不会，临近找工作时发现自己的专业技
      
    
    </summary>
    
    
      <category term="碎碎念" scheme="http://yoursite.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式系统开发技术摘要</title>
    <link href="http://yoursite.com/2019/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/"/>
    <id>http://yoursite.com/2019/03/06/计算机三级/</id>
    <published>2019-03-06T08:44:47.000Z</published>
    <updated>2019-03-06T11:47:51.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="嵌入式系统开发技术"><a href="#嵌入式系统开发技术" class="headerlink" title="嵌入式系统开发技术"></a>嵌入式系统开发技术</h1><p>前言：写来给计算机三级整理用的，虽然意义不是很大。</p><h2 id="TOC"><a href="#TOC" class="headerlink" title="[TOC]"></a>[TOC]</h2><h2 id="第一章：嵌入式系统概论"><a href="#第一章：嵌入式系统概论" class="headerlink" title="第一章：嵌入式系统概论"></a>第一章：嵌入式系统概论</h2><h2 id="1-1嵌入式系统及其应用"><a href="#1-1嵌入式系统及其应用" class="headerlink" title="1.1嵌入式系统及其应用"></a>1.1嵌入式系统及其应用</h2><h3 id="1-1-1嵌入式系统"><a href="#1-1-1嵌入式系统" class="headerlink" title="1.1.1嵌入式系统"></a>1.1.1嵌入式系统</h3><p>  嵌入式计算机系统的简称，广泛应用于各个领域，它几乎无处不在。<br>  概念：嵌入式系统是以应用为中心，以计算机技术为基础，软硬件可裁剪，适应应用系统对功能、可靠性、成本、体积、功耗等多种约束的专用计算机系统。 </p><p>特点：</p><ol><li>专用性：  具体应用紧密结合，目标明确，很强的专用性。例如采集环境温度</li><li>隐蔽性：  例如：ATM机，数码相机等</li><li>资源受限：通常要求系统小型化、轻量化、低功耗、低成本等</li><li>高可靠性：例如汽车、数控机床等</li><li>实时性：  报警领域</li><li>软件固化：程序固化在ROM中，用户不能随便修改。</li></ol><p>应用领域:</p><ul><li>消费类：冰箱、洗衣机、空调、数码相机、游戏机等</li><li>产业类：数控机床、汽车、飞机、监护仪等</li><li>业务类：电话机、打印机、POS机、路由器、手机等</li><li><p>军用类：火炮、导弹等军用电子设备</p><p>嵌入式系统在应用数量上远远超过了各种类型的通用计算机系统。</p></li></ul><h3 id="1-1-2嵌入式系统组成及分类"><a href="#1-1-2嵌入式系统组成及分类" class="headerlink" title="1.1.2嵌入式系统组成及分类"></a>1.1.2嵌入式系统组成及分类</h3><p>逻辑组成：<br><strong>硬件：</strong></p><ul><li>处理器：采用微米级（深亚微米级至纳米级）半导体加工工艺。<br>CPU：中央处理器[4/8/16/32位字长，使用最多8/16位，32/64位是技术发展主流]<br>DSP：数字信号处理器<br>决定嵌入式系统性能的参数：<strong>主频、指令系统、缓存、逻辑结构</strong></li><li>存储器：     <ul><li>易失性存储器 RAM: DRAM存放正在运行的程序/数据，<br>SRAM 存储速度快，高速缓存使用</li><li>非易失性存储器 ROM：Flash ROM NOR Flash 字节为单位存储<br>NAND Flash 页为单位存储</li></ul></li><li>I/O设备与I/O接口: <ul><li>人机交互：按键、LED、触摸板、</li><li>机机交互：各种传感器和伺服执行机构</li><li>VGA：视频图像阵列</li><li>HDMI：高清晰度多媒体接口</li><li>DVI：数字视频接口</li><li>CAN：控制器局域网</li></ul></li><li>数据总线: Data Bus，简称总线；数据线和控制电路组成</li></ul><p><strong>软件：</strong></p><p>安卓Android为例:</p><ul><li>最底层：各种驱动程序和Linux内核</li><li>第二层：系统库和Android运行环境</li><li>第三层：应用软件框架</li><li>第四层：应用程序</li><li>BSP：板级支持包</li></ul><p>嵌入式处理芯片<br>特点：支持实时处理、低功耗、结构可扩展、集成测试电路</p><p>目前嵌入式处理芯片有4种产品类型：</p><ol><li>微处理器</li><li>数字信号处理器DSP：哈佛结构、SIMD</li><li>微控制器</li><li>片上系统Soc</li></ol><p>嵌入式系统的分类与发展</p><ul><li>用途:    军用、工业用、民用</li><li>实时性:    非实时系统、软实时系统、硬实时系统</li><li>产品形态:   系统级：PC104模块 板级：带CPU的主板</li><li>片级：单片机、微处理器、DSP、Soc</li><li>系统复杂程度:     低端系统、中端系统、高端系统</li><li>发展:     1/4/8/16/32/64 位</li></ul><p>应用系统举例:数码相机</p><h3 id="1-1-3-Soc芯片"><a href="#1-1-3-Soc芯片" class="headerlink" title="1.1.3  Soc芯片"></a>1.1.3  Soc芯片</h3><p>微电子技术    </p><ul><li>核心：半导体集成电路</li><li>分类：小规模、中规模、大规模、超大规模、及大规模</li><li>摩尔定律：单块集成电路的集成度平均每18-24个月翻一番</li></ul><p>通用Soc和专用Soc：</p><ul><li><strong>通用Soc芯片</strong>：半导体企业通过自主开发处理器内核或购买其他企业的处理器内核的IP授权，按照目标应用领域功能要求所开发的SoC芯片系列。</li><li><strong>专用SoC芯片</strong>：嵌入式系统开发商依据待开发产品的特殊要求，向半导体企业定制的SoC芯片。</li></ul><p>Soc芯片开发流程:  主要工作是借助EDA(电子设计自动化)工具完成。<br>1、总体设计2、逻辑设计3、综合与仿真4、芯片制造</p><p>IP核及其复用   :   </p><ul><li>IP：（Intellectual Property）知识产权</li><li>分类：<strong>固核、软核、硬核</strong></li><li>IP复用：减少研发成本、缩短研发时间、实现快速设计、尽早投放市场的有效途径。</li></ul><h2 id="1-2嵌入式系统与数字媒体"><a href="#1-2嵌入式系统与数字媒体" class="headerlink" title="1.2嵌入式系统与数字媒体"></a>1.2嵌入式系统与数字媒体</h2><h3 id="1-2-1数字文本-Text"><a href="#1-2-1数字文本-Text" class="headerlink" title="1.2.1数字文本(Text)"></a>1.2.1数字文本(Text)</h3><p>字符集及编码：   </p><ol><li>西文字符：ASCII字符集：128个字符+96个可打印字符+32个控制字符【7个2进制进行编码】</li><li>汉字编码：</li></ol><ul><li>GB2312:包含汉字和拉丁字母、俄文、日文、希腊字母和汉语拼音等【十六个2进制进制标识】</li><li>GB18030：和国际标准的UCS/Unicode字符集基本兼容</li></ul><ol start="3"><li>UCS/Unicode：</li></ol><ul><li>UTF-8 : 采用单字节可变长编码。</li><li>UTF-16: 采用双字节可变长编码。</li></ul><p>文本类型：数字文本也称电子文本或文本                </p><ol><li>：简单文本，纯文本，后缀名为.txt                </li><li>：丰富文本，PDF、.doc等格式                </li><li>：超文本，【超链接】</li></ol><p>文本制作和展现: 字符的形状有两种描述方法：          </p><ul><li>点阵法，描述字符离散点阵中笔画的占位信息          </li><li>轮廓法，描述字符的轮廓</li></ul><h3 id="1-2-2-数字图像"><a href="#1-2-2-数字图像" class="headerlink" title="1.2.2 数字图像"></a>1.2.2 数字图像</h3><p>数字图像获取及主要参数</p><p>获取方法：数码相机和扫描仪<br><strong>获取步骤：扫描–&gt;分色–&gt;取样–&gt;量化</strong><br>参数： 图像大小、位平面数目(像素颜色分量数目)、像素深度、颜色模型</p><p>常用格式及应用<br>  <strong>图像数据量(单位：字节)=图像水平分辨率×图像垂直分辨率×像素深度/8</strong>  </p><p>常用格式：</p><ul><li>BMP：Windows应用程序            </li><li>GIF：互联网，颜色数目不超过256色，文件小，适合互联网传输。</li><li>JPEG：互联网、数码相机【有损】，静止图像数据压缩编码的国际标准           </li><li>PNG：互联网、桌面出版            </li><li>TIF：桌面出版</li></ul><h3 id="1-2-3-数字音频及视频"><a href="#1-2-3-数字音频及视频" class="headerlink" title="1.2.3 数字音频及视频"></a>1.2.3 数字音频及视频</h3><p>音频视频的数字化<br>音频：</p><ul><li>音频频率范围：20Hz-20kHz的模拟信号。</li><li>语音信号范围：300-3400Hz，电话取样频率为8kHz，音乐为全频，取样频率为40kHz。</li></ul><p>音频数字化步骤：<strong>取样–&gt;量化–&gt;编码</strong>。<br><strong>数字信号码率(单位：b/s)=取样频率×量化位数×声道数/压缩比</strong></p><p>编码类型：</p><ul><li>未压缩  ：WAV </li><li>无损压缩：FLAC、APE、M4A </li><li>有损压缩：MP3、WMA、AC3、AAC<br>视频：压缩编码标准：</li><li>MPEG-1： VCD、数码相机、数字摄像机 </li><li>H.261 </li><li>MPEG-2： 用途最广，DVD，数字卫星电视、数字有线电视 </li><li>MPEG-2   High Profile </li><li>MPEG-4   ASP </li><li>MPEG-4 AVC：最新应用最多的标准</li></ul><h2 id="1-3数字通讯与计算机网络"><a href="#1-3数字通讯与计算机网络" class="headerlink" title="1.3数字通讯与计算机网络"></a>1.3数字通讯与计算机网络</h2><h3 id="1-3-1数字通讯"><a href="#1-3-1数字通讯" class="headerlink" title="1.3.1数字通讯"></a>1.3.1数字通讯</h3><p>模拟/数字通讯</p><ul><li>模拟信号：连续变化的物理量(如电平的幅度或电流的强度)来表示，信号容易受到干扰，传输不稳定。</li><li>数字信号：用高低电平来表示电流的大小，抗干扰能力强，差错可控制。</li></ul><p>有线/无线通讯</p><ul><li>有线通讯：传输介质通常为金属导体或者光导纤维。双绞线、同轴电缆、光缆 。</li><li>无线通讯：不需要物理连接，通过电磁波在自由空间的传播来传输信息。</li></ul><p>无线电波按照频率/波长分为<strong>中波、短波、超短波、微波</strong>。</p><ul><li>中波：沿地面传播，绕射能力强，适合广播和海上通讯 </li><li>短波：较强的电离层反射能力，适合环球通讯。 </li><li>超短波/微波：绕射能力弱，适用于视距或超视距中继通讯 </li><li>微波：300MHz-300GHz，微波中继距离在50km，典型代表：手机。</li></ul><blockquote><ul><li>第1代个人移动通讯：模拟传输技术。</li><li>第2代个人移动通讯：数字通讯，频段900MHZ-1800MHz，使用GSM和CDMA，俗称全球移动通讯系统，简称2G。</li><li>第3代个人移动通讯：使用频段1885-2025MHz，2110-2200MHz，传输速率几个Mb/s,中国移动自主研发TD-SCDMA，中国电信CDMA2000,中国联通WCDMA，不同标准的网络互通，但终端设备（手机）不兼容。</li><li>第4代个人移动通讯; 传输速率100Mb/s,中国移动TD-LTE,兼容3G(TD-SDMA)和2G(GSM)，中国联通和电信采用FDD-LTE,终端设备采用多模工作方式，兼容之前的3G和2G网络。</li></ul></blockquote><p>数字通讯传输技术</p><ul><li>调制与解调技术</li><li>多路复用技术 <ul><li>时分多路复用TDM</li><li>频分多路复用FDM</li><li>波分多路复用WDM</li></ul></li><li>交换技术  分组交换技术</li></ul><h3 id="1-3-2-计算机网络"><a href="#1-3-2-计算机网络" class="headerlink" title="1.3.2 计算机网络"></a>1.3.2 计算机网络</h3><p>网络组成：</p><ul><li>计算机等智能电子设备终端</li><li>数据通讯链路</li><li>通讯协议</li><li>网络软件</li></ul><p>网络类型：</p><ul><li>局域网LAN</li><li>城域网MAN</li><li>广域网WAN</li></ul><p>以太局域网：</p><ul><li>传输方式：分组交换技术，</li><li>格式为：发送设备MAC地址，接收设备MAC地址，控制信息，有效载荷，信息校验</li><li>MAC地址：全球唯一，48个二进制组成。</li></ul><p>无线局域网：无线电波进行数据传输，分为2.4GHz和5.8GHz两个频段<br>协议：</p><ul><li>IEEE802.11，俗称WiFi.       </li><li>IEEE802.11b（2.4GHz频段），传输速率11Mbps        </li><li>IEEE802.11a（5.8GHz频段）</li><li>IEEE802.11g（2.4GHz频段） 传输速率54Mbps    </li><li>IEEE802.11n                传输速率108Mbps    </li><li>IEEE802.11ac               传输速率1000Mbps    </li><li>无线接入点（WAP或AP）。</li><li>蓝牙Bluetooth 瑞典爱立信公司提出，无线协议IEEE802.15.</li></ul><h3 id="1-3-3-互联网"><a href="#1-3-3-互联网" class="headerlink" title="1.3.3 互联网"></a>1.3.3 互联网</h3><p>IP协议和路由器<br>IP协议：</p><ul><li>IPv4协议中，每个IP地址使用32个二进制表示。 </li><li>IPv6协议中，每个IP地址使用128个二进制表示。</li><li>IP协议分为A,B,C三个基本类 </li></ul><p>IP数据报：头部和数据区。<br>路由器：选择路由和转发IP数据报。</p><p>互联网及其组成<br>互联网的接入: </p><ol><li>ADSL接入 </li><li>有线电视网接入 </li><li>光纤接入网 </li><li>无线接入：无线局域网接入、GPRS移动电话网接入、3G移动电话网接入、4G移动电话网接入</li></ol><h2 id="第二章：嵌入式处理器"><a href="#第二章：嵌入式处理器" class="headerlink" title="第二章：嵌入式处理器"></a>第二章：嵌入式处理器</h2><h2 id="2-1处理器概述"><a href="#2-1处理器概述" class="headerlink" title="2.1处理器概述"></a>2.1处理器概述</h2><h3 id="2-1-1嵌入式处理器结构类型"><a href="#2-1-1嵌入式处理器结构类型" class="headerlink" title="2.1.1嵌入式处理器结构类型"></a>2.1.1嵌入式处理器结构类型</h3><p>指令集：</p><ul><li>复杂指令集结构<strong>CISC</strong>(Complex Instruction Set Computer)</li><li>精简指令集结构<strong>RISC</strong>(Reduced Instruction Set Computer)</li></ul><p>存储机制：</p><ul><li>冯·诺依曼von Neumann：数据和程序代码存放在一起</li><li>哈佛结构Harvard：数据和程序代码分开存储</li></ul><p>字长：8位、16位、32位、64位</p><p>内核系列：51、AVR、PIC、MSP430、MIPS、PowerPC、MC68K、ColdFire、ARM</p><h3 id="2-1-2嵌入式处理器简介"><a href="#2-1-2嵌入式处理器简介" class="headerlink" title="2.1.2嵌入式处理器简介"></a>2.1.2嵌入式处理器简介</h3><p>  51、AVR、PIC、MPS430、MIPS、PowerPC、MC68K、ColdFire、ARM等内核</p><h3 id="2-1-3-ARM处理器概述"><a href="#2-1-3-ARM处理器概述" class="headerlink" title="2.1.3 ARM处理器概述"></a>2.1.3 ARM处理器概述</h3><p>ARM处理器特点</p><ol><li>单周期操作</li><li>只使用加载/存储指令访问内存</li><li>指令长度固定</li><li>三地址指令格式</li><li>指令流水线技术</li><li>低功耗设计</li></ol><p>ARM处理器架构发展</p><ul><li>ARMv1  1985    </li><li>ARMv2  1987    </li><li>ARMv3  1992 </li><li>ARMv4/ARMv4T  1996    S3C2410 </li><li>ARMv5  1999    ARMv5TE  1999    ARMv5TEJ  1999 </li><li>ARMv6  2001 ARMv7M  2004 ARMv6M  2004 </li><li>ARMv7R  2004    Coetex-R4/R5/R7 </li><li>ARMv7A  2004    Coetex-A5/A7/A8/    A9/A15/A17 </li><li>ARMv8A  2011    Coetex-A53/A57</li></ul><p>ARM指令集比较</p><ul><li>Thumb-2指令集：混合指令集，既有16位指令也有32位指令</li><li>Thumb指令集：全部为16位指令</li><li>ARM指令集：全部为32位指令</li></ul><h2 id="2-2-ARM典型处理器介绍"><a href="#2-2-ARM典型处理器介绍" class="headerlink" title="2.2 ARM典型处理器介绍"></a>2.2 ARM典型处理器介绍</h2><p>经典ARM处理器：ARM7、ARM9、ARM11(ARMv4T、ARMv5TE、ARMv6架构)</p><p>ARM Cortex嵌入处理器：<strong>ARM Cortex-M</strong>系列Cortex-M0/M0+/M1/M3/M4，<strong>成本和功耗敏感低端处理器</strong></p><p>ARM Cortex<strong>实时</strong>处理器：<strong>ARM Cortex-R</strong>系列包括Cortex-R4/R5/R7,<strong>中档处理器</strong></p><p>ARM Cortex<strong>应用</strong>处理器：<strong>ARM Cortex-A</strong>系列包括Cortex-A17/A15/A12/A9/A8/A7/A5，<strong>高端处理器</strong></p><p>ARM专家处理器：SC100、SC300</p><h2 id="2-3-ARM处理器体系结构"><a href="#2-3-ARM处理器体系结构" class="headerlink" title="2.3 ARM处理器体系结构"></a>2.3 ARM处理器体系结构</h2><h3 id="2-3-1-ARM处理器工作状态和模式"><a href="#2-3-1-ARM处理器工作状态和模式" class="headerlink" title="2.3.1 ARM处理器工作状态和模式"></a>2.3.1 ARM处理器工作状态和模式</h3><p>工作状态：ARM和Thumb之间的切换 :<br>指令BX    </p><ul><li>ARM到Thumb：R[0]=1;    BX R0             </li><li>Thumb到ARM：R[0]=0;    BX R0</li></ul><ol><li>ARM状态：          ARM处理器复位后总是处于ARM状态</li><li>Thumb/Thumb-2状态：（Cortex-M处理器只有Thumb-2状态和调试状态）</li><li>调试状态</li></ol><p>工作模式CPSR:[M4:M0]（Cortex除外）</p><ul><li><strong>用户模式User [10000]</strong></li><li><strong>快速中断模式FIQ [10001]</strong></li><li><strong>外部中断模式IRQ [10010]</strong></li><li><strong>管理模式SVC [10011]</strong></li><li><strong>中止模式ABT [10111]</strong></li><li><strong>系统模式SYS [11111]</strong></li><li><strong>未定义指令模式UND [11011]</strong></li></ul><h3 id="2-3-2-ARM处理器的寄存器组织"><a href="#2-3-2-ARM处理器的寄存器组织" class="headerlink" title="2.3.2 ARM处理器的寄存器组织"></a>2.3.2 ARM处理器的寄存器组织</h3><p>ARM状态下寄存器组织</p><ul><li>ARM处理器共37个寄存器：31个通用寄存器和6个状态寄存器</li><li>R15：  程序计数器（PC） </li><li><strong>CPSR</strong>： 当前程序状态寄存器 </li><li>R7~R0：通用寄存器</li></ul><p>状态寄存器：当前程序状态寄存器CPSR和备份程序状态寄存器SPSR </p><ul><li>N：符号标志，N=1运算结果为负数 </li><li>Z：全0标志，Z=1运算结果为0 </li><li>C：进位、借位标志，C=1，加法有进位，减法无借位 </li><li>V：溢出标志，V=1,加减法运算结果有溢出 </li><li>Q：增强的DSP运算指令溢出标志，Q=1，有溢出 </li><li>I：外部中断控制位，I=1，禁止外部IRQ中断 </li><li>F：快速中断控制位，F=1，禁止FIQ中断 </li><li>T：ARM与Thumb指令切换，T=1，Thumb指令 </li><li>M4~M0：模式选择位</li></ul><p>CPSR状态寄存器分为4个域：标志域F(31:24)、状态域S(23:16)、扩展域X(15:8)、控制域(7:0)，单个字节可以单独操作域而不影响其他位。</p><p>Thumb状态下寄存器组织：在Thumb状态下R8-R12下不可见<br>带MMU的ARM处理器中的控制寄存器（略过）</p><h3 id="2-3-3-ARM处理器的异常"><a href="#2-3-3-ARM处理器的异常" class="headerlink" title="2.3.3 ARM处理器的异常"></a>2.3.3 ARM处理器的异常</h3><p>ARM异常种类、异常向量表和优先级<br>异常类型|优先级|工作模式<br>:————-:|:——–:|:———:<br>复位RESET |1 | 管理模式<br>未定义UND| 6|中止模式<br>软件中断SWI|6|管理模式<br>指令预取中止PABT|5|中止模式<br>数据访问中止DABT|2 |中止模式<br>外部中断请求IRQ|4|外部中断模式<br>快速中断请求FIQ|3|快速中断模式</p><p>异常中断响应过程<br>异常处理程序返回</p><h3 id="2-3-4-存储器格式和数据类型"><a href="#2-3-4-存储器格式和数据类型" class="headerlink" title="2.3.4 存储器格式和数据类型"></a>2.3.4 存储器格式和数据类型</h3><p>存储字格式：<strong>大端模式</strong><br>32位数据字的高字节存储在低地址中，而数据字的低字节存放在高地址中。<br>例如：0x12345678存放的起始地址为0x30001000，<br>大端模式下，</p><blockquote><p>0x30001000单元存放0x12；<br>0x30001001单元存放0x34；<br>0x30001002单元存放0x56；<br>0x30001003单元存放0x78；</p></blockquote><p><strong>小端模式</strong><br>32位数据字的高字节存储在高地址中，而数据字的低字节存放在低地址中。<br>例如：0x12345678存放的起始地址为0x30001000，<br>小端模式下，</p><blockquote><p>0x30001000单元存放0x78；<br>0x30001001单元存放0x56；<br>0x30001002单元存放0x34；<br>0x30001003单元存放0x12；</p></blockquote><p><strong>与大端模式存放数据完全不同。系统复位时一般自动默认为小端模式</strong>。</p><p>数据类型：32位ARM处理器支持字节（8位）、半字（16位）、字（32位）3种数据类型。字需要4字节对齐，半字需要2字节对齐。<br>ARM指令固定长度32位指令，<strong>且字对齐</strong>。<br>Thumb指令长度16位指令，且2<strong>字节字对齐</strong>。</p><h3 id="2-3-5-MMU和MPU"><a href="#2-3-5-MMU和MPU" class="headerlink" title="2.3.5 MMU和MPU"></a>2.3.5 MMU和MPU</h3><p>MMU虚拟存储器技术：通过地址映射，使需要运行在连续地址空间的软件可以运行在不连续的物理存储空间，需要较大存储空间的软件可以运行在较小容量的物理存储器中。</p><p>MMU：存储器管理单元，高性能处理器所必须的重要部件之一<br>MMU的功能：①虚拟地址到物理地址映射、②存储器访问权限控制。<br>MPU：存储器保护单元</p><h2 id="2-4-ARM处理器指令集"><a href="#2-4-ARM处理器指令集" class="headerlink" title="2.4 ARM处理器指令集"></a>2.4 ARM处理器指令集</h2><h3 id="2-4-1-ARM指令分类和格式"><a href="#2-4-1-ARM指令分类和格式" class="headerlink" title="2.4.1 ARM指令分类和格式"></a>2.4.1 ARM指令分类和格式</h3><p>ARM指令分类：</p><ol><li>分支指令 </li><li>数据处理指令 </li><li>程序状态寄存器处理指令 </li><li>加载/存储指令 </li><li>协处理器指令 </li><li>异常指令</li></ol><p>ARM指令格式<br>ARM状态下寄存器组织</p><p>\<opcode> {\<cond>} {S}   \<rd> , \<rn> {,\<op2>}    </op2></rn></rd></cond></opcode></p><p>\&lt;&gt;不可省略<br>{}可省略<br>\<opcode>        指令操作码        [31:28]<br>{cond}            条件域                【可省略】<br>{S}            指令执行是否更新CPSR    【可省略】<br>Rd                目的寄存器<br>Rn                第一个源操作数<br>op2                第二个源操作数<br>opcode，cond与S之间没有分隔符<br>{S}和Rd之间用空格隔开。</opcode></p><p>imm8m：</p><ul><li>ARM指令集：imm8m表示一个由8位立即数经循环右移任意偶数位次形成的32位操作数</li><li>Thumb指令集：imm8m表示一个由8位立即数经左移任意位次形成的32位操作数</li></ul><p>ARM指令中操作数符号</p><ol><li>‘#’–立即数符号，后面是十进制或十六进制数 </li><li>‘0x’–十六进制符号，后面的数据表示十六进制 </li><li>‘！’–更新基址寄存器符号，表示指令完成操作后最后的地址应该写入的基址寄存器 </li><li>‘^’–复制SPSR到CPSR符号 </li><li>’-‘–寄存器列表范围 R7-R0；</li></ol><p>移位操作符</p><ol><li>逻辑左移    LSL </li><li>算数左移    ASL </li><li>逻辑右移    LSR </li><li>算数右移    ASR </li><li>循环右移    ROR </li><li>带扩展的循环右移  RRX</li></ol><h3 id="2-4-2-ARM指令寻址方式："><a href="#2-4-2-ARM指令寻址方式：" class="headerlink" title="2.4.2 ARM指令寻址方式："></a>2.4.2 ARM指令寻址方式：</h3><ul><li>立即寻址</li><li>寄存器寻址</li><li>寄存器间接寻址</li><li>变址寻址</li><li>相对寻址</li><li>堆栈寻址</li><li>块拷贝寻址</li></ul><p>ARM指令集<br>Thumb指令集<br>ARM处理器伪指令</p><h3 id="2-5-ARM汇编语言程序设计"><a href="#2-5-ARM汇编语言程序设计" class="headerlink" title="2.5 ARM汇编语言程序设计"></a>2.5 ARM汇编语言程序设计</h3><p>ARM汇编器支持的伪指令<br>ARM汇编语言语句格式<br>汇编语言程序设计举例<br>C语言汇编语言混合编程</p><h2 id="第三章：嵌入式系统硬件组成"><a href="#第三章：嵌入式系统硬件组成" class="headerlink" title="第三章：嵌入式系统硬件组成"></a>第三章：嵌入式系统硬件组成</h2><h2 id="3-1-硬件组成概述"><a href="#3-1-硬件组成概述" class="headerlink" title="3.1 硬件组成概述"></a>3.1 硬件组成概述</h2><p>嵌入式系统由嵌入式硬件系统和嵌入式软件系统组成。 </p><ul><li>嵌入式硬件系统由嵌入式处理器、存储器、I/O接口等构件。 </li><li>嵌入式硬件系统可分为：嵌入式最小系统和典型嵌入式硬件系统、</li></ul><p>最小硬件系统：</p><ul><li>电源电路：<ul><li>交流变直流模块（AC-DC）</li><li>直流到直流模块（DC-DC）</li><li>低压差稳压器LDO（Low Dropout Regulator）</li></ul></li><li>时钟电路：<ul><li>为嵌入式处理器提供时钟信号 </li><li>晶振：有源晶振和无源晶振</li></ul></li><li>复位电路：<ul><li>嵌入式处理器有一个系统复位引脚nRESET或RESET，n表示低电平复位。 ARM复位后PC指针指向唯一的地址0x00000000，此处通常有一条无条件转移指令B RESET，转向RESET开始系统的初始化程序。</li></ul></li><li>JTAG测试接口：内部测试电路 JTAG(Joint Test Action Group)是一种国际标准测试协议。<br>SWD是Cortex-M内核提供的另外一种少引脚调试接口，串行线调试接口：SWD和SWCLK两根信号线；调试时也需要加上地线和复位信号线。</li></ul><p>ARM内核典型嵌入式应用系统硬件组成</p><p>典型的嵌入式应用系统硬件由以下几部分组成： </p><ol><li>嵌入式最小硬件系统： </li><li>前向通道：即<strong>输入接口</strong>，由模拟量输入接口（传感器、信号调整电路，<br>A/D转换器等）和数字量输入接口组成 </li><li>后向通道：即<strong>输出接口</strong>，由模拟输出接口（D/A转换器、功率放大器和<br>执行器等）和数字输出接口组成。 </li><li>人机交互通道：键盘、触摸屏输入接口以及LED或LCD输出显示接口 </li><li>相互互连通讯通道：RS-232/RS-485串行通信接口，CAN通信接口，以太<br>网通信接口、USB通信接口</li></ol><h2 id="3-2-嵌入式处理芯片"><a href="#3-2-嵌入式处理芯片" class="headerlink" title="3.2 嵌入式处理芯片"></a>3.2 嵌入式处理芯片</h2><h3 id="3-2-1-AMBA总线体系结构及标准"><a href="#3-2-1-AMBA总线体系结构及标准" class="headerlink" title="3.2.1 AMBA总线体系结构及标准"></a>3.2.1 AMBA总线体系结构及标准</h3><p>AMBA(Advanced Microcontroller Bus Architecture)：先进微控制器总线体系结构。 </p><ol><li>ARM公司公布的总线协议，用于连接和管理偏上系统中功能模块的开放标准和片上互联规范。 </li><li><strong>AMBA</strong>总线1995年推出AMBA1.0到2011年AMBA4.0共计4个版本，总线性能不断提升。 </li><li><strong>ASB**</strong>(Advanced System Bus)先进系统总线<strong> </strong>AHB<strong>(Advanced Hign-performance Bus)</strong>先进高性能总线**（ASB发展而来）主要用于连接高宽带快速组件。 </li><li><strong>APB(Advanced Peripheral Bus)先进外围总线</strong>，主要连接低带宽组件与外部相连的硬件组件。 <strong>系统组件通过桥接器（Bridge）与外围总线互联</strong>。</li></ol><h3 id="3-2-2-ARM内核嵌入式芯片的硬件组成"><a href="#3-2-2-ARM内核嵌入式芯片的硬件组成" class="headerlink" title="3.2.2 ARM内核嵌入式芯片的硬件组成"></a>3.2.2 ARM内核嵌入式芯片的硬件组成</h3><p><strong>AHB连接的高带宽组件包括</strong>：电源管理和时钟管理器、测试接口JTAG、外部存储器控制器接口、DMA控制器、USB主机、片上SRAM及FLASH、Etherent、高速GPIO中断控制器、LCD控制器等。<br><strong>APB连接的低速带宽组件包括</strong>：GPIO、UART、SPI、I2C、USB设备、CAN、ADC、DAC、WDT、Timer、RTC、PWM等。</p><ul><li>存储器与控制器：片内程序存储器通常是Flash ROM； 片内数据存储器通常是SRAM；</li><li>中断控制器： VIC：中断向量 NVIC：嵌套向量中断 处理中断两种形式：标准的中断控制器和向量中断控制器（VIC）</li><li>DMA控制器：（Direct Memory Access）：直接存储器访问控制器 使用它可以将数据块从外设传输至内存、从内存传输至外设或从内存传输至内存。 数据的传输过程中不需要CPU的参与，可以显著降低处理器的负荷，提高数据处理的效率。</li><li>电源管理与时钟管理器：ARM处理器内部电源管理主要有：<strong>正常工作模式、慢时钟模式、空闲模式、掉电模式、休眠模式、深度休眠模式</strong>等。 时钟控制器负责对时钟的分配，产生不同频率的定时时钟可供片内个组件作为同步时钟使用。</li><li>GPIO端口： (General Purpose Input Output)即通用输入/输出端口。 作为<strong>输入具有缓冲</strong>功能，而作为<strong>输出时则具有锁存</strong>功能。 有的引脚是双功能，也有三功能甚至四功能的引脚。</li><li>定时计数组件：包括：①WDT（Watchdog Timer）：看门狗定时器 ②Timer通用定时器，用于一般的定时 ③RTC：提供年月日时分秒 ④脉冲宽度调制器PWM（Pulse Width Modulation）：用于电机等控制</li><li>模拟通道组件：内部的模拟组件包括ADC和DAC： <ul><li>ADC：模拟到数字的转换器，可完成从模拟信号到数字信号的变换。它是一个模拟输入的组件。</li><li>DAC：数字到模拟的变换器，可完成从数字信号到模拟信号的变换，一般在后级还需要加功率放大才能接到实际应用系统中。</li></ul></li><li>互联通信组件：<ol><li>UART通用异步收发器（Universal Asynchronous Receiver/Transmitter)：标准的串行通信接口。字符格式按照地位在前、高位在后，1位起始位、5-8位数据位、1位奇偶校验位，1-2位停止位。 </li><li>I2C（Inter－Integrated Circuit）集成电路互联的一种总线标准。两根信号线，时钟线（SCL）和数据线（SDA） </li><li>I2S（Inter－Integrated Circuit Sound Bus）多媒体应用的音频串行总线 </li><li>SPI（Serial Peripheral Interface）是串行外设接口，它是一种同步串行外设接口，通常用四线制，包括MISO（主输入从输出）、MOSI（主输出从输入）、SSL（芯片选择）、SCK（时钟） </li><li>CAN(Controller Area Network)控制器局域网，仅有CANH和CANL两根信号线，采用差分传输方式，远距离1200m，抗干扰能力强，可组成多主多从系统。 </li><li>USB（Universal Serial Bus）通用串行总线，主要应用于与外部设备的短距离通信，采用查分信号传输数据，速度快，效率高。 </li><li>Ethernet是以太网通讯接口。</li></ol></li></ul><h3 id="3-2-3-常用ARM嵌入式处理芯片"><a href="#3-2-3-常用ARM嵌入式处理芯片" class="headerlink" title="3.2.3 常用ARM嵌入式处理芯片"></a>3.2.3 常用ARM嵌入式处理芯片</h3><ul><li>NXP的ARM芯片</li><li>TI的ARM芯片</li><li>Samsung的ARM芯片（基于ARM920T内核的S3C4xx系列）</li><li>Atmel的ARM芯片</li><li>ST的ARM芯片</li><li>Freescale的ARM芯片</li><li>Nuvoton的ARM芯片</li><li>Intel的ARM芯片</li><li>其他ARM芯片厂家</li></ul><h3 id="3-2-4-嵌入式处理芯片的选型"><a href="#3-2-4-嵌入式处理芯片的选型" class="headerlink" title="3.2.4  嵌入式处理芯片的选型"></a>3.2.4  嵌入式处理芯片的选型</h3><p>性价比原则：完全能够满足要求且略有余量的嵌入式处理器芯片<br>参数选择原则</p><h2 id="3-3-嵌入式系统存储器"><a href="#3-3-嵌入式系统存储器" class="headerlink" title="3.3 嵌入式系统存储器"></a>3.3 嵌入式系统存储器</h2><h3 id="3-3-1-层次结构："><a href="#3-3-1-层次结构：" class="headerlink" title="3.3.1 层次结构："></a>3.3.1 层次结构：</h3><p>缓存（Cache）技术，目前嵌入式系统采用SRAM作为Cache，分为一级Cache(L1)h和二级Cache(L2)</p><h3 id="3-3-2-分类：半导体存储器："><a href="#3-3-2-分类：半导体存储器：" class="headerlink" title="3.3.2 分类：半导体存储器："></a>3.3.2 分类：半导体存储器：</h3><p>RAM：</p><ul><li>SRAM:静态随机存取存储器（嵌入式内嵌的数据存储器）</li><li>DRAM:动态随机存取存储器（外部扩展的存储器）<br>ROM：</li><li>MROM:掩膜型只读存储器</li><li>PROM:一次可编程只读存储器</li><li>EPROM:紫外线可擦除可编程只读存储器</li><li>E2PROM:电可擦除可编程只读存储器</li><li>Flash:闪速存储器<ul><li><strong>NOR Flash ROM</strong>：以页（行）为单位随机存取，数据存储器使用</li><li><strong>NAND Flash ROM</strong>：以字节为单位随机存取</li></ul></li></ul><p>新型存储器:</p><ul><li><strong>FRAM:铁电</strong>随机存取存储器</li><li><strong>MRAM:磁性</strong>随机存取存储器</li></ul><h3 id="3-3-3性能指标"><a href="#3-3-3性能指标" class="headerlink" title="3.3.3性能指标"></a>3.3.3性能指标</h3><p>容量:<br>存储器容量是指每一个存储芯片或模块能够存储的二进制位数。 存储1位二进制位为最小单位（b）。<br>容量单位有字节（Byte，B）、千字节（Kilo-Byte，KB）、兆字节（Mega-Byte，MB）、吉字节（Giga-Byte，GB）、太字节（Tera-Byte，TB）。<br><strong>对内存而言</strong>：容量单位之间的相互关系为<strong>2^10=1024倍</strong>表示；<br><strong>对外存容量</strong>：容量单位之间的相互关系为<strong>10^3=1000倍</strong>表示； </p><p>存储器容量计算公式：</p><blockquote><p>V=2^m×n<br>V：存储器容量<br>m：地址线条数<br>n：数据线条数</p></blockquote><p>存取时间：从CPU给出有效的存储器地址开始到存储器读出数据（或者把数据写入存储器）所需要的时间。 </p><blockquote><p>1s=10^3ms=1000ms<br>1ms=10^3μs=1000μs<br>1μs=10^3ns=1000ns</p></blockquote><p>带宽:存储器带宽是指：每秒可以传输（读出/写入）的最大数据总量。单位：B/s、KB/s、MB/s、GB/s、<br>传输带宽与存储器<strong>总线的频率、数据位数（宽度）、总线周期的传输次数有关</strong>。<br>并行总线存储器带宽：</p><blockquote><p><strong>带宽=总线频率×数据宽度/8×传输次数/总线周期 （B/s）</strong></p></blockquote><p>例如：存储器频率333MHz，数据宽度32位，每周期传输1次，<br>则带宽为：333×32/8×1 B/s =1332MB/s<br>并行总线存储器带宽：</p><blockquote><p>带宽=总线频率×（1/10）（B/s）</p></blockquote><h3 id="3-3-4-片内存储器"><a href="#3-3-4-片内存储器" class="headerlink" title="3.3.4 片内存储器"></a>3.3.4 片内存储器</h3><ul><li>片内Cache： 容量几KB、几百KB或几MB，有一级Cache、二级Cache</li><li>片内Flash ROM：程序存储器</li><li>片内SRAM：  数据存储器（系统复位要对SRAM初始化）</li><li>片内E2PROM：做长期保存重要的数据</li><li>片内FRAM：  具有ROM和RAM的优点，因此既可以做ROM也可做RAM</li></ul><h3 id="3-3-5-片外存储器"><a href="#3-3-5-片外存储器" class="headerlink" title="3.3.5 片外存储器"></a>3.3.5 片外存储器</h3><p>片外程序存储器:  </p><ol><li>NOR Flash(参见P130的表3-4) </li><li>NAND Flash<br>重要的几个引脚说明：        </li></ol><ul><li>BYTE#：8位（0）/16位选择（1）        </li><li>CE#：芯片使能          </li><li>OE#：数据输出使能         </li><li>WE#：写使能       </li><li>RESET#：硬件复位       </li><li>RY/BY#：准备就绪/忙输入 </li><li>引脚低电平有效的几种表示方式：(prague.jing)        </li><li>带#号：OE#     </li><li>带上划线：       </li><li>带n号：nRESET</li><li>片外数据存储器：SDRAM\DDR/DDR2/DDR3/DDR4</li></ul><h3 id="3-3-6外部辅助存储设备"><a href="#3-3-6外部辅助存储设备" class="headerlink" title="3.3.6外部辅助存储设备"></a>3.3.6外部辅助存储设备</h3><ul><li>SM卡：被SD卡和MMC卡取代</li><li>CF卡：采用NAND Flash ROM作为存储器</li><li>MMC卡：应用于数码影像、音乐、手机、PAD等</li><li>SD卡：mimiSD卡和microSD卡（TF卡）</li><li>记忆棒</li><li>XD卡</li><li>U盘：全称为USB闪存盘，USB flash disk</li><li>微硬盘</li></ul><h2 id="3-4-I-O接口和I-O设备"><a href="#3-4-I-O接口和I-O设备" class="headerlink" title="3.4  I/O接口和I/O设备"></a>3.4  I/O接口和I/O设备</h2><ul><li>通用I/O接口GPIO：<ul><li>通用输入输出接口：输入时具备缓冲功能，而输出时具有锁存功能。 </li><li>GPIO一般有三种状态：<strong>0态、1态和高阻状态</strong>。</li></ul></li><li>集成电路互联总线接口I2C：用于连接嵌入式处理器及外围器件广泛采用的<strong>一种串行半双工</strong>传输总线标准。<ul><li>通讯速率：400kb/s、3.4Mb/s（高速模式） </li><li>只有两条线：<strong>数据线SDA和时钟线SCL</strong>。数据线SDA上的数据必须在时钟的高电平期间保持稳定，它的高/低电平状态只有在SCL时钟信号线是低电平时才能改变。 </li></ul><ol><li>起始和停止条件：     <ul><li>起始：<strong>SCL保持高电平时SDA线由高电平转为低电平</strong>，此时主控器件在SCL产生时钟信号，SDA线开始数据传送。     </li><li>停止：<strong>SCL为高电平时SDA电平由低转为高</strong>，则总线停止工作，恢复为空闲状态。 </li></ul></li><li>数据传送格式：数据传送时高位在前，低位在后，每次传送的字节数目没有限制。传送操作启动后主控器件传送的第一个字节为地址，其中前7位指出与哪一个从器件进行通讯，第8位指出数据传送的方向（发送还是接收）。 </li><li>应答信号：完成一字节的传送，接受方应该发送一个确认信号ACK给发送方。ACK信号在SCL的第9个时钟上，有效的应答ACK在SDA上呈现低电平。 </li><li>读/写操作：     <ul><li>发送：数据被发送出去后，I2C接口将处于等待状态（SCL线将保持低电平），直到有新的数据写入I2C数据发送寄存器后，SCL线才被释放，继续发送数据。   </li><li>接收：I2C接口接收到数据后，将处于等待状态，直到数据接收寄存器内容被读取后，SCL线才被释放，继续传输数据。 </li></ul></li><li>总线仲裁：<strong>I2C总线属于多主总线</strong>，允许总线上有一个或多个主控制器和若干从器件同时进行操作。 仲裁机制为线与机制，即总线控制器遵循“SDA线低电平优先”的原则。 </li><li>P139 图3-16/17</li></ol></li><li>串行外设接口SPI：   <ul><li>SPI是一种<strong>同步串行外设接口</strong>，数据传输格式为高位在前，低位在后。</li><li>SCK：时钟信号线 </li><li>SSEL：设备使能线</li><li>MOSI：主设备输出从设备输入 </li><li>MISO：主设备输入从设备输出 </li><li>可以实现<strong>一主一从、互为主从、一主多从、多主多从</strong>等连接。</li></ul></li><li>串行异步通讯接口UART：通用异步收发传输器，通常称作UART，是一种全双工异步<br>收发传输器。 <ul><li>UART由<strong>发送器、接收器、控制单元、波特率发生器</strong>等构成。 </li><li>UART字符格式约定：<br>1.字符总是以起始位为开始，以停止位为结束<br>2.数据以低位在前，高位在后按次序传输<br>3.数据位可以是5、6、7、8，由编程决定<br>4.数据位之后是校验位，可以是奇校验或偶校验，也可以没有校验<br>5.起始位以逻辑0为标志，停止位以逻辑1为标志，停止位可以为1、1.5、2位<br>6.通常情况接收采用中断方式，<strong>发送采用查询</strong>方式。<br>7.UART通讯仅限于板间或芯片间通讯，连接方式仅需三根线，<strong>TXD、RXD及GND</strong>。</li></ul></li><li>通用串行总线USB：  <ul><li>USB是通用串行总线（Universal Serial Bus）的首字母缩写 USB（1.1和2.0）有4根信号线：Vbus，D+、D-、GND。D+、D-为差分信号线。 </li><li>采用差分方式进行通讯 </li><li>USB 2.0速度480Mb/s，USB 3.0速度5Gb/s，即640MB/s USB电源5V/500mA，USB 3.0提供5V/900mA; </li><li>编码方式：翻转不归零制NRZI</li></ul></li><li>高清多媒体接口HDMI：<ul><li>HDMI是（High Definition Multimedia Interface）的缩写，意思是高清晰度多媒体接口，是一种数字化视频/音频接口技术，适合影像传输的专用型数字化接口，可同时传送音频和影像信号，即插即用。 </li><li>HDMI有两种接口形式：<strong>19针的Type-A和29针的Type-B</strong>。 DVI是24针的接口，有多种规格，</li></ul><ol><li>DVI-A：仅用于传输模拟信号，和D-SUB一样；</li><li>DVI-D：仅用于传输数字信号；</li><li>DVI-I：模拟信号和数字信号都可传输，专为LCD显示器和投影仪等数字显示设备设计的。 </li></ol><ul><li><strong>相比DVI，HDMI接口体积小，传输距离可达15m，DVI传输距离不能超过8m</strong>。 </li></ul></li><li>常用简单输入设备：<ul><li>键盘  分为两种：1. 线性键盘，2. 矩阵键盘 键盘消抖时间一般为5-30ms</li><li>触摸屏  电阻式触摸屏（软屏）：利用压力感应进行控制。</li><li>电容式触摸屏（硬屏）</li></ul></li><li>常用简单输出设备：<ul><li>LED二极管和数码管</li><li>LED发光二极管：常亮、长灭、闪亮（快闪、慢闪） 普通发光二极管电流5-20mA，电压1.2V左右。电流大，亮度高，寿命短。</li><li>LED数码管：有八段，a，b，c，d，e，f，g，dp。可以表示数字0-9，字母A-F；<br>分为共阳数码管和共阴数码管。</li><li>LCD显示设备：较好的人机交互体验</li></ul></li></ul><h2 id="3-5-典型处理器芯片-S3C2410-S3C2440"><a href="#3-5-典型处理器芯片-S3C2410-S3C2440" class="headerlink" title="3.5 典型处理器芯片[S3C2410/S3C2440]"></a>3.5 典型处理器芯片[S3C2410/S3C2440]</h2><p>芯片内部结构: </p><ul><li>S3C2410/S3C2440是三星公司基于ARM920T核的嵌入式处理器芯片。<br>采用哈弗体系结构，内部有MMU，具有16KB大小的指令Cache和16KB大小的数据Cache。</li><li>S3C2440在S3C2410的基础上增加了视频和音频接口。</li></ul><p>存储器控制组件:包括：<strong>存储器控制器、总线控制器、外部主控制器、NAND Flash 控制器</strong>等。<br>时钟和电源管理组件<br>S3C2410内部有时钟振荡电路。<br>电源管理模块：</p><ol><li>正常模式       </li><li>慢速模式：不使用PLL时钟，       </li><li>休眠模式：不使用内核时钟FCLK，外围时钟运行，       </li><li>掉电模式：断开内部电源，不产生功耗。</li></ol><ul><li>任何情况复位后均自动进入正常模式，掉电模式和休眠模式下，</li><li>任何外部中断均将返回正常模式。</li></ul><p>中断控制器及中断控制: 中断控制器 P156 表3-11<br>除屏蔽寄存器初始值为1外，其他寄存器的初始值均为0。</p><p>脉宽调制定时计数器PWM Timer<br>定时器的输入<strong>时钟频率=PCLK/（预分频值+1）×时钟因子</strong> </p><p>实时时钟RTC：实时时钟（Real-Time Clock，RTC）可以提供日历/时钟的内置硬件。<br>需要单独的供电引脚和单独的时钟源，采用<strong>32,768kHz</strong>晶体。</p><p>通用I/O接口GPIO：参考各个端口的寄存器</p><p>串行异步通讯接口UART：</p><ul><li>嵌入式系统使用串行异步通讯接口需要通讯双方波特率和传输格式一致。 </li><li>线路控制寄存器（奇偶校验、停止位、数据位）</li><li>UART控制寄存器 </li><li>状态寄存器 </li><li>数据寄存器 </li><li>波特率除数寄存器： </li><li>UBRDIVn=INT（UCLK/（波特率×16））-1（例3-7）</li></ul><p>I2C总线接口： 两种不同的地址形式：7位地址和10位地址。</p><p>看门狗定时器WDT：为了系统可靠的运行。一旦由于某种原因程序跑飞而死机，看门狗可以强行使系统重新复位。（例3-9）</p><p>模数转换器ADC：对模拟信号的采集</p><h2 id="3-6-嵌入式系统外部通讯接口"><a href="#3-6-嵌入式系统外部通讯接口" class="headerlink" title="3.6 嵌入式系统外部通讯接口"></a>3.6 嵌入式系统外部通讯接口</h2><h3 id="3-6-1-基于UART的RS-232-RS-485"><a href="#3-6-1-基于UART的RS-232-RS-485" class="headerlink" title="3.6.1 基于UART的RS-232/RS-485"></a>3.6.1 基于UART的RS-232/RS-485</h3><ol><li>RS-232接口：<ul><li>DB9是标准的RS-232连接器。DB9-2为发送引脚，DB9-3为接收引脚，DB9-5为公共地。传输距离大约15m左右。 </li><li>RS-232采用负逻辑传输：逻辑0：+3V~+15V，逻辑1：-15V~ -3V， </li><li>RS-232互联时需要交叉连接，即RXD连接到TXD，公共地互联。</li></ul></li><li>RS-485接口：<ul><li>工业控制领域、传输距离远、采用<strong>差分信号</strong>传输方式，抗共模干扰能力。传输距离可达1200m。</li><li>RS-485逻辑电平：当A的电位比B高200mV以上时为逻辑1，反之为逻辑0。</li><li>RS-485互联时同名端相连，A连A，B连B。</li></ul></li></ol><h3 id="3-6-2-CAN总线接口"><a href="#3-6-2-CAN总线接口" class="headerlink" title="3.6.2 CAN总线接口"></a>3.6.2 CAN总线接口</h3><p>CAN总线采用差分方式传输。<br>数据帧7部分组成：<strong>帧起始、仲裁域、控制域、数据域、CRC域、应答域、帧结尾</strong>。<br>CAN互联时采用<strong>同名端</strong>相连，CANL连CANL，CANH连CANH。</p><h3 id="3-6-3-以太网通讯接口"><a href="#3-6-3-以太网通讯接口" class="headerlink" title="3.6.3 以太网通讯接口"></a>3.6.3 以太网通讯接口</h3><h3 id="3-6-4-常用无线通讯接口"><a href="#3-6-4-常用无线通讯接口" class="headerlink" title="3.6.4 常用无线通讯接口"></a>3.6.4 常用无线通讯接口</h3><ol><li>PS模块：全球定位系统（Global Positioning System），简称GPS。民用精度100m，采用差分GPS技术后，精度5m。</li><li>北斗模块：北斗一代称为北斗导航实验系统（BDTS），北斗二代称为北斗卫星导航系统，是继美国GPS和俄国GLONASS之后第三个成熟的卫星导航系统。定位精度10m，授时精度50ns，测速精度0.2m/s。</li><li>GPRS模块：GPRS是通用分组无线服务的简称，是GSM移动电话用户可用的一种移动数据业务。</li><li>WIFI模块：<strong>802.11</strong>协议的无线局域网，无线WIFI模块内置TCP/IP协议栈，可以使有线数据到无线数据的传输。</li><li>蓝牙模块：短距离通讯（10m之内）的无线低速（1Mb/s）通讯技术。</li><li>其他（Zigbee、LoRa、433）</li></ol><h2 id="第四章：嵌入式系统软件"><a href="#第四章：嵌入式系统软件" class="headerlink" title="第四章：嵌入式系统软件"></a>第四章：嵌入式系统软件</h2><h2 id="4-1-嵌入式软件的组成"><a href="#4-1-嵌入式软件的组成" class="headerlink" title="4.1 嵌入式软件的组成"></a>4.1 嵌入式软件的组成</h2><ul><li>嵌入式软件的特点：<ul><li>软硬件一体化，软件固化存储</li><li>代码效率高、实时性要求高</li><li>软件可裁剪</li><li>安全性、可靠性要求高(容错设计)</li><li>软件开发难度大(软硬件、开发环境、调试技巧掌握)</li><li>面向客户、面向应用</li><li>软件产业高度分散(嵌入式针对性很强)</li><li>生命周期长(跟新替换同产品同步进行)</li></ul></li><li>嵌入式软件的结构：<ul><li><strong>轮询结构</strong>(没有中断)</li><li>带中断的轮询结构</li><li>监控式操作系统(µC/OS(内核+任务调度+任务通讯+中断管理))+应用软件</li><li>嵌入式操作系统(Android)+应用软件</li></ul></li><li>硬件抽象层HAL与板级支持包BSP<ul><li>概念：<ul><li><strong>硬件抽象层：Hardware Abstract Layer</strong><br>操作系统层和硬件之间设置的独立接口软件层，是所有直接依赖于硬件的软件，包括引导程序、硬件配置程序、硬件访问代码。</li><li><strong>板级支持包：Board Support Package</strong><br>由硬件制造商专门编写，屏蔽了其所支持的嵌入式操作系统和底层硬件平台的相关性。</li></ul></li><li>实例：<ul><li>开发和移植：最小系统调试。外围设备驱动程序调试</li></ul></li></ul></li><li>引导加载程序Bootloader<ul><li>概念和功能：嵌入式系统上电复位后首先运行引导加载程序，它负责系统的上电自检、硬件初始化、建立存储空间映射、配置系统参数、建立上层软件的运行环境、并加载和启动操作系统。</li><li>嵌入式操作系统的加载方式：<ul><li>ROM中直接运行操作系统</li><li>RAM中运行操作系统</li><li>外部存储器加载操作系统</li><li>通讯接口加载操作系统</li></ul></li></ul></li><li><p>引导加载程序的执行过程</p><ul><li>U-Boot：最强、最具弹性、应用最广、更新最快的开源BootLoader</li></ul></li><li>设备驱动程序：  <ul><li>以24C02为例：<ol><li>只能被高层软件调用而无法自行运行；</li><li>对上层软件屏蔽硬件细节，对下层硬件直接进行操作。</li></ol></li></ul></li></ul><h2 id="4-2-嵌入式操作系统"><a href="#4-2-嵌入式操作系统" class="headerlink" title="4.2 嵌入式操作系统"></a>4.2 嵌入式操作系统</h2><p>实时系统与实时操作系统</p><ul><li>实时系统：必须在有限和确定的时间内对外部事件作出响应的信息系统。 IEEE计算机协会实时系统技术委员会(IEEE-CT-TCRTS)：正确性不仅取决于计算的结果，而且取决于产生结果的时间的计算机系统。<br>实时系统对外界的响应是否正确不仅取决于功能正确性，而且取决于对事件处理的正确性。<br>实时系统中的任务分为三类： </li></ul><ol><li><strong>硬实时任务</strong>：也叫做强实时任务，任务必须在给定的时限内完成，超过时限将会导致任务失败或引起致命错误。工业控制和军工系统 </li><li><strong>软实时任务</strong>：也叫做弱实时任务，软实时任务仍然要求系统的响应越快越好，但偶尔超出时限并不会造成任务失败或出现致命错误。DVD播放机 </li><li><strong>准实时任务</strong>：通常允许偶尔错过最后期限，但若超过时限，所进行的操作或计算结果没有任何意义。 注意：硬实时、软实时与准实时的概念与时限的长短没有关系，而与其对超过实现的容忍程度有关。<br>实时系统特征：<strong>1. 时间约束性、2. 可预测性、3. 可靠性、4. 交互性</strong></li></ol><ul><li>实时操作系统：实时操作系统是不以在给定时间内完成更多的任务为目标，而是以响应外部事件尽可能快且响应时间具有确定性为目标的操作系统。<br>实时系统最关键的特性就是完成每次任务所需要的时间的一致性。如果一个实时操作系统能够完全满足确定性的时限要求，则称为硬实时操作系统，否则称为软实时操作系统。<br>实时操作系统完成每次任务所需时间的偏差称为抖动。<strong>硬实时操作系统的抖动比软实时系统小</strong>。</li><li>实时操作系统实时性指标：响应时间：系统从事件请求开始到任务完成的时间间隔。<ol><li><strong>中断延时时间</strong>：接收到可屏蔽中断请求信号到操作系统做出响应并转入中断服务程序所需要的最长时间。 </li><li><strong>任务切换时间</strong>：操作系统在两个独立且具有相同优先级的就绪态任务之间切换所需要的时间 </li><li><strong>任务抢占时间</strong>：系统将控制权从低优先级任务转移到高优先级任务所花费的时间</li></ol></li></ul><p>嵌入式操作系统概述</p><ul><li>特点：具有<strong>任务调度、同步机制、内存管理、中断处理、文件处理、</strong> <ol><li>代码固化存储，时空效率高 </li><li>可裁剪性 </li><li>实时性 </li><li>强稳定性，弱交互性 </li><li>硬件适应性</li></ol></li><li>分类：<ol><li>实时性：硬实时操作系统，弱实时操作系统(非实时操作系统) </li><li>开发方式：专用嵌入式环境开发的嵌入式操作系统，通用计算机操作系统移植的嵌入式操作系统 </li><li>商业模式：免费嵌入式操作系统（RTEMS、eCOS\FreeRTOS）、商业嵌入式操作系统（VxWorks、µC/OS）</li></ol></li><li>内核结构：<br><strong>单内核(宏内核)</strong>：操作系统把内核的各个功能模块（如进程管理、文件系统、设备管理、网络通信等）整合在一起，模块间的交互通过直接调用其他模块中的函数来实现，执行效率高，性能好。<br>例如：<strong>Unix，BSD Unix，Linux，MS-DOS、Windows 9x（Windows 95/98/Me），Windows CE，Android</strong><br><strong>微内核</strong>：仅将必须的基本功能（任务调度、任务键通讯、存储管理、中断处理）放入内核，运行在核心态；其他功能都在内核之外，由用户态服务来完成。<br>例如：<strong>AIX、Mach（早起Apple计算机操作系统内核）、Minix、VxWorks、QNX</strong><br>通用计算机采用微内核：<strong>Windows NT/XP/2000、Vista，Windows 7，MacOS X，ReactOS</strong></li><li>常用嵌入式操作系统：<ul><li>VxWorks：美国风河公司（09年成为英特尔的全资子公司），广泛应用于军用产品。收费</li><li>QNX：QNX软件公司（10年被黑莓收购），类Unix操作系统，</li><li>Nucleus PLUS：ATI公司的，代码使用ANSI C编写的</li></ul></li><li>嵌入式Windows操作系统家族：<ul><li>嵌入式操作系统EOS：Windows Embedded Compact(WEC)<br>Windows Embedded 系列<br>+设备平台（device platform）<ul><li>RTEMS：美国军方研制，用于国防系统，</li><li>TinyOS：无线传感器网络操作系统，美国加州大学伯克利分校研发，开源嵌入式操作系统</li><li>eCOS：嵌入式可配置操作系统，开源免费</li><li>FreeRTOS：开源免费操作系统</li></ul></li></ul></li><li>Linux内核<ul><li>Unix：诞生于美国电话电报公司（AT&amp;T）的贝尔实验室 Linux：属于类Unix，起源于芬兰赫尔辛基大学的学生: 林纳斯 托瓦斯。</li><li>Linux是一种自由软件（开源、免费、自由定制、自由传播）。 </li><li>中国天河一号巨型机系统内核为Linux。</li></ul></li></ul><p>嵌入式Linux操作系统</p><ul><li>结构与组成：<ul><li>结构：单内核。</li><li>组成：①初始化组件、②进程调度器、③内存管理、④虚拟文件系统、⑤网络接口、⑥进程间通讯、⑦可加载模块、⑧设备驱动程序</li></ul></li><li>实时化技术：<ol><li>内核补丁方式</li><li>双内核方式</li><li>超微内核方式</li></ol></li><li>系统的构建：<ul><li>基于通用Linux内核构建嵌入式Linux</li><li>基于嵌入式Linux发行版构建嵌入式Linux<br>µclinux<br>Monta Vista Linux<br>RTLinux<br>RTAI<br>Xenomai<br>Wind River Linux</li></ul></li></ul><p>Android操作系统</p><ul><li>系统特点：美国Google公司主导的一个开源项目。中文名字“安卓”， Android核心是以Linux内核为基础的开源操作系统。 主要应用于智能手机、平板电脑、车载导航、医疗仪器和智能家居等领域。</li><li>系统组成与结构：Android采用<strong>堆层式软件架构</strong>，<br><strong>分为四层</strong>：<ol><li>Linux内核层</li><li>系统运行库：<br>①Android运行环境：Dalvil虚拟机和核心库<br>②组件库：系统C库，媒体框架、surface manager 显示<br>管理库、SGL库、freetype库、SQLite库、WebKit库、<br>OpenGL|ES 3D库、OpenSSL库</li><li>应用程序框架：活动管理器、窗口管理器、内容提供器、视觉系统、通告管理器、包管理器、电话管理器、资源管理器、位置管理器、XMPP服务。 </li><li>应用程序：</li></ol></li><li>应用开发：配置开发环境<br>创建Android应用开发工程<br>运行应用程序</li></ul><p>iOS操作系统</p><ul><li>概述：苹果公司开发的操作系统，原名为iPhone OS，应用于iphone智能手机、平板电脑、和电视机顶盒。<br><strong>iOS同样属于类Unix的操作系统</strong>，</li><li>组成与结构：<ul><li>核心操作系统层</li><li>核心服务层</li><li>媒体层</li><li>触控界面层</li></ul></li><li>应用开发：Xcode</li></ul><h2 id="4-3-µC-OS嵌入式操作系统"><a href="#4-3-µC-OS嵌入式操作系统" class="headerlink" title="4.3 µC/OS嵌入式操作系统"></a>4.3 µC/OS嵌入式操作系统</h2><p>µC/OS操作系统概述：</p><ul><li>历史和发展：µC/OS是由美国Micriµm公司创始人拉伯罗斯（Jean J. Labrosse）开发的RTOS内核。<br>第一个版本：µC/OS，1992年<br>第二个版本：µC/OS II，1998年<br>第三个版本：µC/OS III，2010年</li><li>特点：<ol><li>公开源码的高质量实时内核：不免费，商业用途需要获得Micriµm公司许可。 </li><li>可移植： </li><li>可剪裁、可固化 </li><li>时间确定性 </li><li>多任务：µC/OS II可以管理<strong>64个任务，8个保留给系统</strong>，且不支持时间片轮转调度。 </li><li>抢占式内核 </li><li>多种系统服务：任务管理、时间管理、信号量、事件标志组、互斥信号量、消息队列、内存分区管理。</li></ol></li><li>组成和源代码结构：<strong>µC/OS-II内核负责管理用户任务</strong>，并为任务提供资源共享等服务机制。<br>µC/OS-II源代码主要组成：<ol><li>系统核心</li><li>任务管理 </li><li>时钟管理 </li><li>任务同步和任务间通讯 </li><li>内存管理 </li><li>处理器相关代码</li></ol></li></ul><hr><p>µC/OS-II任务及管理</p><ul><li><p>任务构成：µC/OS-II中，任务是操作系统的基本调度单位。 任务由三部分组成： </p><ol><li>程序代码：没有返回值的C函数， </li><li>任务堆栈：用于保存任务的工作环境， </li><li>任务控制块：保存任务状态和属性的数据结构</li></ol></li><li><p>任务的状态：µC/OS-II的任务处于5种状态：</p><ol><li><strong>休眠态</strong>：任务代码驻留在内存中但还没有交给内核调度的状态，调用创建任务后</li><li><strong>就绪态</strong>：任务已经具备运行条件但因优先级比正在运行的任务低而暂时不能运行的状态</li><li><strong>运行态</strong>：任务已经获得处理器的使用权而正在运行的状态，任何时刻系统中只有一个任务处于运行状态。</li><li><strong>等待态/挂起态</strong>：正在运行的任务因为某一事件发生而将处理器的使用权让给其它任务将自己挂起的状态。</li><li><strong>被中断态</strong>：处理器执行中断服务程序而被暂停运行的任务状态。</li></ol></li><li><p>任务调度：µC/OS-II可以管理<strong>64个任务</strong>（2.82版本后可以管理255个任务）， 0是最高优先级别，最低优先级由OS_LOWEST_PRIO定义， 8个保留给系统，最高优先级的0-3和最低优先级的4个OS_LOWEST_PRIO-3至OS_LOWEST_PRIO，即用户任务最多56个， 任务优先级具有唯一性，所以优先级作为任务的标识。<br><strong>空闲任务</strong>：idle task，必须使用空闲任务，并且是最低优先级。不能被挂起和删除。<br><strong>统计任务</strong>：可选的任务，统计当前处理器利用率。<br><strong>调度方式：</strong></p><ol><li><strong>任务级调度</strong>：内核通过调度OS_TASK_SW()进行任务级的任务切换，保存当前任务的上下文（程序计数器PC，通用寄存器和处理器的状态寄存器），并恢复新任务的上下文。 </li><li><strong>中断级调度</strong>：中断级通过调用OSIntExit()进行任务调度<br>临界区代码：</li></ol></li></ul><ol><li>利用宏OS_ENTER_CRITICAL（）和OS_EXIT_CRITICAL（）实现关中断和开中断</li><li>利用函数OSSchedlock（）和OSSchedUnlock（）给调度器上锁和解锁。</li></ol><ul><li>中断处理：中断服务程序执行步骤如下：<ol><li>保存全部CPU寄存器</li><li>调用OSIntEnter（）或OSIntNesting直接加1</li><li>执行用户中断服务程序代码</li><li>调用OSIntExit（）</li><li>回复所有CPU寄存器</li><li>执行中断返回指令<br>通过OSIntNesting标识当前是否处于中断或中断嵌套的层数，中断嵌套<strong>最多255层。 中断处理中不允许进行任务管理、事件管理、任务调度等</strong></li></ol></li></ul><p>µC/OS-II系统服务</p><ul><li>任务管理：<ul><li><strong>任务创建</strong>：OSTaskCreate（）或者调用OSTaskCreateExt（）<br>任务可以在调用OSStart（）之前或者之后被创建。<br>在任务调度前必须至少创建一个用户任务。</li><li><strong>任务删除</strong>：OSTaskDel (INT8U prio)函数用于删除任务 prio<br>任务可以删除其他任务也可以删除自身，<br>删除后转入休眠态，不被内核调度<br>如有共享资源访问可以调用OSTaskDelReg（）函数让任务使用完资源后再删除。</li><li><strong>任务挂起和恢复</strong>：OSTaskSuspend（） 可以挂起任务。可以挂起自身可其他任务，必须调用OSTaskResume（）进行任务的恢复。</li></ul></li><li><p>时钟节拍和时间管理：操作系统内核需要周期性的信号源用于时间延时和超时。用户必须在调用OSStart（）启动多任务调度以后再开启时钟节拍器。在调用OSStart（）后的第一件事就是初始化定时器中断。<br>任务延时：OSTimeDly()：延时时间是以节拍数来衡量的 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OSTimeDlyHMSM(CPU_INT16U   hours,</span><br><span class="line">CPU_INT16U   minutes,</span><br><span class="line">CPU_INT16U   seconds,</span><br><span class="line">CPU_INT32U   milli,</span><br><span class="line">OS_OPT       opt,</span><br><span class="line">OS_ERR      *p_err)：延时时间则是以具体时间大小来衡量的               </span><br><span class="line">*  hours        (0...99)</span><br><span class="line">*  minutes      (0...59) </span><br><span class="line">*  seconds      (0...59)</span><br><span class="line">*  milliseconds (0...999)</span><br></pre></td></tr></table></figure></li><li><p>任务间通讯和同步：任务间通讯常用的有： </p><ol><li><strong>信号量</strong>：    创建/删除/释放/等待/查询 </li><li>互斥信号量：创建/删除/释放/等待/查询 </li><li>事件标志组：创建/删除/释放/等待/查询 </li><li>消息邮箱：  创建/删除/释放/等待/查询 ‘</li><li>消息队列：  创建/删除/释放/等待/查询</li></ol></li></ul><hr><p>µC/OS-II应用程序设计</p><ul><li><strong>µC/OS初始化和main()函数结构</strong>：基于µC/OS II 的多任务系统中，引导加载程序执行完毕则调用主函数main（）。<br>主函数主要实现的功能包括：<ol><li>硬件初始化、</li><li>调用OSInit（）初始化µC/OS-II的内核，</li><li>创建任务、</li><li>创建任务间通讯或同步的内核对象、</li><li>应用程序相关的初始化、</li><li>调用OSStart（）启动多任务调度等。</li></ol></li><li><strong>用户任务的三种结构</strong>：任务可以是一个无限循环，也可以在任务完成后自我删除。</li><li>通常任务有三种结构：<ol><li><strong>单次执行任务</strong>：任务创建后处于就绪态并可以被执行，执行完相应的功能后则自我删除。 </li><li><strong>周期执行任务</strong>：任务通常采用循环结构，并在每次完成具体的功能后调用系统延时函数OSTimeDlyHMSM（）或者OSTimeDly（）等待下一个执行周期，并将处理器让给其它任务。 </li><li><strong>事件触发执行的任务</strong>：任务的实体代码只有在某种事件发生后才执行。在事件发生之前，任务被挂起。任务也采用循环结构，事件触发一次，任务执行一次。</li></ol></li></ul><hr><p><strong>应用程序设计实例</strong><br>µC/OS-III操作系统的改进和提高</p><p>µC/OS-II定位于8位/16位/低端32位处理器<br>µC/OS-III定位于高端32位处理器，在8位/16位上也可以运行。</p><p>µC/OS-III增加的主要特性：</p><ol><li>时间片轮转调度：允许给任务相同的优先级                           </li><li>内核对象的无限制：任务、信号量、互斥信号量、事件标志、消息队列、定时器等</li><li>任务消息和任务信号：任务本身即可以发送消息和信号量</li><li>时钟节拍：使用哈希散列表机制</li><li>可针对处理器体系结构进行优化</li><li>时间戳</li><li>增强内置性能测试功能：测试任务、CPU的占用情况</li></ol><h2 id="第五章：嵌入式系统开发"><a href="#第五章：嵌入式系统开发" class="headerlink" title="第五章：嵌入式系统开发"></a>第五章：嵌入式系统开发</h2><h2 id="5-1-开发嵌入式系统的基础知识"><a href="#5-1-开发嵌入式系统的基础知识" class="headerlink" title="5.1 开发嵌入式系统的基础知识"></a>5.1 开发嵌入式系统的基础知识</h2><h3 id="5-1-1嵌入式系统的开发过程："><a href="#5-1-1嵌入式系统的开发过程：" class="headerlink" title="5.1.1嵌入式系统的开发过程："></a>5.1.1嵌入式系统的开发过程：</h3><ul><li>需求分析与规格说明</li><li>系统设计</li><li>构建设计</li><li>系统集成和测试：测试（Test）的目的是验证模块/系统的功能和性能，发现错误。<br>调试（Debug）的任务是分析测试中发现的错误，检查原因、定位故障位置，采取适当的措施，修改软件/硬件，然后返回重新进行测试。</li></ul><h3 id="5-1-2开发平台和工具"><a href="#5-1-2开发平台和工具" class="headerlink" title="5.1.2开发平台和工具"></a>5.1.2开发平台和工具</h3><ul><li>嵌入式系统的开发特点：<br>宿主机-目标机的开发架构<br>嵌入式系统的开发平台多半不是最终的运行平台，因此嵌入式的开发通常需要构建一个宿主机-目标机的交叉编译及运行环境，用于编程、调试的计算机称为宿主机（Host），用于程序最终运行的称为目标机（Target）。与底层硬件控制程序的关系密切软硬件资源受限需要固化程序</li><li>开发平台和开发工具：集成开发环境（IDE）</li><li>典型开发平台</li><li><h3 id="5-1-3嵌入式系统的调试"><a href="#5-1-3嵌入式系统的调试" class="headerlink" title="5.1.3嵌入式系统的调试"></a>5.1.3嵌入式系统的调试</h3></li><li><p>在线仿真器（ICE）</p></li><li>片上调试技术（OCD）-JTAG：JTAG(Joint Test Action Group,联合测试工作组)是一种国际标准测试协议（IEEE 1149.1兼容），主要用于芯片内部测试。 标准的JTAG接口4线：TMS、TCK、TDI、TDO，分别为模式选择、时钟、数据输入和数据输出线。 信号线TRST（复位）是可选的。</li><li>驻留监控软件调试</li><li>指令集模拟器（ARMulator和SkyEye）</li></ul><h2 id="5-2-系统开发工具软件"><a href="#5-2-系统开发工具软件" class="headerlink" title="5.2 系统开发工具软件"></a>5.2 系统开发工具软件</h2><ul><li>ADS1.2工具软件</li><li>RVDS</li><li><p>GNU：<strong>GNU</strong>是“GNU is Not Unix”的递归缩写，常用于基于Linux操作系统的嵌入式软件工具套件简称。包括编译器、连接器、文本剪辑器、语法除错等工具。</p><ul><li><p><strong>GCC概述</strong>：针对Linux操作系统环境下应用程序的编译工具，可以将C语言、C++语言、汇编语言编写的源程序及库文件编译连接成执行文件。 从源文件生成执行文件的过程为：<strong>预处理、编译、汇编、连接</strong>。 </p><p>生成可执行文件时，无论工程目录中只有一个源文件还是多个源文件，所有被编译和连接的源文件中必须有且仅有一个main函数。 若仅仅是把源文件编译成目标文件，不进行连接操作，main函数就不是必须的。</p></li><li><p><strong>GCC命令和参数</strong>：基本命令格式为：<code>gcc [options] [filenames]</code><br>options代表编译器命令所需要的参数<br>filenames代表命令中所涉及的相关文件名称<br>针对ARM系列微处理器为核心的目标机，<strong>GCC的基本命令格式是</strong>：<code>arm-linux-gcc [options] [filenames]</code></p></li><li><p><strong>GDB</strong>： GDB是GNU开发工具套件中的程序调试工具，可以提供单步执行和断点执行功能，并观察程序执行时变量值的变化。</p></li><li><p><strong>GNU的使用</strong>：</p><ol><li>需要建立好交叉编译环境，并在宿主机上安装应用于目标机硬件平台的GCC，GDB等工具软件。</li><li>采用一个文本编辑器来编辑项目中所需要的源文件，源文件可以是C/C++/汇编语言 </li><li>利用与目标机硬件平台相关的GCC命令完成预处理、编译、汇编、连接工作。项目中由若干个源文件组成时，通常编写Makefile文件来确定源文件的连接顺序、若程序中只有一个源文件，则不需要Makefile文件，直接使用GCC命令来完成编译工作。 </li><li>利用GDB工具进行程序调试。注意：在编译时需要在命令中加入-g参数，以便生成调试信息。</li></ol></li></ul></li></ul><h2 id="5-3-系统开发示例"><a href="#5-3-系统开发示例" class="headerlink" title="5.3 系统开发示例"></a>5.3 系统开发示例</h2><ul><li>数字式电子钟</li><li>便携式心电记录仪</li><li>基于嵌入式Web服务器的应用设计</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;嵌入式系统开发技术&quot;&gt;&lt;a href=&quot;#嵌入式系统开发技术&quot; class=&quot;headerlink&quot; title=&quot;嵌入式系统开发技术&quot;&gt;&lt;/a&gt;嵌入式系统开发技术&lt;/h1&gt;&lt;p&gt;前言：写来给计算机三级整理用的，虽然意义不是很大。&lt;/p&gt;
&lt;h2 id=&quot;TOC&quot;
      
    
    </summary>
    
    
      <category term="嵌入式" scheme="http://yoursite.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Note of Effective C++</title>
    <link href="http://yoursite.com/2019/03/05/test/"/>
    <id>http://yoursite.com/2019/03/05/test/</id>
    <published>2019-03-05T08:44:47.000Z</published>
    <updated>2019-03-06T02:29:14.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Effective-C-浏览过程"><a href="#Effective-C-浏览过程" class="headerlink" title="Effective C++浏览过程"></a><em>Effective C++</em>浏览过程</h1><hr><p>[TOC]</p><h2 id="条款01：视C-为语言联邦"><a href="#条款01：视C-为语言联邦" class="headerlink" title="条款01：视C++为语言联邦"></a>条款01：视C++为语言联邦</h2><p>1.C：C++是以C为基础的语言。<br>2.Object-Oriented C++：C++中面向对象的内容。<br>3.Template C++：C++中泛型编程的内容。<br>4.STL：C++中的标准库。</p><h2 id="条款02：尽量用const，enum，inline来替换-include"><a href="#条款02：尽量用const，enum，inline来替换-include" class="headerlink" title="条款02：尽量用const，enum，inline来替换#include"></a>条款02：尽量用const，enum，inline来替换#include</h2><ul><li>对于单纯常量，最好用const或者enum来代替#include</li><li>对于宏定义（Marco），最好改用inline函数（template inline）替换#include</li></ul><h2 id="条款03：尽量使用const"><a href="#条款03：尽量使用const" class="headerlink" title="条款03：尽量使用const"></a>条款03：尽量使用const</h2><ul><li>如果关键字const出现在星号左边，则被指物是常量。</li><li>如果关键字const出现在星号右边，则被指针是常量。</li><li>STL中如果需要声明一个’T* const指针‘，则使用const_iterator。</li><li>成员函数其常量性的不同，也可以被重载 。</li></ul><h2 id="条款04：确定对象在使用前已被初始化"><a href="#条款04：确定对象在使用前已被初始化" class="headerlink" title="条款04：确定对象在使用前已被初始化"></a>条款04：确定对象在使用前已被初始化</h2><ul><li>初始化和赋值并不一样，比如构造函数中初始化发生在进入构造函数本体（即赋值语句）之前。所以构造函数最好使用成员初值列(member initalization list)，而非赋值操作(assignment)。其成员的初始化顺序与声明顺序相同。</li><li>为内置型对象（如int,double）进行手工初始化，因为C++不保证初始化它们。</li></ul><h2 id="条款05：了解C-隐式编写并调用了哪些函数"><a href="#条款05：了解C-隐式编写并调用了哪些函数" class="headerlink" title="条款05：了解C++隐式编写并调用了哪些函数"></a>条款05：了解C++隐式编写并调用了哪些函数</h2><p>+编译器会暗自给class创建default构造函数，copy构造函数，copy assignment操作符，以及析构函数。</p><h2 id="条款06：如果不想使用编译器自动生成的函数，就应该明确拒绝"><a href="#条款06：如果不想使用编译器自动生成的函数，就应该明确拒绝" class="headerlink" title="条款06：如果不想使用编译器自动生成的函数，就应该明确拒绝"></a>条款06：如果不想使用编译器自动生成的函数，就应该明确拒绝</h2><ul><li>可以将相应的成员函数声明为private来拒绝编译器自动提供的功能。</li></ul><h2 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h2><ul><li>只有当class包含至少一个virtual函数时，才给它声明一个virtual析构函数。</li><li>如果class的设计目的不是作为base class使用或者具备多态性时(polymorphically)，就不该声明析构函数。</li></ul><h2 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h2><ul><li>不能让析构函数吐出异常，不然会带来“过早结束程序”或者“发生不明确行为”的风险。</li><li>如果客户需要对某个函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非析构函数）执行该操作。</li></ul><h2 id="条款09：绝不要在构造和析构函数中调用virtual函数"><a href="#条款09：绝不要在构造和析构函数中调用virtual函数" class="headerlink" title="条款09：绝不要在构造和析构函数中调用virtual函数"></a>条款09：绝不要在构造和析构函数中调用virtual函数</h2><ul><li>在构造和析构（连同它们调用的所有函数）中不要调用virtual函数，因为这类调用不会下降至derived class（派生类）。</li></ul><h2 id="条款10：令operator-返回一个-reference-to-this"><a href="#条款10：令operator-返回一个-reference-to-this" class="headerlink" title="条款10：令operator= 返回一个 reference to *this"></a>条款10：令operator= 返回一个 reference to *this</h2><ul><li>令赋值（assignment）操作符返回一个reference to *this ，这个协议被所有内置和标准程序库提供的类型如string，vector等等共同遵守。</li></ul><h2 id="条款11：在operator中处理“自我赋值”"><a href="#条款11：在operator中处理“自我赋值”" class="headerlink" title="条款11：在operator中处理“自我赋值”"></a>条款11：在operator中处理“自我赋值”</h2><p>+</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Effective-C-浏览过程&quot;&gt;&lt;a href=&quot;#Effective-C-浏览过程&quot; class=&quot;headerlink&quot; title=&quot;Effective C++浏览过程&quot;&gt;&lt;/a&gt;&lt;em&gt;Effective C++&lt;/em&gt;浏览过程&lt;/h1&gt;&lt;hr&gt;
&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/03/05/hello-world/"/>
    <id>http://yoursite.com/2019/03/05/hello-world/</id>
    <published>2019-03-05T06:47:06.805Z</published>
    <updated>2019-03-05T06:47:06.805Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
