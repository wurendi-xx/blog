<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Recorder</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-19T07:06:56.404Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Wu Rendi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer习题学习过程51-66</title>
    <link href="http://yoursite.com/2019/06/19/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B61-66/"/>
    <id>http://yoursite.com/2019/06/19/剑指offer习题学习过程61-66/</id>
    <published>2019-06-19T07:02:37.000Z</published>
    <updated>2019-06-19T07:06:56.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题61：扑克牌中的顺子"><a href="#面试题61：扑克牌中的顺子" class="headerlink" title="面试题61：扑克牌中的顺子"></a>面试题61：扑克牌中的顺子</h2><blockquote><p>题目：从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2~10时数字本身，A为1，J为11，Q为12，K为13，而大小王可以看出任意数字。</p></blockquote><p>思路：将扑克牌的背景抽象成计算机语言，把5张牌看成由5个数字组成的数组。大小王是特殊数字，不妨定义为0。<br>为了判断这5个数字是不是连续的，最直观的方法是将其排序。其中由于大小王也就是0可以替换成任何一个数字，所以可以用0去补齐数组中的空缺使其连续。<br>所以要做的有三个步骤：</p><ol><li>将数组排序</li><li>统计0的个数</li><li>统计排序后数组中相邻数字之间的空缺总数。如果空缺的总数小于或者等于0的个数，那么就是连续的。（需要注意的是如果有对子，则不可能连续）</li></ol><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isContinuous</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = input.size();</span><br><span class="line">    <span class="keyword">if</span>(length != <span class="number">5</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    sort(input.begin(),input.end());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> numberOfZero = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> numberOfGap = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计算大小王的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(input[i] == <span class="number">0</span>)</span><br><span class="line">            numberOfZero ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = numberOfZero + <span class="number">1</span>;i &lt; length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(input[i] == input[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        numberOfGap = input[i] - input[i<span class="number">-1</span>] <span class="number">-1</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (numberOfGap&gt;numberOfZero) ? <span class="literal">false</span> : <span class="literal">true</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题62：圆圈中最后剩下的数字"><a href="#面试题62：圆圈中最后剩下的数字" class="headerlink" title="面试题62：圆圈中最后剩下的数字"></a>面试题62：圆圈中最后剩下的数字</h2><blockquote><p>题目：0，1，····，n这n个数字排成一个个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。例如，0、1、2、3、4这5个数字，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p></blockquote><p>思路：本题是约瑟夫环（Josephuse）问题，有两种解题方法：一种方法用环形链表模拟圆圈的经典算法；第二种算法是分析被删除数字的规律直接计算出剩下的数字。</p><p>方法一：用list模拟环形链表，在遍历到末尾的时候把迭代器转到链表头部。</p><p>解法： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n,<span class="keyword">unsigned</span> <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; numbers;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        numbers.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator current = numbers.begin();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(numbers.size() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            current ++;</span><br><span class="line">            <span class="keyword">if</span>(current == numbers.end())</span><br><span class="line">                current = numbers.begin();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator next = ++current;</span><br><span class="line">        <span class="keyword">if</span>(next == numbers.end())</span><br><span class="line">            next = numbers.begin();</span><br><span class="line">        current--;</span><br><span class="line">        numbers.erase(current);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：定义一个关于n和m的方程$f(n,m)$，表示每次在n个数字0，1，···，n-1中删除第m个数字最后剩下的数字。</p><p>$$f(n,m)=<br>\begin{cases}<br>0&amp; \text{n=1}\<br>[f(n-1,m)+m]\%n&amp; \text{n&gt;1}<br>\end{cases}$$</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n,<span class="keyword">unsigned</span> <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">        last = (last+m)%i;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题63：股票的最大利润"><a href="#面试题63：股票的最大利润" class="headerlink" title="面试题63：股票的最大利润"></a>面试题63：股票的最大利润</h2><blockquote><p>题目：假设把某股票的价格按照时间先后顺序存储阿紫数组中，请问买卖该股票一次可能获得的最大利润是多少？例如，一只股票在某些时间节点的价格为{9,11,8,5,7,12,16,14}。如果我们能在价格为5的时候买入并在16时卖出，则能收获最大利润11。</p></blockquote><p>思路：最大利润实际就是求数组中所有数对的最大差值，可以在遍历到第i个数字的时候记住前i-1个数中的最小值，就可以获得当前的最高利润了。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDiff</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = input.size();</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> min = input[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> maxDiff = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(input[i<span class="number">-1</span>] &lt; min)</span><br><span class="line">            min = input[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(input[i] - min &gt; maxDiff)</span><br><span class="line">            maxDiff = input[i] - min;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDiff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题64：求1-2-···-n"><a href="#面试题64：求1-2-···-n" class="headerlink" title="面试题64：求1+2+···+n"></a>面试题64：求1+2+···+n</h2><blockquote><p>题目：求1+2+···+n，要求不能使用乘除法、for、while、if、else、switch、case等关键词和条件判断语句。</p></blockquote><p>思路：</p><ol><li>利用构造函数来实现循环：构造函数里写循环内容，数组实例化写循环次数。</li><li>利用递归实现循环，其中判断使用虚函数和数组实现来结束递归。</li><li>用函数指针来模拟虚函数（在纯C环境中）。</li><li>利用模版来实现递归。</li></ol><p>2:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line">A *<span class="built_in">array</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">array</span>[!!n]-&gt;sum(n<span class="number">-1</span>)+n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_Solution2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span>] = &amp;a;</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span>] = &amp;b;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="built_in">array</span>[<span class="number">1</span>]-&gt;sum(n);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*fun)</span><span class="params">(<span class="keyword">unsigned</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">solution3_Teminator</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sum_Solution3</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> fun f[<span class="number">2</span>] = &#123;solution3_Teminator,sum_Solution3&#125;;</span><br><span class="line">    <span class="keyword">return</span> n+f[!!n](n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">unsigned</span> <span class="keyword">int</span> n&gt;<span class="class"><span class="keyword">struct</span> <span class="title">sum_Solution4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> value&#123;N = sum_Solution4&lt;n - <span class="number">1</span>&gt;::N + n&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">sum_Solution4</span>&lt;1&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">enum</span> value&#123; N = <span class="number">1</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="面试题65：不用加减乘除法做加法"><a href="#面试题65：不用加减乘除法做加法" class="headerlink" title="面试题65：不用加减乘除法做加法"></a>面试题65：不用加减乘除法做加法</h2><blockquote><p>题目：写一个函数，求两个整数之和，要求在函数体内不能使用四则运算符号。</p></blockquote><p>思路：利用位运算，来模拟加法，分为三步。</p><ol><li>只做各位的相加不进位。</li><li>做进位。</li><li>将前面两个结果相加。</li></ol><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum,carry;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum = num1 ^ num2;</span><br><span class="line">        carry = (num1 &amp; num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        num1 = sum;</span><br><span class="line">        num2 = carry;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//num2用来存储进位，并不断相加</span></span><br><span class="line">    <span class="keyword">while</span>(num2 != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题66：构建乘积数组"><a href="#面试题66：构建乘积数组" class="headerlink" title="面试题66：构建乘积数组"></a>面试题66：构建乘积数组</h2><blockquote><p>题目：给定一个数组$A[0,1,…,n-1]$，请构建一个数组$B[0,1,…,n-1]$，其中B的元素$B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]$。不能使用除法。</p></blockquote><p>思路：如果可以使用除法，就可以用数组所有数的乘积除以当前数（注意0的情况）。</p><p>定义$C[i]=A[0]<em>A[1]</em>…<em>A[i-1]，D[i]=A[i+1]</em>…<em>A[n-2]</em>A[n-1]$。</p><p>这两个数组可以用自上而下和自下而上的顺序计算出来。然后B数组就出来了。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">multiply</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;input,<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = input.size();</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    output.resize(length,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//tmpC存储的是C数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; tmpC(length,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmpC[i] = tmpC[i<span class="number">-1</span>]*input[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//tmpD存储的是D数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; tmpD(length,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = length<span class="number">-2</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        tmpD[i] = tmpD[i+<span class="number">1</span>]*input[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = length<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        output[i]=tmpD[i]*tmpC[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面试题61：扑克牌中的顺子&quot;&gt;&lt;a href=&quot;#面试题61：扑克牌中的顺子&quot; class=&quot;headerlink&quot; title=&quot;面试题61：扑克牌中的顺子&quot;&gt;&lt;/a&gt;面试题61：扑克牌中的顺子&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目：从扑克牌中随机抽5张
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer习题学习过程51-60</title>
    <link href="http://yoursite.com/2019/06/19/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B51-60/"/>
    <id>http://yoursite.com/2019/06/19/剑指offer习题学习过程51-60/</id>
    <published>2019-06-19T07:02:23.000Z</published>
    <updated>2019-06-19T07:06:51.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题51：数组中的逆序对"><a href="#面试题51：数组中的逆序对" class="headerlink" title="面试题51：数组中的逆序对"></a>面试题51：数组中的逆序对</h2><blockquote><p>题目：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组的逆序对的个数。例如，在数组{7,5,6,4}中,一共有5个逆序对，分别是(7,6),(7,5),(7,4),(6,4),(5,4)。</p></blockquote><p>思路：暴力算法的时间复杂度是$O(n^2)$。</p><p>每扫描到一个数，为了避免拿它和后面每一个数进行比较，考虑先比较两个相邻的数字。（利用并归排序的思想）<br>统计逆序对的过程：先把数组分隔成子数组，统计出子数组内部的逆序对的数目，统计完之后进行排序，之后再统计相邻子数组之间的逆序对的数目。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = input.size();</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; copyInput;</span><br><span class="line">copyInput = input;</span><br><span class="line">    <span class="keyword">int</span> count = inversePairsCore(input,copyInput,<span class="number">0</span>,length - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inversePairsCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;copyInput,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end)</span><br><span class="line">    &#123;</span><br><span class="line">        copyInput[start] = input[start];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> length = (end - start)/<span class="number">2</span>;</span><br><span class="line"><span class="comment">//这里特别需要注意原数组和辅助数组所在的位置，这里递归很不好理解，每次返回data(input)都是有序的（调用内部对data，即函数内部的tmp排序）</span></span><br><span class="line">    <span class="comment">//出来过后data有序了，又使用data对copyInput排序，这样外部的data又是有序的了</span></span><br><span class="line">    <span class="keyword">int</span> left = inversePairsCore(copyInput,input,start,start+length);</span><br><span class="line">    <span class="keyword">int</span> right = inversePairsCore(copyInput,input,start+length+<span class="number">1</span>,end);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = start+length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = end;</span><br><span class="line">    <span class="keyword">int</span> indexCopy = end;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//两个子数组之间逆序对的计数</span></span><br><span class="line">    <span class="keyword">while</span>(i &gt;= start &amp;&amp; j &gt;= start+length+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(input[i] &gt; input[j])</span><br><span class="line">        &#123;</span><br><span class="line">            copyInput[indexCopy--] = input[i--];</span><br><span class="line">            count += (j-start - length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            copyInput[indexCopy--] = input[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i &gt;= start;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        copyInput[indexCopy--] = input[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(;j &gt;= start + length + <span class="number">1</span>;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        copyInput[indexCopy--] = input[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left+right+count;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目52：两个链表的第一个公共节点"><a href="#题目52：两个链表的第一个公共节点" class="headerlink" title="题目52：两个链表的第一个公共节点"></a>题目52：两个链表的第一个公共节点</h2><blockquote><p>题目：输入两个链表，找出它们的第一个公共节点。链表的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span></span></span><br><span class="line"><span class="class">&gt; &#123;</span></span><br><span class="line">&gt;     <span class="keyword">int</span> m_key;</span><br><span class="line">&gt;     listNode* m_pNext;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>思路：如果第一个链表的长度为m，第二个链表的长度为n，暴力解法的时间复杂度为$O(mn)$。</p><p>两个单向链表有公共节点，它们的尾节点肯定是相同节点，需要从后向前遍历寻找，可以利用栈来实现单向链表的从后向前遍历。但是用栈也会浪费空间复杂度，可以记录两者的长度，较长的一端就可以先走，以保证两个链表会同时遍历到尾节点。</p><p>解法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">listNode* <span class="title">findFirstCommonNode</span><span class="params">(listNode* pHead1,listNode* pHead2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length1 = getListLength(pHead1);</span><br><span class="line">    <span class="keyword">int</span> length2 = getListLength(pHead2);</span><br><span class="line">    <span class="keyword">if</span>(length1 &gt; length2)</span><br><span class="line">    &#123;</span><br><span class="line">        lengthDif = length1 - length2;</span><br><span class="line">        listNode* listNodeLong = pHead1;</span><br><span class="line">        listNode* listNodeShort = pHead2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        lengthDif = length2 - length1;</span><br><span class="line">        listNode* listNodeLong = pHead2;</span><br><span class="line">        listNode* listNodeShort = pHead1;     </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; lengthDif;<span class="number">1</span>++)</span><br><span class="line">        listNodeLong = listNodeLong-&gt;m_pNext;</span><br><span class="line">    <span class="keyword">while</span>(listNodeLong != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">         listNodeShort != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">         listNodeLong != listNodeShort)</span><br><span class="line">    &#123;</span><br><span class="line">        listNodeLong = listNodeLong-&gt;m_pNext;</span><br><span class="line">        listNodeShort = listNodeShort-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    listNode* firstCommonNode = listNodeLong;</span><br><span class="line">    <span class="keyword">return</span> firstCommonNode;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getListLength</span><span class="params">(listNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">while</span>(pHead == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        length ++;</span><br><span class="line">        pHead = pHead-&gt;m_pNext;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="题目53：在排序数组中查找数字"><a href="#题目53：在排序数组中查找数字" class="headerlink" title="题目53：在排序数组中查找数字"></a>题目53：在排序数组中查找数字</h2><blockquote><p>题目一：统计数字在排序数组中出现的次数。例如，输入排序数组{1,2,3,3,3,3,4,5}和数字3，由于3在这个数组中出现了4次，因此输出4。</p></blockquote><p>思路：二分法查找，和普通二分法的区别在于需要找到目标出现的第一次和最后一次的位置。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = input.size();</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//寻找第一次出现的</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> middle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        middle = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(input[middle] == target)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span>(middle &gt; <span class="number">0</span> &amp;&amp; input[middle<span class="number">-1</span>] != target </span><br><span class="line">  || middle == <span class="number">0</span>)</span><br><span class="line">  &#123;first = middle;<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(input[middle] &gt; target)</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = middle + <span class="number">1</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一次出现的</span></span><br><span class="line">    left = <span class="number">0</span>;</span><br><span class="line">    right = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        middle = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(input[middle] == target)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span>(middle &gt; <span class="number">0</span> &amp;&amp; input[middle+<span class="number">1</span>] != target </span><br><span class="line">  || middle == <span class="number">0</span>)</span><br><span class="line">&#123;last = middle;<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(input[middle] &gt; target)</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = middle + <span class="number">1</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"first: "</span>&lt;&lt;first&lt;&lt;<span class="string">"last: "</span>&lt;&lt;last&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(first &gt; <span class="number">0</span> &amp;&amp; last &gt; <span class="number">0</span>)</span><br><span class="line">        result = last - first + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目二：0~n-1中缺失的数字，一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0~n-1之内。在范围0~n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p></blockquote><p>思路：简单想法是求出0~n-1的数字之和$s1$（通过公式$n(n-1)/2$计算得出），然后计算出数组中数字之和$s2$，缺失的数字即$s2-s1$。时间复杂度为$O(n)$。</p><p>利用二分法，在数组中找到第一个值不等于序列的位置。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMissNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = input.size();</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(input[middle] != middle)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span>(middle &gt; <span class="number">0</span> &amp;&amp; input[middle<span class="number">-1</span>] == middle<span class="number">-1</span> </span><br><span class="line">  || middle == <span class="number">0</span>)</span><br><span class="line">&#123;result = middle;<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = middle + <span class="number">1</span>; </span><br><span class="line"><span class="comment">//缺少的是最后一个数的可能</span></span><br><span class="line"><span class="keyword">if</span>(left == length) result = length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目三：数组中数值和下标相等的元素，假设一个单调递增的数组里的每个元素都是整数并且是唯一的。实现一个函数，找出数组中任意一个数值等于其下表的元素。例如，在数组{-3,-1,1,3,5}中，数字3和它的下标相等。</p></blockquote><p>思路：还是二分法，区别在于判断条件的变化（没啥好说的了）。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumberSameAsIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = input.size();</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(input[middle] == middle)</span><br><span class="line">&#123;result = middle;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (input[middle] &lt; middle)</span><br><span class="line">            left = middle + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            right = middle - <span class="number">1</span>;         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题54：二叉搜索树的第k大节点"><a href="#面试题54：二叉搜索树的第k大节点" class="headerlink" title="面试题54：二叉搜索树的第k大节点"></a>面试题54：二叉搜索树的第k大节点</h2><blockquote><p>题目：给定一棵二叉搜索树，找出其中第k大的节点。</p></blockquote><p>思路：二叉搜索树的中序遍历的结果就是递增排序的结果。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">binaryTreeNode* <span class="title">getKthNode</span><span class="params">(binaryTreeNode* pRoot,<span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span> || k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> getKthNodeCore(pRoot,k);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">binaryTreeNode* <span class="title">getKthNodeCore</span><span class="params">(binaryTreeNode* pRoot,<span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    binaryTreeNode* target == <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pRoot-&gt;m_pLeft != <span class="literal">nullptr</span>)</span><br><span class="line">        target = getKthNodeCore(pRoot-&gt;m_pLeft,k);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(target == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">            target = pRoot;        </span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(target == <span class="literal">nullptr</span> &amp;&amp; pRoot-&gt;m_pRight != <span class="literal">nullptr</span>)</span><br><span class="line">        target = getKthNodeCore(pRoot-&gt;m_pRight,k);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> target;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题55：二叉树的深度"><a href="#面试题55：二叉树的深度" class="headerlink" title="面试题55：二叉树的深度"></a>面试题55：二叉树的深度</h2><blockquote><p>题目一：二叉树的深度，输入一棵二叉的根节点，求该树的深度。从根节点到叶节点依次经过的节点形成树的一条路径，最长路径为树的深度。</p></blockquote><p>思路：如果一个节点只有左子树，那么深度就是左子树的深度+1，如果只有右子树，那么深度就是右子树的深度+1。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTreeDepth</span><span class="params">(binaryTreeNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = getTreeDepth(pRoot-&gt;m_pLeft);</span><br><span class="line">    <span class="keyword">int</span> right = getTreeDepth(pRoot-&gt;m_pRight);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left &gt; right? (left+<span class="number">1</span>) : (right+<span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目二：平衡二叉树，输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果左右节点的深度相差不大于1，就是平衡二叉树。</p></blockquote><p>思路：暴力解法是遍历二叉树的每个节点，计算出左右节点的深度，判断深度相差是否大于1。但这种方法会重复遍历一个节点。</p><p>如果用后序遍历，就可以先遍历左右节点，记录下它的深度之后，一边遍历一边判断是否平衡。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalancedCore</span><span class="params">(binaryTreeNode* pRoot,<span class="keyword">int</span> &amp;depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left,right;</span><br><span class="line">    <span class="keyword">if</span>( isBalancedCore(pRoot-&gt;m_pLeft,left) &amp;&amp; isBalancedCore(pRoot-&gt;m_pRight,right) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = left - right;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(diff) &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//返回整体二叉树深度的</span></span><br><span class="line">            depth = <span class="number">1</span> + (left &gt; right?lefft:right);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(binaryTreeNode* pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> isBalancedCore(pRoot,depth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题56：数组中数字出现的次数"><a href="#面试题56：数组中数字出现的次数" class="headerlink" title="面试题56：数组中数字出现的次数"></a>面试题56：数组中数字出现的次数</h2><blockquote><p>题目一：数组中只出现一次的两个数字，一个整型数组里除两个数字外，其他数字都出现了两次。请找出这两个只出现一次的数字。要求时间复杂度是$O(n)$，空间复杂度是$O(1)$。例如在数组{2,4,3,6,3,2,5,5}中出现一次的数字是4，6。</p></blockquote><p>思路：先把题目分割成数组只出现一次的一个数字，题目中的关键词是其他数字都出现两次，这里和异或的性质相匹配（任何一个数字和自己的异或都为0），如果将数组中所有的数字依次异或，那么留下来的就是只出现一次的数字。</p><p>再回到出现一次的两个数字的情况，如果还是依次异或的话，最后留下的是这两个数字异或的结果，其中可以依据结果中出现1的第n位将两个数字区分开来，就将第n位是否为1作为评断标准把数组分为两组，就可以把问题分解成两个上面的小问题。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBit1</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">unsigned</span> <span class="keyword">int</span> indexBit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num = num &gt;&gt;indexBit;</span><br><span class="line">    <span class="keyword">return</span> (num &amp; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">findFirstBits1</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> indexBit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((num &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; indexBit &lt; <span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        num = num &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        indexBit ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> indexBit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findNumberAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = input.size();</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">2</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp ^= input[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> indexBit = findFirstBits1(tmp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> result2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isBit1(input[i],indexBit))</span><br><span class="line">        result1 ^= input[i];</span><br><span class="line">        <span class="keyword">else</span>            </span><br><span class="line">        result2 ^= input[i];</span><br><span class="line">    &#125;</span><br><span class="line">    output.push_back(result1);</span><br><span class="line">    output.push_back(result2);       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目二：数组中唯一出现一次的数字，在一个数组中除了一个数字只出现一次之外，其他数字都出现了三次。请找出只出现一次的数字。</p></blockquote><p>思路：关键在于其他数字出现三次，同样是沿用位运算的思路，如果一个数字出现三次，那么他的二进制的每一位数加起来都能被3整除。那么把所有数组中的数加起来计算，没有被3整除的那一位就是只出现一次数字的为1的位数。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设int有32位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findNumberAppearTriple</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = input.size();    </span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">1</span>) <span class="keyword">throw</span> runtime_error(<span class="string">"Invalid Parameters."</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> bitSum[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> bitMask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">31</span>;j &gt;= <span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = input[i] &amp; bitMask;</span><br><span class="line">            bitSum[j] += bit;</span><br><span class="line">            bitMask = bitMask &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result = result&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">" :"</span>&lt;&lt;result;</span><br><span class="line">        result += bitSum[i]%<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题57：和为s的数字"><a href="#面试题57：和为s的数字" class="headerlink" title="面试题57：和为s的数字"></a>面试题57：和为s的数字</h2><blockquote><p>题目一：和为s的两个数字，输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得他们的和正好是s。如果有多对数字的和等于s，则输出任意一堆即可。</p></blockquote><p>思路：暴力解法的时间复杂度为$O(n^2)$。</p><p>定义两个指针，一个指向头部，一个指向尾部。计算他们的和，当和小于目标时，第一个指针向后移动；当和大于目标时，第二个指针向前移动。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findNumbersWithSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;output,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> length = input.size();</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = input[left] + input[right];</span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            output.push_back(input[left]);</span><br><span class="line">            output.push_back(input[right]);</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)</span><br><span class="line">            left ++;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            right --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目二：和为s的连续正数序列，输入一个正数，打印出所有和为s的连续正数序列（至少含有两个数）。例如输入15，由于$1+2+3+4+5=4+5+6=7+8=15$，所以打印出3个连续序列1~5，4~6和7~8。</p></blockquote><p>思路：沿用前面问题的思想，用两个数来表示序列的最小值和最大值。首先将两者初始化为1，2。如果序列的和大于目标数，则增大最小值；如果序列的和小于目标数，则增大最大值；如果等于目标值，则增大最大值并继续遍历直到遍历结束（最小值大于目标值的一半）。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findContinuousSequence</span><span class="params">(<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> middle = (<span class="number">1</span>+sum)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> curSum = left + right;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; middle)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(curSum == sum)</span><br><span class="line">           printContinuousSequence(left,right);            </span><br><span class="line"> </span><br><span class="line">        <span class="comment">//序列和大于目标数的情况</span></span><br><span class="line">        <span class="keyword">while</span>(curSum &gt; sum &amp;&amp; left &lt; middle)</span><br><span class="line">        &#123;</span><br><span class="line">            curSum -= left;</span><br><span class="line">            left ++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(curSum == sum)</span><br><span class="line">                printContinuousSequence(left,right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//序列和小于目标数或者等于目标的情况</span></span><br><span class="line">        right ++;</span><br><span class="line">        curSum += right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printContinuousSequence</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = left;i &lt;= right;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">','</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题58：翻转字符串"><a href="#面试题58：翻转字符串" class="headerlink" title="面试题58：翻转字符串"></a>面试题58：翻转字符串</h2><blockquote><p>题目一：翻转单词顺序，输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变，标点符号和普通字母一样处理。例如，输入字符串”I am a student.”，则输出”student.a am I”。</p></blockquote><p>思路：第一步翻转句子中所有的字符，比如翻转”I am a student.”可以得到”.tneduts a ma I”，第二步翻转每个单词中字符的顺序，就得到了”student.a am I”。关键在于实现一个函数来翻转字符串中的一段。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">char</span> *pBegin,<span class="keyword">char</span> *pEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pBegin == <span class="literal">nullptr</span> || pEnd == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span>(pBegin &lt; pEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = *pBegin;</span><br><span class="line">        *pBegin = *pEnd;</span><br><span class="line">        *pEnd = tmp;</span><br><span class="line">        pBegin++;</span><br><span class="line">        pEnd--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">reverseSentence</span><span class="params">(<span class="keyword">char</span> *pData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *pBegin = pData;</span><br><span class="line">    <span class="keyword">char</span> *pEnd = pData;</span><br><span class="line">    <span class="keyword">while</span>(*pEnd != <span class="string">'\0'</span>)</span><br><span class="line">        pEnd++;</span><br><span class="line">    pEnd--;</span><br><span class="line">    </span><br><span class="line">    Reverse(pBegin,pEnd);</span><br><span class="line">    </span><br><span class="line">    pBegin = pEnd = pData; </span><br><span class="line">    <span class="keyword">while</span>(*pBegin != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*pBegin == <span class="string">' '</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pBegin ++;</span><br><span class="line">            pEnd ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*pEnd == <span class="string">' '</span> || *pEnd == <span class="string">'\0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Reverse(pBegin,--pEnd);</span><br><span class="line">            pEnd++;</span><br><span class="line">            pBegin = pEnd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pEnd++;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目二：左旋转字符串，字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。例如，输入字符串”abcdefg”和数字2，输出”cdefgab”。</p></blockquote><p>思路：以”abcdefg”为例，把它分成两个部分，”ab”和”cdefg”。第一步先分别翻转这两个部分，得到”bagfedc”，第二部翻转整个部分，得到”cdfegab”。<br>也可以先翻转整个部分，得到”gfedcba”，再翻转两个部分”gfedc”和”ba”，得到”cdefgab”。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">char</span> *pBegin,<span class="keyword">char</span> *pEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pBegin == <span class="literal">nullptr</span> || pEnd == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span>(pBegin &lt; pEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = *pBegin;</span><br><span class="line">        *pBegin = *pEnd;</span><br><span class="line">        *pEnd = tmp;</span><br><span class="line">        pBegin++;</span><br><span class="line">        pEnd--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">leftRotateString</span><span class="params">(<span class="keyword">char</span>* pData,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;    </span><br><span class="line">    <span class="keyword">int</span> length = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">strlen</span>(pData));</span><br><span class="line">    <span class="keyword">if</span>(length &gt; <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span> &amp;&amp; length &gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span>* pFirstBegin = pData;</span><br><span class="line">        <span class="keyword">char</span>* pFirstEnd = pData + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>* pSecondBegin = pData + n;</span><br><span class="line">        <span class="keyword">char</span>* pSecondEnd = pData + length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        Reverse(pFirstBegin,pFirstEnd);</span><br><span class="line">        Reverse(pSecondBegin,pSecondEnd);</span><br><span class="line">        Reverse(pData,pSecondEnd);            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题59：队列的最大值"><a href="#面试题59：队列的最大值" class="headerlink" title="面试题59：队列的最大值"></a>面试题59：队列的最大值</h2><blockquote><p>题目一：滑动窗口的最大值，给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。例如，输入数组{2,3,4,2,6,2,5,1}以及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}。</p></blockquote><p>思路：暴力算法的时间复杂度为$O(nk)$。</p><p>一种方法：在面试题30中，实现了一个可以用$O(1)$时间得到最小值的栈，在面试9中，讨论了如何用两个栈实现一个队列。综合两个解决方案，就可以得到在$O(1)$时间内得到最大值的栈，总的时间复杂度就降到了$O(n)$。</p><p>另一种方法：并不把滑动窗口的每个数值都存入队列，而是把有可能成为滑动窗口最大值的数值存入一个两端开口的队列(deque)。队列中只储存有可能成为最大值数值的索引下标（为的是知道滑动窗口是否包括现在队列里的数）。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num,<span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows;</span><br><span class="line">    <span class="keyword">if</span>(num.size() &lt; size &amp;&amp; size &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> maxInWindows;</span><br><span class="line">    <span class="comment">//头部放的最大值，尾部放的次最大值</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line">    <span class="comment">//初始化滑窗</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当滑入数字比当前次最大值大时，弹出现有最大值</span></span><br><span class="line">        <span class="keyword">while</span>(!index.empty() &amp;&amp; num[i] &gt;= num[index.back()])</span><br><span class="line">            index.pop_back();</span><br><span class="line">        index.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = size;i &lt; num.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        maxInWindows.push_back(num[index.front()]);</span><br><span class="line">        <span class="comment">//当滑入数字比当前次最大值大时，弹出现有最大值</span></span><br><span class="line">        <span class="keyword">while</span>(!index.empty() &amp;&amp; num[i] &gt;= num[index.back()])</span><br><span class="line">            index.pop_back();</span><br><span class="line">        <span class="comment">//当滑窗中最大值不在滑窗包含之内时被弹出</span></span><br><span class="line">        <span class="keyword">if</span>(!index.empty() &amp;&amp; index.front() &lt;= (<span class="keyword">int</span>)(i - size))</span><br><span class="line">            index.pop_front();</span><br><span class="line">        </span><br><span class="line">        index.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    maxInWindows.push_back(num[index.front()]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxInWindows;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目二：队列的最大值，定义一个队列并实现函数max得到队列里的最大值，要求函数max，push_back，和pop_front的时间复杂度都是$O(1)$。</p></blockquote><p>思路：和前面类似，滑动窗口可以看出一个队列，上题的解法可以显示带max函数的队列。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">queueWithMax</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    QueueWithMax():currentIndex(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T number)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!maximums.empty() &amp;&amp; number &gt;= maximums.back().number)</span><br><span class="line">            maximums.pop_back();</span><br><span class="line">        InternalData internalData = &#123;number,currentIndex&#125;;</span><br><span class="line">        <span class="comment">//正常的push_back操作</span></span><br><span class="line">        data.push_back(internalData);            </span><br><span class="line">        internalData.push_back(internalData);</span><br><span class="line">        currentIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(maximums.empty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> exception(<span class="string">"queue is empty."</span>);</span><br><span class="line">        <span class="keyword">if</span>(maximums.front().index == data.front().index)</span><br><span class="line">            maximums.pop_front;</span><br><span class="line">        data.pop_front();</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function">T <span class="title">max</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(maximums.empty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> exception(<span class="string">"queue is empty."</span>);</span><br><span class="line">        <span class="keyword">return</span> maximums.front().number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">InternalData</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        T number;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">deque</span>&lt;InternalData&gt; data;</span><br><span class="line">    <span class="comment">//用来存放最大值的窗口</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;InternalData&gt; maximums;</span><br><span class="line">    <span class="comment">//用来记录最大值序列，保证在pop操作时，能够正确pop  </span></span><br><span class="line">    <span class="keyword">int</span> currentIndex;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题60：n个骰子的点数"><a href="#面试题60：n个骰子的点数" class="headerlink" title="面试题60：n个骰子的点数"></a>面试题60：n个骰子的点数</h2><blockquote><p>题目：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p></blockquote><p>思路：n个骰子的点数和最小值为n，最大值为6n，所有点数的排列数为$6^n$。想求出n个骰子的点数和，把n个骰子分为两堆：第一堆只有一个；另一堆有n-1个。单独那一个有可能出现1~6的点数，还需要计算剩余n-1个骰子的点数。如此递归下去直到只剩下一个骰子。<br>我们用两个数组来存储骰子点数的每个总数出现的次数。在一轮循环中，第一个数组中的第n个数字表示骰子和为n出现的次数。在下一轮循环中，加一个新的骰子，此时和为n的骰子出现的次数，应该等于上一轮循环中骰子点数为n-1、n-2、n-3、n-4、n-5、n-6的总和，所以把另一个数组的第n个数字设为前一个数组第n-1、n-2、n-3、n-4、n-5、n-6个数字之和。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printProbability</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number &lt; <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>* pProbability[<span class="number">2</span>];</span><br><span class="line">    pProbability[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[g_maxValue*number+<span class="number">1</span>];</span><br><span class="line">    pProbability[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[g_maxValue*number+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; g_maxValue*number;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pProbability[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        pProbability[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//flag用来切换两个数组的使用</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化第一个数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= g_maxValue;i++)</span><br><span class="line">        pProbability[flag][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//k代表第几个骰子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>;k &lt;=number;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++)</span><br><span class="line">            pProbability[<span class="number">1</span>-flag][i] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k;i &lt;= g_maxValue*k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pProbability[<span class="number">1</span>-flag][i] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//这里代表上一轮n-1、n-2、n-3、n-4、n-5、n-6的个数之和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i&amp;&amp; j &lt;= g_maxValue;j++)</span><br><span class="line">                pProbability[<span class="number">1</span>-flag][i] += pProbability[flag][i-j];</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="number">1</span> - flag;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印几率</span></span><br><span class="line">    <span class="keyword">double</span> total = <span class="built_in">pow</span>((<span class="keyword">double</span>)g_maxValue,number);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = number;i &lt;= g_maxValue*number;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> ratio = (<span class="keyword">double</span>)pProbability[flag][i] /total;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">' '</span>&lt;&lt;ratio&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] pProbability[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] pProbability[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面试题51：数组中的逆序对&quot;&gt;&lt;a href=&quot;#面试题51：数组中的逆序对&quot; class=&quot;headerlink&quot; title=&quot;面试题51：数组中的逆序对&quot;&gt;&lt;/a&gt;面试题51：数组中的逆序对&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目：在数组中的两个数字，
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer习题学习过程41-50</title>
    <link href="http://yoursite.com/2019/06/19/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B41-50/"/>
    <id>http://yoursite.com/2019/06/19/剑指offer习题学习过程41-50/</id>
    <published>2019-06-19T07:02:08.000Z</published>
    <updated>2019-06-19T07:06:46.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题41：数据流中的中位数"><a href="#面试题41：数据流中的中位数" class="headerlink" title="面试题41：数据流中的中位数"></a>面试题41：数据流中的中位数</h2><blockquote><p>题目：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p></blockquote><p>要点：数组里，如果是没有排序的数组，则插入一个数的视觉复杂度是O(1)，找出中位数的时间复杂度是O(n)。<br>排序的数组里，插入的时间复杂度是O(n)，找出中位数的时间复杂度是O(1)。</p><p>二叉搜索树里，插入数据时间复杂度是O(logn)，为了得到中位数，需要在二叉树节点添加一个表示子树节点数目的字段，就可以在O(logn)时间内得到中位数。</p><p>为了避免二叉搜索树中最差的情况，可以用平衡搜索二叉树，即AVL树，将原来代表左右子树高度差的平衡因子改为数目之差，中位数获取时间变为O(1)。</p><table><thead><tr><th>数据结构</th><th>插入的时间复杂度</th><th>得到中位数的时间复杂度</th></tr></thead><tbody><tr><td>没有排序的数组</td><td>O(1)</td><td>O(n)</td></tr><tr><td>排序的数组</td><td>O(n)</td><td>O(1)</td></tr><tr><td>排序的链表</td><td>O(n)</td><td>O(1)</td></tr><tr><td>二叉搜索树</td><td>平均O(logn)，最差O(n)</td><td>平均O(logn)，最差O(n)</td></tr><tr><td>AVL数</td><td>O(logn)</td><td>O(1)</td></tr><tr><td>最大堆和最小堆</td><td>O(logn)</td><td>O(1)</td></tr></tbody></table><p>用一个最大堆来放置左边数据，最小堆放置右边数据，为了使得两个堆的总数差不超过1，利用奇偶来分配不同的堆。插入时，如果一个新的数比最大堆的堆顶小，则将新的数据插入最大堆，再将最大堆的最大数插入最小堆。用STL中的push_heap,pop_heap以及vector实现堆。仿函数less,greater实现最大堆和最小堆。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">dynamicArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//偶数个数</span></span><br><span class="line">        <span class="keyword">if</span>( (min.size()+max.size()) &amp; <span class="number">1</span> == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//插入最大堆，比堆顶小</span></span><br><span class="line">            <span class="keyword">if</span>(max.size() &gt; <span class="number">0</span> &amp;&amp; num &lt; max[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                max.push_back(num);</span><br><span class="line">                push_heap(max.begin(),max.end(),less&lt;T&gt;());</span><br><span class="line">                </span><br><span class="line">                num = max[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">//将堆顶和最后一个数对调</span></span><br><span class="line">                pop_heap(max.begin(),max.end(),less&lt;T&gt;());</span><br><span class="line">                <span class="comment">//弹出刚才对调的堆顶</span></span><br><span class="line">                max.pop_back;</span><br><span class="line">            &#125;</span><br><span class="line">            min.push_back(num);</span><br><span class="line">            push_heap(min.begin(),min.end(),greater&lt;T&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//奇数插入，比最小堆堆顶大</span></span><br><span class="line">            <span class="keyword">if</span>(min.size() &gt; <span class="number">0</span> &amp;&amp; min[<span class="number">0</span>] &lt; num)</span><br><span class="line">            &#123;</span><br><span class="line">                min.push_back(num);</span><br><span class="line">                push_heap(min.begin(),min.end(),greater&lt;T&gt;());</span><br><span class="line">                </span><br><span class="line">                num = min[<span class="number">0</span>];</span><br><span class="line">                </span><br><span class="line">                pop_heap(min.begin(),min.end(),greater&lt;T&gt;());</span><br><span class="line">                min.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            max.push_back(num);</span><br><span class="line">            push_heap(max.begin(),max.end(),less&lt;T&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T <span class="title">getMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = min.size() + max.size();</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> exception(<span class="string">"no value"</span>);</span><br><span class="line">        T median;</span><br><span class="line">        <span class="comment">//奇数</span></span><br><span class="line">        <span class="keyword">if</span>((size&amp;<span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            <span class="comment">//由于奇数插入最小堆，所以最小堆数目多1</span></span><br><span class="line">            median = min[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            median = (max[<span class="number">0</span>]+min[<span class="number">0</span>])/<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> median;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; min;</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; max;</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用insert插入从数据流读到的数据，getMedian取得已获得数据的中位数。</p><h2 id="面试题42：连续子数组的最大和"><a href="#面试题42：连续子数组的最大和" class="headerlink" title="面试题42：连续子数组的最大和"></a>面试题42：连续子数组的最大和</h2><blockquote><p>题目：输入一个整形数组，数组里有正数也有负数。数组中一个或者多个连续整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。</p></blockquote><p>思路：动态规划，$f(i) = max(pData[i] , f(i-1)+pData[i])$。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = input.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp.size() == <span class="number">0</span> || dp(i - <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dp.push_back(input(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dp(i - <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = dp[i] &gt; (f(i) + dp[i<span class="number">-1</span>])? dp[i] : f(i) + dp[i<span class="number">-1</span>];</span><br><span class="line">            dp.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题43：1-n整数中出现1的次数"><a href="#面试题43：1-n整数中出现1的次数" class="headerlink" title="面试题43：1~n整数中出现1的次数"></a>面试题43：1~n整数中出现1的次数</h2><blockquote><p>题目：输入一个整数，求1~n这n个整数十进制表示中出现1的次数。</p></blockquote><p>思路：比如计算1~21345中所有出现1的次数。把其分为两段，一段是1~1345，一段是1346~21345。<br>先分析1346~21345，1的出现分为两种情况。</p><ol><li><p>首先分析1出现在最高位的情况。在1346~21345中，1出现在10000~19999这10000个数字的万位，一共出现了10000次即$10^4$。对于一般情况，最高位是1的时候，次数不是$10^4$，而是除去最高位后剩下的数字再加1（1345+1）。</p></li><li><p>再分析1出现在除最高位之外的情况。1346~21345这20000个数字中后4位中1出现的次数是8000次。由于最高位是2，可以再把1346~21345分为两段：1346~11345和11346~21345。每一段剩下的4位数字中，选择其中一位是1，其余三位可以是0~9，根据排列组合，总共出现次数是$2x4x10^3=8000$次。<br> 再分析1~1345，就可以用递归求得。</p><p>这种解法的思路是每次去掉最高为进行递归，递归次数和位数相同，一个数字n有O(logn)位，所以这种思路的时间复杂度是O(logn)。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> strN[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(strN,<span class="string">"%d"</span>,n);<span class="comment">//转化为字符串便于编程。</span></span><br><span class="line"><span class="keyword">return</span> NumberOf1(strN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* strN)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!strN || *strN &lt; <span class="string">'0'</span> || *strN &gt; <span class="string">'9'</span> || *strN == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> first = *strN - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> length = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(<span class="built_in">strlen</span>(strN));</span><br><span class="line">    <span class="comment">//判断个位数的情况</span></span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">1</span> &amp;&amp; first ==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(length ==<span class="number">1</span> &amp;&amp; first &gt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//假设strN是“21345”</span></span><br><span class="line">    <span class="keyword">int</span> numFirstDigit=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(first &gt; <span class="number">1</span>)</span><br><span class="line">        numFirstDigit = powerBase10(length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(first == <span class="number">1</span>)</span><br><span class="line">        numFirstDigit = atoi(strN+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//numOtherDigits是1346~21345除第一位之外的1的数目</span></span><br><span class="line">    <span class="keyword">int</span> numOtherDigits = first*(length - <span class="number">1</span>)*powerBase10(length - <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//numRecursive是1~1345中的数目，也是递归的入口</span></span><br><span class="line">    <span class="keyword">int</span> numRecursive = NumberOf1(strN+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> numFirstDigit+numOtherDigits+numRecursive;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">powerBase10</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result*=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="面试题44：数字序列中某一位的数字"><a href="#面试题44：数字序列中某一位的数字" class="headerlink" title="面试题44：数字序列中某一位的数字"></a>面试题44：数字序列中某一位的数字</h2><blockquote><p>题目：数字以01234567891011121314···的格式序列化到字符序列中。再这个序列中，第5为（从0开始计数）是5，低13为是1，第19为是4。写出一个函数，求任意第n为对应的数字。</p></blockquote><p>思路：一位数字有0~9一共10个二位数字有10~99一共180个，三位数字有100~999一共2700个，以此为区别寻找。比如811位，大于180，所以属于三位数字，$811=270*3+1$，这意味着811位是从100开始的第270个数字即370的中间一位，即7。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">beginNumber</span><span class="params">(<span class="keyword">int</span> digits)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">digitAtIndex</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> digits)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOfIntegers</span><span class="params">(<span class="keyword">int</span> digits)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">digitAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">digitAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> digits = <span class="number">1</span>;<span class="comment">//代表几位数字</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> numbers = countOfIntegers(digits);<span class="comment">//用来计算几位多少个数字的</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; numbers*digits)</span><br><span class="line">            <span class="keyword">return</span> digitAtIndex(index,digits);</span><br><span class="line">        index-=digits*numbers;</span><br><span class="line">        digits++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算m位一共有多少个，比如1：10，2：90，3：900</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOfIntegers</span><span class="params">(<span class="keyword">int</span> digits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(digits == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> count = (<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">10</span>,digits<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">9</span>*count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//知道位数和序列后，就可以好到那个数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">digitAtIndex</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> digits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 811 = 270*3+1，number = 270+100</span></span><br><span class="line">    <span class="keyword">int</span> number = beginNumber(digits)+index/digits;</span><br><span class="line">    <span class="comment">//从右数第几位，</span></span><br><span class="line">    <span class="keyword">int</span> indexFromRight = digits - index%digits;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; indexFromRight;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        number/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number%<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到m位数的第一个数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">beginNumber</span><span class="params">(<span class="keyword">int</span> digits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(digits == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">10</span>,digits<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题45：把数组排成最小的数"><a href="#面试题45：把数组排成最小的数" class="headerlink" title="面试题45：把数组排成最小的数"></a>面试题45：把数组排成最小的数</h2><blockquote><p>题目：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出所有数字中最小的一个。例如输入数组：{3，32，321}，则这三个数字能拼成的最小数字是321323。</p></blockquote><p>思路：自定义一个新的对比规则：有两个数m和n，能拼接成mn和nm，如果mn&lt;nm，则m小于n，如果nm&lt;mn则n小于m，如果mn=nm则m等于n。</p><p>拼接数字可能溢出，需要用字符串解决大数问题。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="built_in">string</span> strNumber1,<span class="built_in">string</span> strNumber2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = numbers.size();</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strNumbers;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> tmp : numbers)</span><br><span class="line">    &#123;</span><br><span class="line">        strNumbers.push_back(to_string(tmp));</span><br><span class="line">    &#125;</span><br><span class="line">    sort(strNumbers.begin(),strNumbers.end(),compare);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> tmp : strNumbers)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="built_in">string</span> strNumber1,<span class="built_in">string</span> strNumber2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> strCombine1 = strNumber1 + strNumber2;</span><br><span class="line">    <span class="built_in">string</span> strCombine2 = strNumber2 + strNumber1;</span><br><span class="line">    <span class="keyword">return</span> strCombine1.compare(strCombine2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; target = &#123;<span class="number">3</span>,<span class="number">32</span>,<span class="number">321</span>&#125;;</span><br><span class="line">printMinNumber(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个有效的比较规则需要三个条件：自反性，对称性和传递性。</p><h2 id="面试题46：把数字翻译成字符串"><a href="#面试题46：把数字翻译成字符串" class="headerlink" title="面试题46：把数字翻译成字符串"></a>面试题46：把数字翻译成字符串</h2><blockquote><p>题目:给定一个数字，我们按照如下规则把它翻译为字符串：0翻译成“a”，1翻译成“b“，···11翻译成”l“，···25翻译成”z”。一个数字可能有多个翻译。例如，12258有5种翻译：“bccfi”,“bwfi”,“bczi”,“mcfi”,“mzi”。实现 一个函数，用来计算一个数字有多少种不是同的翻译方法。</p></blockquote><p>思路：递归从最大的问题开始自上而下解决问题会产生重复。所以这里从最小的子问题开始自下而上解决问题，这样可以消除重复的子问题。从数字的末尾开始，然后从右到左翻译并计算不同翻译的数目。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTranslationCount</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> numberInString = to_string(number);</span><br><span class="line">    <span class="keyword">return</span> getTranslationCount(numberInString);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTranslationCount</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = number.size();</span><br><span class="line">    <span class="keyword">int</span> *counts = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//如果是第一次则初始化，不是第一次则继承上一次count的总数</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; length - <span class="number">1</span>)</span><br><span class="line">            count = counts[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &lt; length - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> digit1 = number[i] -<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> digit2 = number[i+<span class="number">1</span>] -<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> converted = digit1*<span class="number">10</span>+digit2;</span><br><span class="line">            <span class="comment">//可能是两位的字母</span></span><br><span class="line">            <span class="keyword">if</span>(converted &gt;= <span class="number">10</span> &amp;&amp; converted &lt;= <span class="number">25</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; length - <span class="number">2</span>)</span><br><span class="line">                    count += counts[i+<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        counts[i] = count;</span><br><span class="line">    &#125;</span><br><span class="line">    count = counts[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] counts;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题47：礼物的最大价值"><a href="#面试题47：礼物的最大价值" class="headerlink" title="面试题47：礼物的最大价值"></a>面试题47：礼物的最大价值</h2><blockquote><p>题目：再一个m*n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（大于0）。从期盼的左上角开始拿礼物，并每次向左或者向下移动一格，直到到达期盼的右下角。给定一个棋盘，计算出最多能拿到多少价值的礼物。</p></blockquote><p>思路：用动态规划解决问题，定义一个函数$f(i,j)$表示到达坐标为$(i,j)$的格子时能拿到的礼物总和的最大值。我们有两种可能的途径达到坐标为$(i,j)$的格子；通过格子$(i-1,j)$或者$(i,j-1)$。所以：<br>$$f(i,j)=max(f(i-1,j),f(i,j-1))+gift[i,j]$$</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; values)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = values.size();</span><br><span class="line">    <span class="keyword">if</span>(rows&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> cols = values[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">if</span>(cols&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(cols,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(rows));</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">                up = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                left = dp[i][j<span class="number">-1</span>];</span><br><span class="line">            </span><br><span class="line">            dp[i][j] = max(left,up)+values[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> maxValues = dp[rows<span class="number">-1</span>][cols<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题48：最长不含重复字符的子字符串"><a href="#面试题48：最长不含重复字符的子字符串" class="headerlink" title="面试题48：最长不含重复字符的子字符串"></a>面试题48：最长不含重复字符的子字符串</h2><blockquote><p>题目：请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含’a’~’z’的字符。例如在字符串“arabcacfr”中，最长的不包含重复字符的子字符串时”acfr”，长度为4。</p></blockquote><p>思路：暴力算法需要在$O(n^2)$的子字符串中用$O(n)$的时间判断是否重复，这种算法的时间复杂度时$O(n^3)$。</p><p>用动态规划来提高效率，定义函数$f(i)$表示以第$i$个字符为结尾的不包含重复字符的子字符串的最长长度，<br>如果字符没有出现过，那么$f(i)=f(i-1)+1$。<br>如果字符出现过，先计算字符和上次出现位置的距离，记为d。</p><ol><li>$d小于等于f(i-1),f(i)=d$。</li><li>$d大于f(i-1),f(i)=f(i-1)+1$。</li></ol><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubstringWithoutDuplication</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curLength = <span class="number">0</span>;<span class="comment">//f(i-1)</span></span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span>;<span class="comment">//f(i)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> length = str.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">26</span>,<span class="number">-1</span>);<span class="comment">//用来存储26个字母所在地位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> preIndex = dp[str[i]-<span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">if</span>((i - preIndex)&gt; curLength || preIndex == <span class="number">-1</span>)</span><br><span class="line">            curLength++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            curLength = i - preIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[str[i]-<span class="string">'a'</span>] = i;</span><br><span class="line">        <span class="keyword">if</span>(curLength&gt;maxLength)</span><br><span class="line">            maxLength = curLength;         </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> maxLength;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题49：丑数"><a href="#面试题49：丑数" class="headerlink" title="面试题49：丑数"></a>面试题49：丑数</h2><blockquote><p>题目：将只包含因子2，3和5地数称作为丑数。求出从小到大地第1500个丑数。习惯上把1当作第一个丑数。</p></blockquote><p>思路：暴力解法是将目标数对2，3，5连续整除，如果最后得到1，就是丑数。时间复杂度较高。</p><p>创建数组保存已经找到的丑数，用空间换时间的解法。<br>问题是如何获得下一个丑数，假设已经存在一个丑数数组，其最大的丑数为M。下一个大于M的丑数一定是数组中的数乘以2，3或5生成，记为M2，M3，M5（遍历所有数乘以2，3，5之后第一个大于M的数）。下一个丑数就是这三个数中的最小数。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUglyNumber</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; uglyNumbers(index);</span><br><span class="line">    uglyNumbers[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nextUglyIndex = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> M2 = uglyNumbers.begin();</span><br><span class="line">    <span class="keyword">auto</span> M3 = uglyNumbers.begin();</span><br><span class="line">    <span class="keyword">auto</span> M5 = uglyNumbers.begin();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(nextUglyIndex &lt; index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = Min(*M2*<span class="number">2</span>,*M3*<span class="number">3</span>,*M5*<span class="number">5</span>);</span><br><span class="line">        uglyNumbers[nextUglyIndex] = min;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(*M2*<span class="number">2</span> &lt;= uglyNumbers[nextUglyIndex])</span><br><span class="line">            M2++;</span><br><span class="line">        <span class="keyword">while</span>(*M3*<span class="number">3</span> &lt;= uglyNumbers[nextUglyIndex])</span><br><span class="line">            M3++;        </span><br><span class="line">        <span class="keyword">while</span>(*M5*<span class="number">5</span> &lt;= uglyNumbers[nextUglyIndex])</span><br><span class="line">            M5++;</span><br><span class="line">        nextUglyIndex++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> tmp:uglyNumbers)<span class="built_in">cout</span>&lt;&lt;<span class="string">' '</span>&lt;&lt;tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uglyNumbers.back();    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> number1,<span class="keyword">int</span> number2,<span class="keyword">int</span> number3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = (number1&lt;number2)?number1:number2;</span><br><span class="line">    min = (min&lt;number3)?min:number3;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题50：第一个只出现一次的字符"><a href="#面试题50：第一个只出现一次的字符" class="headerlink" title="面试题50：第一个只出现一次的字符"></a>面试题50：第一个只出现一次的字符</h2><blockquote><p>题目一：字符串中第一个只出现一次的字符。例如：在“abaccdeff”中，输出b。</p></blockquote><p>思路：暴力解法，时间复杂度为$O(n^2)$。</p><p>用哈希表的思路来做，键值(key)是字符，值(value)是字符出现的次数。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">firstNotRepeatingChar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = input.size();</span><br><span class="line">    <span class="keyword">if</span>(length&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hashMap(<span class="number">256</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        hashMap[input[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((hashMap[input[i]])==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> input[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'\0'</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目二：字符流中第一个只出现一次的字符。例如，当字符流只读出前两个字符”go”的时候，第一个出现的字符是’g’，当字符流读出前6个字符“google”时，第一个只出现一次的字符是’l’。</p></blockquote><p>思路：与题一对比不同的地方在于需要快速地给出字符，不能重新遍历寻找字符。改变在于将值（value）改为字符第一次出现所在的索引，重复出现改为’-2’加以区分，就可以从最小的索引中取出（key）键值即为字符。这样做就可以不用更新之前的值，在数据流长度大于256后，复杂度降低。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">charStatistics</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    charStatistics():index(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">256</span>;i++)</span><br><span class="line">            hashMap[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> ch)</span><span class="comment">//用insert模拟字符串流</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hashMap[ch] == <span class="number">-1</span>)</span><br><span class="line">            hashMap[ch] = index;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (hashMap[ch] &gt;= <span class="number">0</span>)</span><br><span class="line">            hashMap[ch] = <span class="number">-2</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstAppearing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">256</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hashMap[i] &gt;=<span class="number">0</span> &amp;&amp; hashMap[i] &lt; minIndex)</span><br><span class="line">            &#123;</span><br><span class="line">                ch = <span class="keyword">char</span>(i);</span><br><span class="line">                minIndex = hashMap[i];</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">int</span> hashMap[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面试题41：数据流中的中位数&quot;&gt;&lt;a href=&quot;#面试题41：数据流中的中位数&quot; class=&quot;headerlink&quot; title=&quot;面试题41：数据流中的中位数&quot;&gt;&lt;/a&gt;面试题41：数据流中的中位数&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目：如何得到一个
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer习题学习过程31-40</title>
    <link href="http://yoursite.com/2019/06/19/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B31-40/"/>
    <id>http://yoursite.com/2019/06/19/剑指offer习题学习过程31-40/</id>
    <published>2019-06-19T07:01:54.000Z</published>
    <updated>2019-06-19T07:06:41.595Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题31：栈的压入、弹出序列"><a href="#面试题31：栈的压入、弹出序列" class="headerlink" title="面试题31：栈的压入、弹出序列"></a>面试题31：栈的压入、弹出序列</h2><blockquote><p>题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列{1,2,3,4,5}是某栈的压栈序列，序列{4,5,3,2,1}是该栈序列对于的一个弹出序列，但{4,3,5,1,2}就不可能是该压栈序列的弹出序列。</p><p>比如压入序列{1,2,3,4,5}，弹出序列{4,5,3,2,1}。</p><table><thead><tr><th>步骤</th><th>操作</th><th>栈</th><th>弹出数字</th><th>步骤</th><th>操作</th><th>栈</th><th>弹出数字</th></tr></thead><tbody><tr><td>1</td><td>压入1</td><td>1</td><td></td><td>6</td><td>弹出</td><td>1,2</td><td>3</td></tr><tr><td>2</td><td>压入2</td><td>1,2</td><td></td><td>7</td><td>压入5</td><td>1,2,5</td><td></td></tr><tr><td>3</td><td>压入3</td><td>1,2,3</td><td></td><td>8</td><td>弹出</td><td>1,2</td><td>5</td></tr><tr><td>4</td><td>压入4</td><td>1,2,3,4</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>5</td><td>t弹出</td><td>1,2,3</td><td>4</td><td></td><td></td><td></td></tr></tbody></table></blockquote><p>思路：从弹出序列来看，如果下一个弹出的数字正好是栈顶数字，那么直接弹出；如果不在栈顶，就一直压栈直到遇到栈顶数字，如果所有数压栈结束还没有找到弹出数字，就不是该序列的弹出序列。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPopOrder</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* pushOrder,<span class="keyword">const</span> <span class="keyword">int</span>* popOrder,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(length &gt; <span class="number">0</span> &amp;&amp; popOrder != <span class="literal">nullptr</span> &amp;&amp; pushOrder != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>* nextPush = pushOrder;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>* nextPop = popOrder;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; tmpStack;</span><br><span class="line">        <span class="keyword">while</span>(nextPop - popOrder &lt; length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!tmpStack.empty() || tmpStack.top() != *nextPop)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nextPush - pushOrder == length)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            tmpStack.push(*nextPush);</span><br><span class="line">            </span><br><span class="line">            nextPush++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//一直找不到弹出数字时跳出</span></span><br><span class="line">            <span class="keyword">if</span>(tmpStack.top() != *nextPop)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//相等时弹出</span></span><br><span class="line">            <span class="keyword">else</span>                </span><br><span class="line">            &#123;</span><br><span class="line">                tmpStack.pop();</span><br><span class="line">            nextPop++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当压入数列和辅助栈都为空，完成所有弹出</span></span><br><span class="line">        <span class="keyword">if</span>(tmpStack.empty() &amp;&amp; nextPop - popOrder == length)</span><br><span class="line">            result = <span class="literal">true</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题32：从上到下打印二叉树（广度优先）"><a href="#面试题32：从上到下打印二叉树（广度优先）" class="headerlink" title="面试题32：从上到下打印二叉树（广度优先）"></a>面试题32：从上到下打印二叉树（广度优先）</h2><blockquote><p>题目一：不分行从上到下打印二叉树</p><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p></blockquote><p>思路：用队列实现节点的打印。每次打印一个节点的时候，如果该节点有子节点，则把子节点放到一个队列的末尾，再将从队列头部去除下一个节点。重复前面的操作直至完成打印。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBinaryTreeFromTopToBottom</span><span class="params">(binaryTreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//辅助队列</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;binaryTreeNode*&gt; dequeTreeNode;</span><br><span class="line">    </span><br><span class="line">    dequeTreeNode.push_back(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(dequeTreeNode.size() != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果有子节点，则保存到尾部</span></span><br><span class="line">        <span class="keyword">if</span>(dequeTreeNode.front()-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            dequeBinaryTreeNode.push_back(dequeTreeNode.front()-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(dequeTreeNode.front()-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">            dequeBinaryTreeNode.push_back(dequeTreeNode.front()-&gt;right);</span><br><span class="line">        <span class="comment">//打印头部节点并弹出</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dequeTreeNode.top();</span><br><span class="line">        dequeTreeNode.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目二：分行从上到下打印二叉树</p><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到每一行。</p></blockquote><p>思路：和第一题相似，多出两个变量，一个变量表示再当前层中还没有打印的节点数，另一个变量表示下一层节点的数目。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBinaryTreeFromTopToBottom</span><span class="params">(binaryTreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">deque</span>&lt;binaryTreeNode*&gt; dequeTreeNode;</span><br><span class="line">    </span><br><span class="line">    dequeTreeNode.push_back(root);</span><br><span class="line">    <span class="keyword">int</span> curCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nexCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dequeTreeNode.size() != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dequeTreeNode.front()-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dequeBinaryTreeNode.push_back(dequeTreeNode.front()-&gt;left);</span><br><span class="line">            nexCount ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dequeTreeNode.front()-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dequeBinaryTreeNode.push_back(dequeTreeNode.front()-&gt;right);</span><br><span class="line">            nexCount ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dequeTreeNode.top();</span><br><span class="line">        dequeTreeNode.pop_front();</span><br><span class="line">        curCount--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(curCount == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            curCount = nexCount;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            nexCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目三：之字形打印二叉树。</p><p>即第一层从左到右打印，第二层从右到左打印，以此类推。</p></blockquote><p>思路：需要定义两个栈，一个栈用来保存奇数层，一个栈用来保存偶数层。如果时奇数层，则先保存左节点再保存右节点（奇数层的下一个层偶数层需要从右到左打印）。如果时偶数层，则先保存右节点，再保存左节点（偶数层的下一个奇数层需要从左到右打印）。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(binaryTreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">stack</span>&lt;binaryTreeNode*&gt; level[<span class="number">2</span>];</span><br><span class="line">    level[<span class="number">0</span>].push(root);</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> next = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!level[<span class="number">0</span>].empty() || !level[<span class="number">1</span>].empty())</span><br><span class="line">    &#123;</span><br><span class="line">        binaryTreeNode* tmpNode = level[cur].top();</span><br><span class="line">        level[cur].pop();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;tmpNode-&gt;value;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmpNode-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                level[cur].push(tmpNode-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(tmpNode-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                level[cur].push(tmpNode-&gt;right);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmpNode-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                level[cur].push(tmpNode-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(tmpNode-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                level[cur].push(tmpNode-&gt;left);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(level[cur].empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">//用来实现0和1的交替赋值</span></span><br><span class="line">            cur = <span class="number">1</span> - cur;</span><br><span class="line">            next = <span class="number">1</span> - next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题33：二叉搜索树的后序遍历序列"><a href="#面试题33：二叉搜索树的后序遍历序列" class="headerlink" title="面试题33：二叉搜索树的后序遍历序列"></a>面试题33：二叉搜索树的后序遍历序列</h2><blockquote><p>题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后续遍历结果。假设输入数组中数字互不相同。</p></blockquote><p>思路：后序遍历：left-&gt;right-&gt;root。先 从最后找到根节点，比根节点小的就是左节点，大的就是右节点。递归直到不再产生左右子树即只剩一个根节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSquenceOfBTS</span><span class="params">(<span class="keyword">int</span> input[],<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span> || input == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> root = input[length<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">//找左节点</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt; length<span class="number">-1</span> ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root &lt; input[i])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找右节点，并且判断右节点是不是大于根节点</span></span><br><span class="line">    <span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;j &lt; length<span class="number">-1</span> ;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root &gt; input[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> left = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">        left = isSquenceOfBTS(input,i);</span><br><span class="line">     <span class="keyword">bool</span> right = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//减去1是因为排除了根节点</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; length - <span class="number">1</span>)</span><br><span class="line">        right = isSquenceOfBTS(input + i,length - i - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left &amp;&amp; right;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题34：二叉树中和为某一值的路径"><a href="#面试题34：二叉树中和为某一值的路径" class="headerlink" title="面试题34：二叉树中和为某一值的路径"></a>面试题34：二叉树中和为某一值的路径</h2><blockquote><p>题目：输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的而节点形成一条路径。<br>思路：用前序遍历的方法访问所有节点，并把经过的路径累加起来并保存再一个栈中，当遇到叶节点并且累加值等于目标值时，打印路径所有的节点。否则继续访问父节点，并且回退时需要减去当前叶节点。其中由于需要打印整个节点，所以不能直接stack容器，可以选用vector容器代替。<br>解法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finePath</span><span class="params">(binaryTreeNode* root,<span class="keyword">int</span> target,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path,<span class="keyword">int</span> curSum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    curSum += root-&gt;value;</span><br><span class="line">    path.push_back(root-&gt;value);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> isLeaf = root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>; </span><br><span class="line">    <span class="comment">//找到目标路径</span></span><br><span class="line">    <span class="keyword">if</span>(target == curSum &amp;&amp; isLeaf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"path: "</span>;</span><br><span class="line">for_each(input.begin(),input.end(),[](<span class="keyword">auto</span> tmp)&#123;<span class="built_in">cout</span>&lt;&lt;tmp&lt;&lt;<span class="string">'\t'</span>;&#125;);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不是叶节点，就继续遍历子节点。</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        finePath(root-&gt;left,target,path,curSum);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        finePath(root-&gt;right,target,path,curSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是叶节点，但不是目标路径，返回父节点前删除当前节点</span></span><br><span class="line">    <span class="comment">//书中这里没有减去当前值</span></span><br><span class="line">    curSum -= root-&gt;value;</span><br><span class="line">    path.pop_back();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finePath</span><span class="params">(binaryTreeNode* root,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">    findPath(root,target,path,curSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="面试题35：复杂链表的复制"><a href="#面试题35：复杂链表的复制" class="headerlink" title="面试题35：复杂链表的复制"></a>面试题35：复杂链表的复制</h2><blockquote><p>题目：实现函数complexListNode<em> clone(complexListNode</em> head)，复制一个复杂链表。再复杂链表中，每个节点除了有一个next指向下一个系欸但，还有一个sibling指针指向链表中的任意节点或者nullptr。节点的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">struct</span> <span class="title">complexListNode</span></span></span><br><span class="line"><span class="class">&gt; &#123;</span></span><br><span class="line">&gt;     <span class="keyword">int</span> value;</span><br><span class="line">&gt;     complexListNode* next;</span><br><span class="line">&gt;     complexListNode* sibling;    </span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>思路：三种方法：</p><ol><li>第一步先复制原始链表上的每一个节点，并用next链接起来。第二步设置每个节点的sibling指针。由于需要定位S的位置需要从原始链表的头节点开始找，找到后需要在复制链表中遍历到S，时间复杂度$O(n^2)$。</li><li>第一步仍然是复制每一个节点N到N’，把&lt;N,N’&gt;的配对信息放到一个哈希表中。第二步还是设置复制链表中每个节点的sibling指针，由于有哈希表，能以O(1)的时间找到S’。</li><li>第一步仍然复制每个节点，但是是把节点N’链接到N后面，然后原始链表中N的后一个元素链接到N’的后面。这样sibling指针就可以直接指向原始S的后面。</li></ol><p>解法3：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步，复制N'</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cloneNode</span><span class="params">(complexListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    complexListNode* tmpNode = head;</span><br><span class="line">    <span class="keyword">if</span>(tmpNode != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        complexListNode* cloneNode = <span class="keyword">new</span> complexListNode();</span><br><span class="line">        cloneNode-&gt;value = tmpNode-&gt;value;</span><br><span class="line">        <span class="comment">//N的next链接到N'后面</span></span><br><span class="line">        cloneNode-&gt;next = tmpNode-&gt;next;</span><br><span class="line">        cloneNode-&gt;sibling = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//N'链接到N后面</span></span><br><span class="line">        tmpNode-&gt;next = cloneNode;</span><br><span class="line">        <span class="comment">//N迭代</span></span><br><span class="line">        tmpNode = cloneNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二步，复制sibling指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cloneSiblingNode</span><span class="params">(complexListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    complexListNode* tmpNode = head;</span><br><span class="line">    <span class="keyword">while</span>(tmpNode != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取得N'</span></span><br><span class="line">        complexListNode* cloneNode = tmpNode-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(cloneNode != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cloneNode-&gt;sibling = tmpNode-&gt;sibling-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmpNode = cloneNode-&gt;next;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三步，拆分两个链表</span></span><br><span class="line"><span class="function">complexListNode* <span class="title">reconnectNode</span><span class="params">(complexListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    complexListNode* tmpNode = head;</span><br><span class="line">    complexListNode* cloneNode = <span class="literal">nullptr</span>;</span><br><span class="line">    complexListNode* cloneHead = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//初始化赋值链表的头部</span></span><br><span class="line">    <span class="keyword">if</span>(tmpNode != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cloneHead = tmpNode-&gt;next;</span><br><span class="line">        cloneNode = cloneHead;</span><br><span class="line">        tmpNode-&gt;next = cloneNode-&gt;next;</span><br><span class="line">        tmpNode = tmpNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(tmpNode != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将复制指针节点相连</span></span><br><span class="line">        cloneNode-&gt;next = tmpNode-&gt;next;</span><br><span class="line">        <span class="comment">//复制指针迭代</span></span><br><span class="line">        cloneNode = cloneNode-&gt;next;</span><br><span class="line">        <span class="comment">//原始指针相连</span></span><br><span class="line">        tmpNode-&gt;next = cloneNode-&gt;next;</span><br><span class="line">        <span class="comment">//原始指针迭代</span></span><br><span class="line">        tmpNode = tmpNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">listNode* <span class="title">complexListNodeClone</span><span class="params">(listNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cloneNode(head);</span><br><span class="line">    reconnectNode(head);</span><br><span class="line">    listNode* result = reconnectNode(head);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题36：二叉搜索树与双向链表"><a href="#面试题36：二叉搜索树与双向链表" class="headerlink" title="面试题36：二叉搜索树与双向链表"></a>面试题36：二叉搜索树与双向链表</h2><blockquote><p>题目：输入一课二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。二叉树的定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">struct</span> <span class="title">binaryTreeNode</span></span></span><br><span class="line"><span class="class">&gt; &#123;</span></span><br><span class="line">&gt;     <span class="keyword">int</span> value;</span><br><span class="line">&gt;     binaryTreeNode* left;</span><br><span class="line">&gt;     binaryTreeNode* right;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>思路：二叉树中左节点看作指向前面节点的指针，右节点看作指向后面节点的指针。由于要求转换后的链表是排序好的，所以需要中序遍历。其中链表用尾部指针来获取整个链表，因为left-&gt;root-&gt;right，每次访问root，与left做链表操作。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">binaryTreeNode* <span class="title">convertCore</span><span class="params">(binaryTreeNode* root,binaryTreeNode** lastListNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    binaryTreeNode* cur = root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> convertCore(root-&gt;left,lastListNode);</span><br><span class="line">    <span class="comment">//中序遍历顺序</span></span><br><span class="line">    <span class="comment">//向前指针链接</span></span><br><span class="line">    cur-&gt;left = *lastListNode;</span><br><span class="line">    <span class="keyword">if</span>(*lastListNode != <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="comment">//向后指针链接</span></span><br><span class="line">        (*lastListNode)-&gt;right = cur;</span><br><span class="line">    <span class="comment">//尾部指针迭代</span></span><br><span class="line">    *lastListNode = cur;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> convertCore(root-&gt;right,lastListNode);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">binaryTreeNode* <span class="title">convert</span><span class="params">(binaryTreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    binaryTreeNode* lastListNode = <span class="literal">nullptr</span>;    </span><br><span class="line">    convertCore(root,&amp;lastListNode);</span><br><span class="line">    <span class="comment">//lastListNode是链表的尾节点，需要再或者其头节点</span></span><br><span class="line">    binaryTreeNode* headListNode = lastListNode;    </span><br><span class="line">    <span class="keyword">while</span>(headListNode != <span class="literal">nullptr</span> &amp;&amp; headListNode-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">        headListNode = headListNode-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> headListNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题37：序列化二叉树"><a href="#面试题37：序列化二叉树" class="headerlink" title="面试题37：序列化二叉树"></a>面试题37：序列化二叉树</h2><blockquote><p>题目：实现两个函数，分别用来序列化和反序列化二叉树</p></blockquote><p>思路：根据前序遍历的顺序来序列化二叉树，并且在遇到nullptr指针时，将其序列化为一个特殊字符（比如’$’），用来提示节点停止，两个节点间用’,’分割。</p><p>反序列化就用前序遍历实现。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binaryTreeToString</span><span class="params">(binaryTreeNode* root,<span class="built_in">string</span>&amp; output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        output = output + <span class="string">"$,"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    output = output + itos(root-&gt;value) + <span class="string">','</span>;</span><br><span class="line">    binaryTreeToString(root-&gt;left,output);</span><br><span class="line">    binaryTreeToString(root-&gt;right,output);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stringToBinaryTree</span><span class="params">(binaryTreeNode** root,istream&amp; stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> item;</span><br><span class="line">    getline(stream,item,<span class="string">','</span>);</span><br><span class="line">    <span class="keyword">if</span>(item == <span class="string">'$'</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(item &gt; <span class="string">'0'</span> &amp;&amp; item &lt; <span class="string">'9'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> binaryTreeNode(stoi(item));</span><br><span class="line">        stringToBinaryTree(&amp;((*root)-&gt;left),stream);</span><br><span class="line">        stringToBinaryTree(&amp;((*root)-&gt;right),stream);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题38：字符串的排列（排列问题，涉及8皇后）"><a href="#面试题38：字符串的排列（排列问题，涉及8皇后）" class="headerlink" title="面试题38：字符串的排列（排列问题，涉及8皇后）"></a>面试题38：字符串的排列（排列问题，涉及8皇后）</h2><blockquote><p>题目：出入一个字符串，打印出该字符串中字符的所有排列。例如abc有abc、acb、bca、cab、cba六种。</p></blockquote><p>思路：将排列看出由两部分组成，一个字符和剩余字符。求排列其看做两步：</p><ol><li>求出所有可能在第一个位置的字符。</li><li>固定第一个字符，然后求剩余字符的排列，直到只剩一个字符。</li></ol><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArrange</span><span class="params">(<span class="keyword">char</span>* input,<span class="keyword">char</span>* pBegin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(*pBegin == <span class="string">'\0'</span>)<span class="built_in">cout</span>&lt;&lt;input&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span>* charIterator = pBegin;*charIterator != <span class="string">'\0'</span>;charIterator++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = *charIterator;</span><br><span class="line">            *charIterator = *pBegin;</span><br><span class="line">            *pBegin = tmp;</span><br><span class="line"></span><br><span class="line">            printArrange(input,pBegin+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//交换之后需要复原给下一次迭代使用</span></span><br><span class="line">            tmp = *charIterator;</span><br><span class="line">            *charIterator = *pBegin;</span><br><span class="line">            *pBegin = tmp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArrange</span><span class="params">(<span class="keyword">char</span>* input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(input == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">char</span>* pBegin = input;</span><br><span class="line">    printArrange(input,pBegin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目：输入一个含有8个数字的的数组，判断有没有可能把这8个数字分别放到正方体的8个顶点上，使得正方体上三组相对的面上的4个顶点和都相等。</p></blockquote><p>思路：实际上就是求8个数组的所有排列，然后判断有没有符合$a_1+a_2+a_3+a_4 == a_5+a_6+a_7+a_8,a_1+a_3+a_5+a_7 == a_2+a_4+a_6+a_8,a_1+a_2+a_5+a_6 == a_3+a_4+a_7+a_8$的排列组合。可以用next_permutation来取得所有组合。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isCube</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(input.begin(),input.end());</span><br><span class="line">    <span class="keyword">while</span>(next_permutation(input.begin(),input.end()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> result = </span><br><span class="line">            (input[<span class="number">1</span>]+input[<span class="number">2</span>]+input[<span class="number">3</span>]+input[<span class="number">4</span>])</span><br><span class="line">            == (input[<span class="number">5</span>]+input[<span class="number">6</span>]+input[<span class="number">7</span>]+input[<span class="number">8</span>])</span><br><span class="line">            &amp;&amp; (input[<span class="number">1</span>]+input[<span class="number">3</span>]+input[<span class="number">5</span>]+input[<span class="number">7</span>])</span><br><span class="line">            == (input[<span class="number">2</span>]+input[<span class="number">4</span>]+input[<span class="number">6</span>]+input[<span class="number">8</span>])</span><br><span class="line">            &amp;&amp; (input[<span class="number">1</span>]+input[<span class="number">2</span>]+input[<span class="number">5</span>]+input[<span class="number">6</span>])</span><br><span class="line">            == (input[<span class="number">3</span>]+input[<span class="number">4</span>]+input[<span class="number">7</span>]+input[<span class="number">8</span>]);</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="literal">true</span>)<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目：8皇后问题（用排列解决）</p></blockquote><p>思路：定义一个数组index[8]，数组中第i行数组代表皇后所在的列数。先将其中的数字用0~7初始化，然后对其全排列。由于行数和列数肯定不想同，所以只要判断是否在同一条对角线上，即i-j == index[i]-index[j]或者j - i == index[i] -index[j]。</p><p>解法（排列）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printQueen</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; queen = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;    </span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(next_permutation(queen.begin(),queen.end()))</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; <span class="number">8</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> tmp = <span class="built_in">abs</span>(i - j) != <span class="built_in">abs</span>(queen[i] - queen[j]);</span><br><span class="line">result = result &amp;&amp; tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">if</span>(result == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(<span class="number">8</span>,<span class="number">0</span>);</span><br><span class="line">tmp[queen[i]] = <span class="number">1</span>;</span><br><span class="line">for_each(tmp.begin(),tmp.end(),[](<span class="keyword">auto</span> a)&#123;<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">' '</span>;&#125;);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"count of queen: "</span>&lt;&lt;count;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法（回溯）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">attack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; input,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//i代表其他的皇后的行，input[i]就是列</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!result &amp;&amp; i &lt; row)</span><br><span class="line">    &#123;</span><br><span class="line">        result = (input[i] == col) || </span><br><span class="line">            (<span class="built_in">abs</span>(i - row) == <span class="built_in">abs</span>( input[i] - col));</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印棋盘</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printQueen</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; input)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; tmp(<span class="number">8</span>,<span class="string">'-'</span>);</span><br><span class="line">tmp[input[i]] = <span class="string">'Q'</span>;</span><br><span class="line">for_each(tmp.begin(),tmp.end(),[](<span class="keyword">auto</span> a)&#123;<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">' '</span>;&#125;);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//q代表皇后的行数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">placeQueen</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; input,<span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//i代表皇后的列数</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!attack(input,q,i))</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//存储皇后位置</span></span><br><span class="line">            input[q] = i;            </span><br><span class="line">            <span class="keyword">if</span>(q == <span class="number">7</span>)</span><br><span class="line">                printQueen(input);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                placeQueen(input,q + <span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input(<span class="number">8</span>,<span class="number">0</span>);</span><br><span class="line">placeQueen(input,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题39：数组中出现次数超过一半的数字"><a href="#面试题39：数组中出现次数超过一半的数字" class="headerlink" title="面试题39：数组中出现次数超过一半的数字"></a>面试题39：数组中出现次数超过一半的数字</h2><blockquote><p>题目：数组中有一个数字出现次数超过数组长度的一半，请找出这个数字。</p></blockquote><p>思路：两种方法，一个会破坏数组，一个不会。</p><ol><li>利用快速排序的思想求出第k大的数字。由于超过长度的一半，所以中间的数字即为所求。</li><li>由于出现次数超过长度的一半，换句话说就是其出现次数比其他所有的都多。可以设定两个数，一个保存当前遍历的数，另一个保存其出现的次数，如果遇到相同的就加1，不同的就减1，计数小于0就换下一个数字。可以保证最后出现次数大于0的数即为要找到的数。</li></ol><p>其中需要注意输入数组如果没有出现次数超过一半的数字，即在找到目标数字后检测其次数是否超过一半。</p><p>解法2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkAboveHalfTimes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = input.size();</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> tmp : input)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(target == tmp)</span><br><span class="line">            times++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(times*<span class="number">2</span> &gt; length)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxTimesNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = input.size();</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = input[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(times == <span class="number">1</span>)</span><br><span class="line">            result = input[i];</span><br><span class="line">        <span class="keyword">if</span>(input[i] == result)</span><br><span class="line">            times++;</span><br><span class="line">        <span class="keyword">else</span> times--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(checkAboveHalfTimes(input,result))</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题40：最小的k个数"><a href="#面试题40：最小的k个数" class="headerlink" title="面试题40：最小的k个数"></a>面试题40：最小的k个数</h2><blockquote><p>题目：输入n个整数，找出其中最小的k个数。例如：输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4.</p></blockquote><p>思路：利用快速排序，partition函数，来解决问题。当位于选中数字左边k个数字就是最小的k个数字，其中这k个数字不是排序的。时间复杂度为O(n)。</p><p>思路2：创建一个大小为k的数据容器来存储最小的k个数字。如果容器已有的数字小于k个，则直接加入。如果容器已满，则找到最大值与其对比，比最大值小的话就代替。<br>所以就需要一个能随时获得最大值的容器，并且删除和插入时间复杂度为O(logk)。比如堆，比如STL中的multiset（红黑树）。（优点处理海量数据，不会修改原数组）</p><p>解法1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getLeastKNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; input,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; output,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = input.size();</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span> || k &lt; <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">auto</span> start = input.begin();</span><br><span class="line">    <span class="keyword">auto</span> end = input.end();</span><br><span class="line">    <span class="keyword">int</span> target = input[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//partiton返回第一个不满足p的迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> index = partition(input.begin(),input.end(),[target](<span class="keyword">auto</span> tmp)&#123;<span class="keyword">return</span> tmp &lt; target;&#125;);</span><br><span class="line">        <span class="keyword">while</span>(distance(input.begin(),index) != k<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(distance(input.begin(),index) &gt; k<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                end = index - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> pivot = *next(start, distance(start,end)/<span class="number">2</span>);</span><br><span class="line">                index = partition(start,end,[pivot](<span class="keyword">auto</span> tmp)&#123;<span class="keyword">return</span> tmp &lt; pivot;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                start = index + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> pivot = *next(start, distance(start,end)/<span class="number">2</span>);</span><br><span class="line">                index = partition(start,end,[pivot](<span class="keyword">auto</span> tmp)&#123;<span class="keyword">return</span> tmp &lt; pivot;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        output.push_back(input[i]);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getLeastKNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; input,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; output,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>,greater&lt;<span class="keyword">int</span>&gt;&gt; kNumber;</span><br><span class="line">    <span class="keyword">int</span> length = input.size();</span><br><span class="line">    <span class="keyword">if</span>(length &lt; k)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        kNumber.insert(input[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k - <span class="number">1</span>;i &lt; length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(input[i] &lt; *kNumber.begin())</span><br><span class="line">        &#123;</span><br><span class="line">            kNumber.erase(kNumber.begin());</span><br><span class="line">            kNumber.insert(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = kNumber.begin();iter != kNumber.end();iter ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        output.push_back(*iter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面试题31：栈的压入、弹出序列&quot;&gt;&lt;a href=&quot;#面试题31：栈的压入、弹出序列&quot; class=&quot;headerlink&quot; title=&quot;面试题31：栈的压入、弹出序列&quot;&gt;&lt;/a&gt;面试题31：栈的压入、弹出序列&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目：输入
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer习题学习过程21-30</title>
    <link href="http://yoursite.com/2019/06/19/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B21-30/"/>
    <id>http://yoursite.com/2019/06/19/剑指offer习题学习过程21-30/</id>
    <published>2019-06-19T07:01:39.000Z</published>
    <updated>2019-07-24T03:00:29.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题21：调整数组顺序是的奇数位于偶数前面"><a href="#面试题21：调整数组顺序是的奇数位于偶数前面" class="headerlink" title="面试题21：调整数组顺序是的奇数位于偶数前面"></a>面试题21：调整数组顺序是的奇数位于偶数前面</h2><blockquote><p>题目：输入一个整数数组，实现一个函数来调整改整数中数字的顺序，使得所有奇数位于数组的前半部分，偶数位于后半部分。</p></blockquote><p>思路：设置两个指针一个指向数组头部，一个指向数组尾部。前面遇到偶数，后面遇到奇数时两者交换直到两个数组相遇。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &amp; <span class="number">1</span>) ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并没有保持原有的数组顺序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">reorderEven</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = input.size();</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tail = length - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(head &lt; tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( head &lt; tail &amp;&amp; !isEven(input[head]))</span><br><span class="line">            head++;</span><br><span class="line">        <span class="keyword">while</span>( head &lt; tail &amp;&amp; isEven(input[tail]))</span><br><span class="line">            tail--;</span><br><span class="line">        <span class="keyword">if</span>(head &lt; tail)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = input[head];</span><br><span class="line">            input[head] = input[tail];</span><br><span class="line">            input[tail] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; target = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"origin: "</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> tmp : target)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;tmp&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">reorderEven(target);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"result: "</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> tmp : target)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;tmp&lt;&lt;<span class="string">' '</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题22：链表中倒数第k个节点"><a href="#面试题22：链表中倒数第k个节点" class="headerlink" title="面试题22：链表中倒数第k个节点"></a>面试题22：链表中倒数第k个节点</h2><blockquote><p>题目：输入一个链表，输出该链表中倒数第k个节点。（从1开始计算而非0）</p><p>链表结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span></span></span><br><span class="line"><span class="class">&gt; &#123;</span></span><br><span class="line">&gt;     <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">&gt;     listNode* next;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>思路：设置两个头指针，第一个先走k个节点，然后第二个开始一起走，直到第一个走到尾部。</p><p>需要注意的边界问题：</p><ol><li>输入指针为空指针。</li><li>链表的节点数小于k。</li><li>k小于1。</li></ol><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">listNode* next;</span><br><span class="line">listNode(<span class="keyword">int</span> a):value(a)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">listNode* <span class="title">findKthToTail</span><span class="params">(listNode* head,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    listNode* first = head;</span><br><span class="line">    listNode* second = head;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(first != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(count == k)</span><br><span class="line">        &#123;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count == k)</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp[<span class="number">9</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">listNode* head = <span class="keyword">new</span> listNode(<span class="number">0</span>);</span><br><span class="line">listNode* iterator1 = head;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">9</span>;i ++)</span><br><span class="line">&#123;</span><br><span class="line">iterator1-&gt;next = <span class="keyword">new</span> listNode(tmp[i]);</span><br><span class="line">iterator1 = iterator1-&gt;next;</span><br><span class="line">iterator1-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">listNode* iterator = head;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"origin: "</span>;</span><br><span class="line"><span class="keyword">while</span>(iterator != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; (iterator-&gt;value) &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">iterator = iterator-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">listNode* result = findKthToTail(head,<span class="number">7</span>);</span><br><span class="line"><span class="keyword">if</span>(result != <span class="literal">nullptr</span>)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"result: "</span>&lt;&lt; result-&gt;value &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"error"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题23：链表中环的入口节点"><a href="#面试题23：链表中环的入口节点" class="headerlink" title="面试题23：链表中环的入口节点"></a>面试题23：链表中环的入口节点</h2><blockquote><p>题目：如果一个链表中包含环，如何找到换的入口节点？</p></blockquote><p>思路：首先判断链表是否有环，方法是设置两个迭代速度不同的指针，第一个每次加1，第二个每次加2。如果存在环，则两者会相遇。</p><p>把相遇的节点存储，然后从这里再次遍历一次，即可得到环的节点数n。</p><p>然后设置两个指针，速度相同，第一个指针先向前n次，之后两个指针一起遍历，相遇的节点即环的入口节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[1_P2] --&gt; B[2] </span><br><span class="line">    B[2] --&gt; C[3]</span><br><span class="line">    C[3] --&gt; D[4]</span><br><span class="line">    D[4] --&gt; E[5_P1]</span><br><span class="line">    E[5_P1] --&gt; F[6]</span><br><span class="line">    F[6] --&gt; C[3]</span><br></pre></td></tr></table></figure><p>如图所示：环的节点数为4，P1先移动4步，然后一起移动会在入口处相遇（因为两者的距离始终是n）。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测是否有环，并且返回相遇节点</span></span><br><span class="line"><span class="function">listNode* <span class="title">meetNode</span><span class="params">(listNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//设置快慢的两个指针，并让其先运动一次</span></span><br><span class="line">    listNode* slow = head-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(slow == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    listNode* fast = slow-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fast == slow)</span><br><span class="line">            <span class="keyword">return</span> fast;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="comment">//需要注意边界条件，while只能保证当前节点不是空指针，不能保证下下个节点不是空指针</span></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="literal">nullptr</span>)</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">listNode* <span class="title">getEntryNode</span><span class="params">(listNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    listNode* meet = meetNode(head);</span><br><span class="line">    <span class="keyword">if</span>(meet == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//环节点数，至少1个</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    listNode* tmp = meet-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(tmp != meet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>++;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    listNode* P1 = head;</span><br><span class="line">    listNode* P2 = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        P1 = p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(p1 != p2)</span><br><span class="line">    &#123;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题24：反转链表"><a href="#面试题24：反转链表" class="headerlink" title="面试题24：反转链表"></a>面试题24：反转链表</h2><blockquote><p>题目：定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p></blockquote><p>思路：从头遍历链表，并以相反的方向重新组成链表。需要维持三个节点：当前节点，它的前一个节点和后一个节点。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">listNode* next;</span><br><span class="line">listNode(<span class="keyword">int</span> a):value(a)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">listNode* <span class="title">reverseList</span><span class="params">(listNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next == <span class="literal">nullptr</span>)<span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    listNode* cur = head;</span><br><span class="line">    listNode* reverseHead = <span class="literal">nullptr</span>;</span><br><span class="line">    listNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//中间变量，记录下一个节点</span></span><br><span class="line">        listNode* nex = cur-&gt;next;        </span><br><span class="line">        <span class="comment">//记录反转的头节点</span></span><br><span class="line">        <span class="keyword">if</span>(nex == <span class="literal">nullptr</span>)</span><br><span class="line">            reverseHead = cur;</span><br><span class="line">        <span class="comment">//反转指向</span></span><br><span class="line">       cur-&gt;next = pre;</span><br><span class="line">        <span class="comment">//pre和cur向前进一</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nex;                </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reverseHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp[<span class="number">9</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">listNode* head = <span class="keyword">new</span> listNode(<span class="number">0</span>);</span><br><span class="line">listNode* iterator1 = head;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">9</span>;i ++)</span><br><span class="line">&#123;</span><br><span class="line">iterator1-&gt;next = <span class="keyword">new</span> listNode(tmp[i]);</span><br><span class="line">iterator1 = iterator1-&gt;next;</span><br><span class="line">iterator1-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">listNode* iterator = head;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"origin: "</span>;</span><br><span class="line"><span class="keyword">while</span>(iterator != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; (iterator-&gt;value) &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">iterator = iterator-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">listNode* result = reverseList(head);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"result: "</span>;</span><br><span class="line"><span class="keyword">if</span>(result != <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">while</span>(result != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; (result-&gt;value) &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">result = result-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"error"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题25：合并两个排序的链表"><a href="#面试题25：合并两个排序的链表" class="headerlink" title="面试题25：合并两个排序的链表"></a>面试题25：合并两个排序的链表</h2><blockquote><p>题目：输入两个递增排序的链表，合并这两个链表并使新链表中节点任然是递增排序的。</p></blockquote><p>思路：两者进行对比，小的节点作为头节点，循环递归。需要注意边界条件。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归解法</span></span><br><span class="line"><span class="function">listNode* <span class="title">mergeList</span><span class="params">(listNode* head1,listNode* head2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head1 == <span class="literal">nullptr</span>)<span class="keyword">return</span> head2;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(head2 == <span class="literal">nullptr</span>)<span class="keyword">return</span> head1;</span><br><span class="line">    </span><br><span class="line">    listNode* mergeHead = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(head1-&gt;value &lt; head2-&gt;value)</span><br><span class="line">    &#123;</span><br><span class="line">        mergeHead = head1;</span><br><span class="line">        mergeHead -&gt;next = mergeList(head1-&gt;next,head2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mergeHead = head2;</span><br><span class="line">        mergeHead -&gt;next = mergeList(head1,head2-&gt;next);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mergeHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题26：树的子结构"><a href="#面试题26：树的子结构" class="headerlink" title="面试题26：树的子结构"></a>面试题26：树的子结构</h2><blockquote><p>输入两棵二叉树A和B，判断B是不是A的子结构。二叉树节点的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">struct</span> <span class="title">binaryTreeNode</span></span></span><br><span class="line"><span class="class">&gt; &#123;</span></span><br><span class="line">&gt;     <span class="keyword">double</span> value;</span><br><span class="line">&gt;     binaryTreeNode* left;</span><br><span class="line">&gt;     binaryTreeNode* right;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>思路：先遍历A找到B的根节点，然后进行对比，使用递归即可。</p><ol><li>浮点数的对比不能使用“==”，因为计算机存储浮点数用的是近似值，为的是能在固定长度上存储更大范围的数。</li><li>需要随时注意空指针。</li></ol><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较节点中浮点数是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEqual</span><span class="params">(binaryTreeNode* tree1,binaryTreeNode* tree2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> diff = tree1-&gt;value - tree2-&gt;value;</span><br><span class="line">    <span class="keyword">if</span>(diff &lt; <span class="number">0.0000001</span> &amp;&amp; diff &gt; <span class="number">-0.0000001</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//验证tree2是否是tree1的子节点（假设两者root相同）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">doesTree1HaveTree2</span><span class="params">(binaryTreeNode* tree1,binaryTreeNode* tree2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//递归结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(tree2 == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree1 == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!isEqual(tree1,tree2))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> result = doesTree1HaveTree2(tree1-&gt;left,tree2-&gt;left)</span><br><span class="line">        &amp;&amp; doesTree1HaveTree2(tree1-&gt;right,tree2-&gt;right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//验证tree2是否是tree1的子节点（在tree1中寻找tree2的root）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasSubtree</span><span class="params">(binaryTreeNode* tree1,binaryTreeNode* tree2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//时刻保证不为空指针</span></span><br><span class="line">    <span class="keyword">if</span>(tree1 != <span class="literal">nullptr</span> &amp;&amp; tree2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEqual(tree1,tree2))</span><br><span class="line">        &#123;</span><br><span class="line">            result = doesTree1HaveTree2(tree1,tree2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果result为真，则结束递归</span></span><br><span class="line">        <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">            result = hasSubtree(tree1-&gt;left,tree2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">            result = hasSubtree(tree1-&gt;right,tree2);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题27：二叉树的镜像（二叉树翻转）"><a href="#面试题27：二叉树的镜像（二叉树翻转）" class="headerlink" title="面试题27：二叉树的镜像（二叉树翻转）"></a>面试题27：二叉树的镜像（二叉树翻转）</h2><blockquote><p>题目：输入一个儿茶叔，输出它的镜像，二叉树节点定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">struct</span> <span class="title">binaryTreeNode</span></span></span><br><span class="line"><span class="class">&gt; &#123;</span></span><br><span class="line">&gt;     <span class="keyword">double</span> value;</span><br><span class="line">&gt;     binaryTreeNode* left;</span><br><span class="line">&gt;     binaryTreeNode* right;</span><br><span class="line">&gt; &#125;；</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>思路：递归交换左右节点。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseBinaryTree</span><span class="params">(binaryTreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    binaryTreeNode* tmp = root-&gt;left;</span><br><span class="line">    root-&gt;left = root-&gt;right;</span><br><span class="line">    root-&gt;right = tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)reverseBinaryTree(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)reverseBinaryTree(root-&gt;right);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    binaryTreeNode* left;</span><br><span class="line">    binaryTreeNode* right;</span><br><span class="line">binaryTreeNode(<span class="keyword">int</span> x) : value(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseBinaryTree</span><span class="params">(binaryTreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    binaryTreeNode* tmp = root-&gt;left;</span><br><span class="line">    root-&gt;left = root-&gt;right;</span><br><span class="line">    root-&gt;right = tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)reverseBinaryTree(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)reverseBinaryTree(root-&gt;right);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prettyPrintTree</span><span class="params">(binaryTreeNode* node, <span class="built_in">string</span> prefix = <span class="string">""</span>, <span class="keyword">bool</span> isLeft = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Empty tree"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node-&gt;right) &#123;</span><br><span class="line">        prettyPrintTree(node-&gt;right, prefix + (isLeft ? <span class="string">"|   "</span> : <span class="string">"    "</span>), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; prefix + (isLeft ? <span class="string">"`-- "</span> : <span class="string">",-- "</span>) + to_string(node-&gt;value) + <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">        prettyPrintTree(node-&gt;left, prefix + (isLeft ? <span class="string">"    "</span> : <span class="string">"|   "</span>), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trimLeftTrailingSpaces</span><span class="params">(<span class="built_in">string</span> &amp;input)</span> </span>&#123;</span><br><span class="line">    input.erase(input.begin(), find_if(input.begin(), input.end(), [](<span class="keyword">int</span> ch) &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">isspace</span>(ch);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trimRightTrailingSpaces</span><span class="params">(<span class="built_in">string</span> &amp;input)</span> </span>&#123;</span><br><span class="line">    input.erase(find_if(input.rbegin(), input.rend(), [](<span class="keyword">int</span> ch) &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">isspace</span>(ch);</span><br><span class="line">    &#125;).base(), input.end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">binaryTreeNode* <span class="title">stringTobinaryTreeNode</span><span class="params">(<span class="built_in">string</span> input)</span> </span>&#123;</span><br><span class="line">    trimLeftTrailingSpaces(input);</span><br><span class="line">    trimRightTrailingSpaces(input);</span><br><span class="line">    input = input.substr(<span class="number">1</span>, input.length() - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (!input.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> item;</span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    ss.str(input);</span><br><span class="line"></span><br><span class="line">    getline(ss, item, <span class="string">','</span>);</span><br><span class="line">    binaryTreeNode* root = <span class="keyword">new</span> binaryTreeNode(stoi(item));</span><br><span class="line">    <span class="built_in">queue</span>&lt;binaryTreeNode*&gt; nodeQueue;</span><br><span class="line">    nodeQueue.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        binaryTreeNode* node = nodeQueue.front();</span><br><span class="line">        nodeQueue.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!getline(ss, item, <span class="string">','</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        trimLeftTrailingSpaces(item);</span><br><span class="line">        <span class="keyword">if</span> (item != <span class="string">"null"</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftNumber = stoi(item);</span><br><span class="line">            node-&gt;left = <span class="keyword">new</span> binaryTreeNode(leftNumber);</span><br><span class="line">            nodeQueue.push(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!getline(ss, item, <span class="string">','</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        trimLeftTrailingSpaces(item);</span><br><span class="line">        <span class="keyword">if</span> (item != <span class="string">"null"</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> rightNumber = stoi(item);</span><br><span class="line">            node-&gt;right = <span class="keyword">new</span> binaryTreeNode(rightNumber);</span><br><span class="line">            nodeQueue.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> tmp = <span class="string">"[1,2,3,5,4,6,7,8,5]"</span>;</span><br><span class="line">binaryTreeNode* root =  stringTobinaryTreeNode(tmp);</span><br><span class="line">prettyPrintTree(root,<span class="string">""</span>,<span class="literal">true</span>);</span><br><span class="line">reverseBinaryTree(root);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"result: "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">prettyPrintTree(root,<span class="string">""</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题28：对称的二叉树"><a href="#面试题28：对称的二叉树" class="headerlink" title="面试题28：对称的二叉树"></a>面试题28：对称的二叉树</h2><blockquote><p>题目：实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它就是对称的。</p></blockquote><p>思路：通过对比二叉树的前序遍历序列和对称前序遍历序列来判断二叉树是不是对称的。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetry</span><span class="params">(binaryTreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isSymmetry(root,root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetry</span><span class="params">(binaryTreeNode* root1,binaryTreeNode* root2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对称条件应该是一直到所有的空节点</span></span><br><span class="line">    <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span> &amp;&amp; root2 == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span> || root2 == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//所以这里应该需要判断不相等来终止遍历，而不是判断相等（无法检查）</span></span><br><span class="line">    <span class="keyword">if</span>(root1-&gt;value != root2-&gt;value)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> isSymmetry(root1-&gt;left,root1-&gt;right) &amp;&amp;</span><br><span class="line">        isSymmetry(root1-&gt;right,root1-&gt;left); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题29：顺时针打印矩阵"><a href="#面试题29：顺时针打印矩阵" class="headerlink" title="面试题29：顺时针打印矩阵"></a>面试题29：顺时针打印矩阵</h2><blockquote><p>题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p></blockquote><p>思路：首先把顺时针打印分解为一圈一圈的打印，起点为左上角的点。然后分析打印结束的条件：即左上角在中心的左上。<br>然后再把每一圈分为四个步骤，从左到右打印一行，从上到下打印一列，从右到左打印一行，从下到上打印一列。每一步根据起始和终止坐标进行循环打印。<br>需要注意的是最后一圈，打印步骤不全。</p><ol><li>第一步总是需要的，因为打印一圈至少有一步。</li><li>第二步的前提条件是终止行号大于起始行号。</li><li>第三步的前提条件是圈内至少还有两行两列。</li><li>第四步的前提条件是圈内至少还有三行两列。</li></ol><p>解法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMatrixCircle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; input , <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> rows = input.size();</span><br><span class="line">    <span class="keyword">int</span> cols = input[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> endX = cols - <span class="number">1</span> - count;</span><br><span class="line">    <span class="keyword">int</span> endY = rows - <span class="number">1</span> - count;</span><br><span class="line">    <span class="comment">//从左到右打印一行</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = count; i &lt;= endX;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;input[count][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从上到下打印一列</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = count+<span class="number">1</span>; i &lt;= endY;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;input[i][endX];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = endX - <span class="number">1</span>; i &gt;= count &amp;&amp; endY != count;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;input[endY][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = endY - <span class="number">1</span>; i &gt;= count+<span class="number">1</span> &amp;&amp; endX != count;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;input[i][count];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = input.size();</span><br><span class="line">    <span class="keyword">if</span>(rows &lt; <span class="number">1</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> cols = input[<span class="number">0</span>].size();</span><br><span class="line">    <span class="comment">//圈数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count*<span class="number">2</span> &lt; rows &amp;&amp; count*<span class="number">2</span> &lt; cols)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        printMatrixCircle(input,count);</span><br><span class="line">        count ++;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; target = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;,&#123;<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">for_each(target.begin(),target.end(),[](<span class="keyword">auto</span> tmp)&#123;</span><br><span class="line">for_each(tmp.begin(),tmp.end(),[](<span class="keyword">auto</span> value)&#123;<span class="built_in">cout</span>&lt;&lt;value&lt;&lt;<span class="string">' '</span>;&#125;);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;);</span><br><span class="line">printMatrix(target);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="面试题30：包含min函数的栈"><a href="#面试题30：包含min函数的栈" class="headerlink" title="面试题30：包含min函数的栈"></a>面试题30：包含min函数的栈</h2><blockquote><p>题目:定义栈的数据结构摸清在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min、push、pop的时间复杂度都是O(1)。</p></blockquote><p>思路：在栈的数据结构中添加一个辅助栈用来保存最小元素，同时保证辅助栈的长度与主栈相同（即当压入的数没有辅助栈当前的数小时，辅助栈中用当前最小数代替压入辅助栈），这是为了让最小值的在两个栈中位置相同，同时保证最小数在被弹出之前一直存在。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> stackWithMin&lt;T&gt; :: push(<span class="keyword">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    m_data.push(value);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(m_data.size() == <span class="number">0</span> || value &lt; m_data.top())</span><br><span class="line">        m_min.push(value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        m_min.push(m_min.top());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> stackWithMin&lt;T&gt; :: pop()</span><br><span class="line">&#123;</span><br><span class="line">    assert(m_data.size() &gt; <span class="number">0</span> &amp;&amp; m_min.size() &gt; <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    m_data.pop();</span><br><span class="line">    m_min.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">const</span> T&amp; stackWithMin&lt;T&gt; :: getMin()</span><br><span class="line">&#123;</span><br><span class="line">    assert(m_data.size() &gt; <span class="number">0</span> &amp;&amp; m_min.size() &gt; <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> m_min.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面试题21：调整数组顺序是的奇数位于偶数前面&quot;&gt;&lt;a href=&quot;#面试题21：调整数组顺序是的奇数位于偶数前面&quot; class=&quot;headerlink&quot; title=&quot;面试题21：调整数组顺序是的奇数位于偶数前面&quot;&gt;&lt;/a&gt;面试题21：调整数组顺序是的奇数位于偶数
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer习题学习过程11-20</title>
    <link href="http://yoursite.com/2019/06/19/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B11-20/"/>
    <id>http://yoursite.com/2019/06/19/剑指offer习题学习过程11-20/</id>
    <published>2019-06-19T07:01:24.000Z</published>
    <updated>2019-07-19T13:36:29.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题11：旋转数组的最小数字（查找和排序）"><a href="#面试题11：旋转数组的最小数字（查找和排序）" class="headerlink" title="面试题11：旋转数组的最小数字（查找和排序）"></a>面试题11：旋转数组的最小数字（查找和排序）</h2><blockquote><p>题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如{3,4,5,1,2}是{1,2,3,4,5}的一个旋转，该数组的最小值为1。</p></blockquote><p>思路：和二分查找一样，用一个指针指向前面递增数组的元素，第二个指针指向后面递增数组的元素，依据旋转数组的特性，第一指针的值应该大于第二指针。不断寻找，当第一指针指向前面数组的最后一个元素时，第二指针会指向后面数组的第一个元素即最小的元素。</p><p>需要注意的特殊情况：</p><ol><li>数组为空</li><li>数组并没有旋转</li><li>数组中有重复数字</li></ol><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = input.size();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">1</span> || input[<span class="number">0</span>] &lt; input[length<span class="number">-1</span>])<span class="keyword">return</span> input[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>((input[left] == input[mid]) &amp;&amp; (input[right] == input[mid]))</span><br><span class="line">            <span class="keyword">return</span> minOrdered(input);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(input[right] &gt;= input[mid])&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(input[right] &lt;= input[mid])&#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> input[right];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minOrdered</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = input[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> a : input)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a &lt; tmp)</span><br><span class="line">            tmp = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题12：矩形中的路径（回溯）"><a href="#面试题12：矩形中的路径（回溯）" class="headerlink" title="面试题12：矩形中的路径（回溯）"></a>面试题12：矩形中的路径（回溯）</h2><blockquote><p>题目：设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中左、右、上、下移动一个。如果一条路径经过了矩阵的某一格，那么改路径不能再次进入该格子。例如，在下面3x4的矩阵中包含一条字符串“bfce”的路径。但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><table><thead><tr><th>a</th><th>b</th><th>t</th><th>g</th></tr></thead><tbody><tr><td>c</td><td>f</td><td>c</td><td>s</td></tr><tr><td>j</td><td>d</td><td>e</td><td>h</td></tr></tbody></table></blockquote><p>思路：回溯法。利用递归的特性，路径可以看成一个栈，同时由于路径不能重复进入一个矩阵的格子，所以需要定义和字符矩阵一样大小的布尔矩阵。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//row、col代表现在所在的位置，index代表现在选择的字符，map用于存储是否重复</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hashPathCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; input,<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="built_in">string</span> target,<span class="keyword">int</span> index,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = input.size();</span><br><span class="line">    <span class="keyword">int</span> cols = input[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> length = target.size();</span><br><span class="line">    <span class="comment">//递归结束条件，成功找到所有字符</span></span><br><span class="line">    <span class="keyword">if</span>(index == length - <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//失败条件</span></span><br><span class="line">    <span class="keyword">if</span>(row &lt; <span class="number">0</span> || col &lt; <span class="number">0</span> || row &gt;= rows || col &gt;= cols || <span class="built_in">map</span>[row][col] )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//单个字符遍历</span></span><br><span class="line">    <span class="keyword">bool</span> resu;</span><br><span class="line">    <span class="keyword">if</span>(input[row][col] == target[index])&#123;</span><br><span class="line">        <span class="built_in">map</span>[row][col] = <span class="number">1</span>;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="comment">//上下左右的寻找</span></span><br><span class="line">        resu = hashPathCore(input,row+<span class="number">1</span>,col,target,index,<span class="built_in">map</span>)</span><br><span class="line">            || hashPathCore(input,row,col+<span class="number">1</span>,target,index,<span class="built_in">map</span>)</span><br><span class="line">            || hashPathCore(input,row<span class="number">-1</span>,col,target,index,<span class="built_in">map</span>)</span><br><span class="line">            || hashPathCore(input,row,col<span class="number">-1</span>,target,index,<span class="built_in">map</span>);</span><br><span class="line">        <span class="keyword">if</span>(resu == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="built_in">map</span>[row][col] = <span class="number">0</span>;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resu;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hashPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; input,<span class="built_in">string</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = input.size();</span><br><span class="line">    <span class="keyword">int</span> cols = input[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> length = target.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>(rows,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (cols));</span><br><span class="line">    <span class="comment">//寻找开头的起点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;i &lt; cols;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashPathCore(input,i,j,target,<span class="number">0</span>,<span class="built_in">map</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">               </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>                          </span></span><br><span class="line"><span class="function"></span>&#123;                                   </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; test = &#123;&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>&#125;,&#123;<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>&#125;,&#123;<span class="string">'i'</span>,<span class="string">'j'</span>,<span class="string">'e'</span>,<span class="string">'k'</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"abfge"</span>;              </span><br><span class="line">    <span class="keyword">bool</span> resu = hashPath(test,str);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;test.size()&lt;&lt;<span class="string">' '</span>&lt;&lt;test[<span class="number">0</span>].size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; test.size();i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; test[<span class="number">0</span>].size();j++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;test[i][j]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;resu;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题13：机器人的运动范围（回溯）"><a href="#面试题13：机器人的运动范围（回溯）" class="headerlink" title="面试题13：机器人的运动范围（回溯）"></a>面试题13：机器人的运动范围（回溯）</h2><blockquote><p>题目：地上有一个m行n列的方格。一个机器人从坐标(0,0)的格子开始移动，它每次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格(35,37)，因为3+5+3+7=18 &lt;= 18，但不能进入(35,38)。请问该机器人能够达到多少格子。</p></blockquote><p>思路：同样是回溯法，与12题相比区别的地方是判断条件和不需要对标记map进行清零。</p><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//获取位数之和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">digitSum</span><span class="params">(<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(target)&#123;</span><br><span class="line">        result += target%<span class="number">10</span>;</span><br><span class="line">        target /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//row、col代表现在所在的位置，index代表现在选择的字符，map用于存储是否重复</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashPathCore</span><span class="params">(<span class="keyword">int</span> threshold,<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;<span class="built_in">map</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//能够进入条件</span></span><br><span class="line">    <span class="keyword">if</span>(row &gt;= <span class="number">0</span> &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &lt; cols &amp;&amp; !<span class="built_in">map</span>[row][col] &amp;&amp; threshold &gt;= (digitSum(row) + digitSum(col)))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">map</span>[row][col] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//上下左右的寻找</span></span><br><span class="line">    count = <span class="number">1</span> + hashPathCore(threshold,row+<span class="number">1</span>,col,rows,cols,<span class="built_in">map</span>)</span><br><span class="line">        + hashPathCore(threshold,row,col+<span class="number">1</span>,rows,cols,<span class="built_in">map</span>)</span><br><span class="line">        + hashPathCore(threshold,row<span class="number">-1</span>,col,rows,cols,<span class="built_in">map</span>)</span><br><span class="line">        + hashPathCore(threshold,row,col<span class="number">-1</span>,rows,cols,<span class="built_in">map</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashPath</span><span class="params">(<span class="keyword">int</span> threshold,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;<span class="built_in">map</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; map1(rows,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (cols));</span><br><span class="line">    <span class="comment">//从(0,0)开始遍历</span></span><br><span class="line">    <span class="keyword">int</span> result = hashPathCore(threshold,<span class="number">0</span>,<span class="number">0</span>,rows,cols,map1);</span><br><span class="line">copy(map1.begin(),map1.end(),<span class="built_in">map</span>.begin());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">               </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>                          </span></span><br><span class="line"><span class="function"></span>&#123;                                   </span><br><span class="line">    <span class="keyword">int</span> rows = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">int</span> cols = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">int</span> threshold = <span class="number">14</span>;  </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>(rows,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (cols));</span><br><span class="line"><span class="keyword">int</span> resu = hashPath(threshold,rows,cols,<span class="built_in">map</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"rows:"</span>&lt;&lt;rows&lt;&lt;<span class="string">' '</span>&lt;&lt;<span class="string">"cols:"</span>&lt;&lt;cols&lt;&lt;<span class="string">"threshold:"</span>&lt;&lt;threshold&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;resu&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">map</span>[i][j]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题14：剪绳子（动态，贪婪）"><a href="#面试题14：剪绳子（动态，贪婪）" class="headerlink" title="面试题14：剪绳子（动态，贪婪）"></a>面试题14：剪绳子（动态，贪婪）</h2><blockquote><p>题目：给你一根长度为n的绳子，请把绳子剪成m段，每段绳子的长度记为k[0],k[1],k[2]…。请问k[0]xk[1]xk[2]….k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2，3，3的三段，此时得到的最大乘积是18.</p></blockquote><p>思路1：动态规划dp，空间复杂度O(n^2)，空间复杂度O(n)。</p><p>思路2：贪婪算法，空间复杂度O(1)，空间复杂度O(1)。</p><p>解法1：定义f(n)为把长度为n的绳子剪成若干段后各段长度乘积的最大值。f(n) = max(f(i)xf(n-i))</p><ol><li>确定边界值f(0),f(1),f(2),f(3)</li><li>避免重复计算子问题，从小到大开始算</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(length ==<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//前面因为必须要剪一刀，所以f(3)=2。而之后必然会剪一刀，其局部最大值等于本身即可。</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; product = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>;i &lt;= length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//因为对称的关系，所以只用计算下半段即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; i/<span class="number">2</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = product[i - j] * product[j];</span><br><span class="line">            max = tmp &gt; max ? tmp : max;</span><br><span class="line">        &#125;</span><br><span class="line">        product.push_back(max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> product[length];    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> result = maxProduct(length);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"result: "</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法2：贪婪算法</p><ol><li>当n &gt;= 5时，尽可能剪长度为3的绳子</li><li>当剩余长度为4时，剪成两段长度为2的绳子</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(length ==<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(length ==<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count3 = length/<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(length%<span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">        result = <span class="built_in">pow</span>(<span class="number">3</span>,count3<span class="number">-1</span>)*<span class="number">4</span>;</span><br><span class="line">    result = <span class="built_in">pow</span>(<span class="number">3</span>,count3)*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> result = maxProduct(length);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"result: "</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题15：二进制中1的个数（位运算）"><a href="#面试题15：二进制中1的个数（位运算）" class="headerlink" title="面试题15：二进制中1的个数（位运算）"></a>面试题15：二进制中1的个数（位运算）</h2><blockquote><p>实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如9的二进制是1001，则输出2。</p></blockquote><p>思路：</p><ol><li>判断最后一位，然后右移。</li><li>用flag不断左移判断，避免负数导致的死循环。</li><li>一个整数n，n-1和n做并运算会把最右边的1变为0。</li></ol><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果输入的是负数会引起死循环</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countBit</span><span class="params">(<span class="keyword">int</span> input)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(input)&#123;</span><br><span class="line">    <span class="keyword">if</span>(input &amp; <span class="number">1</span>)</span><br><span class="line">        result++;</span><br><span class="line">        input = input &gt;&gt; <span class="number">1</span>;             </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改良方案,训练次数为int的位数即32。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countBit</span><span class="params">(<span class="keyword">int</span> input)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">    <span class="keyword">if</span>(input &amp; <span class="number">1</span>)</span><br><span class="line">        result++;</span><br><span class="line">        flag = flag &lt;&lt; <span class="number">1</span>;             </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个整数n，n-1和n做并运算会把最右边的1变为0。假设1100与1011做与运算，结果是1000。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countBit</span><span class="params">(<span class="keyword">int</span> input)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(input)&#123;</span><br><span class="line">        result++;</span><br><span class="line">        input = (input<span class="number">-1</span>) &amp; input; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题16：数值的整数次方（代码规范）"><a href="#面试题16：数值的整数次方（代码规范）" class="headerlink" title="面试题16：数值的整数次方（代码规范）"></a>面试题16：数值的整数次方（代码规范）</h2><p>错误处理的集中方式：</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>返回值</td><td>和系统API一致</td><td>不能方便地使用计算结果</td></tr><tr><td>全局变量</td><td>能够方便地使用计算结果</td><td>用户可能会忘记检查全局变量</td></tr><tr><td>异常</td><td>可以为不同的出错原因定义不同的异常类型，逻辑清晰</td><td>有些语言不支持异常，对性能有影响</td></tr></tbody></table><blockquote><p>题目：实现函数doublePower(double base,int exponent)，求base的exponent次方。不得使用库函数，同时考虑大数问题。</p></blockquote><ol><li>注意检查输入，并且知道该如何输出此异常（因为0也是答案，所以要考虑其他方案比如全局变量）。</li><li>快速幂的计算。</li><li>结果的溢出（没有考虑）。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有考虑指数为负的情况</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">int</span> exponent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">1</span>)<span class="keyword">return</span> base;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(exponent)&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent &amp; <span class="number">1</span>)</span><br><span class="line">        result *=base;</span><br><span class="line">        base *=base;</span><br><span class="line">        exponent = exponent &gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题17：打印从1到最大的n位数-大数问题"><a href="#面试题17：打印从1到最大的n位数-大数问题" class="headerlink" title="面试题17：打印从1到最大的n位数(大数问题)"></a>面试题17：打印从1到最大的n位数(大数问题)</h2><blockquote><p>题目：输入数字n，按顺序打印出从1到最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数999。</p></blockquote><ol><li>注意大数问题，只要n稍微一大就会超出long long的限制，可以使用字符串实现超高位数的打印。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//模拟十进制递增</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Increment</span><span class="params">(<span class="keyword">char</span> *number)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in">strlen</span>(number);</span><br><span class="line">    <span class="comment">//记录进位</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = length<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> nSum = number[i] - <span class="string">'0'</span> + carry;</span><br><span class="line">        <span class="keyword">if</span>(i == length<span class="number">-1</span>)</span><br><span class="line">            nSum ++;</span><br><span class="line">        <span class="keyword">if</span>(nSum &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="comment">//最高位进位即溢出</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                nSum -= <span class="number">10</span>;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">                number[i] = nSum +<span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            number[i] = nSum +<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印字符串（从非零开始打印）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumber</span><span class="params">(<span class="keyword">char</span>* number)</span></span>&#123;</span><br><span class="line">    <span class="comment">//用来记录非零打印的开始</span></span><br><span class="line">    <span class="keyword">bool</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in">strlen</span>(number);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!start &amp;&amp; number[i] != <span class="string">'0'</span>)</span><br><span class="line">            start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(start)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,number[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMaxDigit</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">char</span> *number = <span class="keyword">new</span> <span class="keyword">char</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(number,<span class="string">'0'</span>,n);</span><br><span class="line">    number[n] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="comment">//模拟十进制递增</span></span><br><span class="line">    <span class="keyword">while</span>(!Increment(number))&#123;</span><br><span class="line">        <span class="comment">//打印字符串，从第一个非零字符开始打印</span></span><br><span class="line">        printNumber(number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n =<span class="number">5</span>;</span><br><span class="line">printMaxDigit(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题18：删除链表的节点（链表）"><a href="#面试题18：删除链表的节点（链表）" class="headerlink" title="面试题18：删除链表的节点（链表）"></a>面试题18：删除链表的节点（链表）</h2><blockquote><p>题目1：在O(1)时间内删除链表节点。</p><p>给定单向链表的头指针和一个节点指针，定义个函数在O(1)时间内删除该节点。链表节点定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span></span></span><br><span class="line"><span class="class">&gt; &#123;</span></span><br><span class="line">&gt;     <span class="keyword">int</span> value;</span><br><span class="line">&gt;     listNode* next;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(listNode* head,listNode* needToDelete)</span></span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p>思路：删除一个节点有两种方法，一个是删除该节点，让前一个节点指向下一个节点。另一个是将该节点的值该为下一个节点的值，然后指向下一个节点的下一个节点，删除下一个节点（好处在于不需要上一个节点）。</p><p>需要注意的边界情况：</p><ol><li>删除的节点处于链表的尾部</li><li>链表只有一个节点，删除的也是这一个节点，就需要删除之后将头节点设置为nullptr。</li></ol><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数双指针是因为可能会删除头节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(listNode** head,listNode* needToDelete)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !needToDelete)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//删除的节点不是尾部</span></span><br><span class="line">    <span class="keyword">if</span>(needToDelete-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        listNode* pNext = needToDelete-&gt;next;</span><br><span class="line">        needToDelete-&gt;value = pNext-&gt;value;</span><br><span class="line">        needToDelete-&gt;next = pNext-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">delete</span> pNext;  </span><br><span class="line">        pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表只有一个节点，且删除它</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(*head == needToDelete)</span><br><span class="line">    &#123;</span><br><span class="line">        needToDelete = <span class="literal">nullptr</span>;</span><br><span class="line">        **head = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表有多个节点，并且删除的是尾节点，所以需要找到它的前一个节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        listNode* pNext = *head;</span><br><span class="line">        <span class="comment">//寻找前一个节点</span></span><br><span class="line">        <span class="keyword">while</span>(pNext-&gt;next != needToDelete)</span><br><span class="line">        &#123;</span><br><span class="line">            pNext = pNext-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pNext-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> needToDelete;</span><br><span class="line">        needToDelete = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目2：删除链表中重复的节点</p><p>在一个排序的链表中，如何删除重复的节点</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDuplication</span><span class="params">(listNode **head)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || *head == <span class="literal">nullptr</span>)<span class="keyword">return</span> ;</span><br><span class="line">    </span><br><span class="line">    listNode *preNode = <span class="literal">nullptr</span>;</span><br><span class="line">    listNode *curNode = *head;</span><br><span class="line">    <span class="keyword">while</span>(curNode == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        listNode *pNext = curNode-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(pNext != <span class="literal">nullptr</span> &amp;&amp; pNext-&gt;value == curNode-&gt;value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> value = curNode-&gt;value;</span><br><span class="line">            listNode* needToDelete = curNode;</span><br><span class="line">            <span class="comment">//一直删除直到pNext遇到不相同的数</span></span><br><span class="line">            <span class="keyword">while</span>(needToDelete != <span class="literal">nullptr</span> &amp;&amp; needToDelete-&gt;value == value)</span><br><span class="line">            &#123;</span><br><span class="line">                pNext = needToDelete-&gt;next;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">delete</span> needToDelete;</span><br><span class="line">                needToDelete = <span class="literal">nullptr</span>;</span><br><span class="line">                </span><br><span class="line">                needToDelete = pNext;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//删除结束之后pre，cur向后进一</span></span><br><span class="line">            <span class="comment">//头结点重复时，head换为下一个节点，pre保持不变（应该不会出现的情况）</span></span><br><span class="line">            <span class="keyword">if</span>(preNode == <span class="literal">nullptr</span>)</span><br><span class="line">                head = pNext;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                preNode-&gt;next = pNext;</span><br><span class="line">            curNode = pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有删除的情况</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            preNode = curNode;</span><br><span class="line">            curNode = curNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题19：正则表达式匹配（状态机）"><a href="#面试题19：正则表达式匹配（状态机）" class="headerlink" title="面试题19：正则表达式匹配（状态机）"></a>面试题19：正则表达式匹配（状态机）</h2><blockquote><p>实现一个函数用来匹配’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，’*‘表示表任意出现多次的一个字符，匹配是指字符串的所有字符串匹配整个模式。例如，字符串”aaa”匹配”a*a”或”a.a”</p></blockquote><p>思路：</p><ol><li>如果是字符’.’，则字符匹配。</li><li>如果模式字符等于字符串字符，则字符匹配。</li><li>如果下一个模式字符不是’*‘，则两者都移动到下一个字符匹配，不匹配返回false。</li><li>如果下一个模式字符是’*‘，则有两种情况<ol><li>模式字符向后移动两位（即认为*匹配0个字符或者已经完成匹配）。</li><li>模式字符保持不变（继续匹配*前面的字符）。</li></ol></li></ol><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">math</span><span class="params">(<span class="keyword">char</span>* str,<span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span> || pattern == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> mathCore（str,pattern）;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mathCore</span><span class="params">(<span class="keyword">char</span>* str,<span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//递归结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">'\0'</span> &amp;&amp; *pattern != <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(*(pattern+<span class="number">1</span>) == <span class="string">'*'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//case1:'a*' == 'a',case2:'.*'=='any'</span></span><br><span class="line">        <span class="keyword">if</span>(*pattern == *str || (*pattern == <span class="string">'.'</span> &amp;&amp; *str != <span class="string">'\0'</span>) )</span><br><span class="line">        &#123;                  </span><br><span class="line">            <span class="comment">//模式字符向后移动两位,并完成匹配</span></span><br><span class="line">            <span class="keyword">return</span> mathCore(str + <span class="number">1</span>,pattern + <span class="number">2</span>)</span><br><span class="line">            <span class="comment">//模式字符保持不变,继续匹配</span></span><br><span class="line">            || mathCore(str + <span class="number">1</span>,pattern)</span><br><span class="line">            <span class="comment">//模式字符向后移动两位,忽略'*'即匹配0个字符</span></span><br><span class="line">            || mathCore(str ,pattern + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//模式字符向后移动两位,忽略'*'即匹配0个字符</span></span><br><span class="line">            <span class="keyword">return</span> mathCore(str ,pattern + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//匹配'.'</span></span><br><span class="line">    <span class="keyword">if</span>(*str == *pattern || (*pattern == <span class="string">'.'</span> &amp;&amp; *str != <span class="string">'\0'</span>))</span><br><span class="line">        <span class="keyword">return</span> mathCore(str + <span class="number">1</span>,pattern + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题20：表示数值的字符串（字符串）"><a href="#面试题20：表示数值的字符串（字符串）" class="headerlink" title="面试题20：表示数值的字符串（字符串）"></a>面试题20：表示数值的字符串（字符串）</h2><blockquote><p>题目：实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-1023”,”3.1415926”,”-1E-16”都表示数值</p></blockquote><p>思路：表示数值的字符串遵循模式$A[.[B]][e|EC]$或者$.B[e|EC]$，其中A为整数部分，B为小数部分，C为指数部分，其中小数可能没有整数部分，比如”0.123”等价于”.123”。</p><ol><li>先判断整数</li><li>再判断小数</li><li>再判断指数</li><li>三者关系是(A || B ) &amp;&amp; C</li></ol><p>解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//检测无符号数字，扫描B部分</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">scanUnsignedInteger</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>** str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(**str != <span class="string">'\0'</span> &amp;&amp; <span class="string">'0'</span> &lt;= (**str) &amp;&amp; (**str) &lt;= <span class="string">'9'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        (*str)++;</span><br><span class="line">        count++;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &gt; <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测有符号数字，扫描A、C部分   </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">scanInteger</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>** str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(**str == <span class="string">'-'</span> || **str == <span class="string">'+'</span>)</span><br><span class="line">        (*str)++;</span><br><span class="line">    <span class="keyword">return</span> scanUnsignedInteger(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> result;</span><br><span class="line">    <span class="comment">//扫描A部分</span></span><br><span class="line">    result = scanInteger(&amp;str);</span><br><span class="line">    <span class="comment">//扫描小数部分</span></span><br><span class="line">    <span class="keyword">if</span>(*str ==<span class="string">'.'</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        str++;</span><br><span class="line">        <span class="comment">//可以没有A部分，所以用的或</span></span><br><span class="line"><span class="comment">//需要先判断小数部分，因为编译器先执行result的判断为真就会忽略之后的判断条件</span></span><br><span class="line">        result = scanUnsignedInteger(&amp;str) || result; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描E或者e</span></span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">'E'</span> ||*str == <span class="string">'e'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str++;</span><br><span class="line">        <span class="comment">//E前面需要有数字</span></span><br><span class="line">        result = result &amp;&amp; scanInteger(&amp;str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描之后字符串需要达到终点</span></span><br><span class="line">    <span class="keyword">return</span> result &amp;&amp; *str == <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"123.5"</span>;</span><br><span class="line"><span class="keyword">int</span> result = isNumber(str);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"result:"</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面试题11：旋转数组的最小数字（查找和排序）&quot;&gt;&lt;a href=&quot;#面试题11：旋转数组的最小数字（查找和排序）&quot; class=&quot;headerlink&quot; title=&quot;面试题11：旋转数组的最小数字（查找和排序）&quot;&gt;&lt;/a&gt;面试题11：旋转数组的最小数字（查找和排
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer习题学习过程1-10</title>
    <link href="http://yoursite.com/2019/06/19/%E5%89%91%E6%8C%87offer%E4%B9%A0%E9%A2%98%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B1-10/"/>
    <id>http://yoursite.com/2019/06/19/剑指offer习题学习过程1-10/</id>
    <published>2019-06-19T07:01:00.000Z</published>
    <updated>2019-06-19T07:06:24.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer习题学习过程"><a href="#剑指offer习题学习过程" class="headerlink" title="剑指offer习题学习过程"></a><strong>剑指offer习题学习过程</strong></h1><hr><h2 id="面试题1：赋值运算符函数"><a href="#面试题1：赋值运算符函数" class="headerlink" title="面试题1：赋值运算符函数"></a>面试题1：赋值运算符函数</h2><blockquote><p>如下为类型CMyString的声明，为该类型添加赋值运算符函数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMystring</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData = <span class="literal">nullptr</span>);</span><br><span class="line">    CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的点：</p><ul><li>是否把返回值的类型声明为该类型的引用。只有返回引用才能允许连续赋值，否则如果返回值为void，则无法连续复制。比如str1=str2=str3。</li><li>是否把传入的参数的类型声明为常量引用。</li><li>是否释放自身内存，在分配新内存之前释放自身已有空间。</li><li>判断传入的参数和当前实例（this*）是不是同一个实例，如果是，则不进行赋值操作，直接返回。<br>解答：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CMystring&amp; CMystring::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMystring&amp; str)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;str)&#123;</span><br><span class="line">        CMystring strTemp(str);<span class="comment">//局部变量，自动析构</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span>* pTemp = strTemp.m_pData; <span class="comment">//局部变量，自动析构</span></span><br><span class="line">        strTemp.m_pData = m_pData;</span><br><span class="line">        m_pData = pTemp;<span class="comment">//交换为了避免异常</span></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回一个引用才可以连续赋值，比如str1=str2=str3。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tips：C++中struct默认访问权限是public，class默认权限是private。</p><hr><h2 id="面试题2：实现Singleton模式"><a href="#面试题2：实现Singleton模式" class="headerlink" title="面试题2：实现Singleton模式"></a>面试题2：实现Singleton模式</h2><blockquote><p>设计一个类，只能生成该类的一个实例。（设计模式里面的单例模式）</p></blockquote><p>需要注意的点：</p><ul><li>单例模式分为两种<ol><li>饿汉式：即类产生的时候就创建好实例对象，这是一种空间换时间的方式</li><li>懒汉式：即在需要的时候，才创建对象，这是一种时间换空间的方式    </li></ol></li><li>C++单例记得初始化静态变量</li><li>注意线程的影响</li></ul><ol><li><p>单线程中最基本的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public sealed class Singlenton1//sealed代表密封的类，无法进行派生</span><br><span class="line">&#123;</span><br><span class="line">    private Singleton1()&#123; &#125;</span><br><span class="line">    private static instance = null;//C#可以在类中进行初始化</span><br><span class="line">    public static Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            if(instance == null)</span><br><span class="line">            instance = new Singleton1;</span><br><span class="line">            </span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多线程中使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意到实现中m_pInstance和GetInstance都是静态的，所以没有创建对象就已经存在了。通过调用GetInstance来创建或者获取唯一的对象</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSingleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CSingleton()&#123;&#125;                            </span><br><span class="line">    <span class="comment">//1.构造函数是私有的，不能通过构造函数创建该类的实例</span></span><br><span class="line">    <span class="keyword">static</span> CSingleton *m_pInstance;           </span><br><span class="line">    <span class="comment">//2.静态成员变量，且是私有的，指向一个CSingleton实例，同一时间只存在一个这个变量，所以只能存在一个CSingleton的实例</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> CSingleton *<span class="title">GetInstance</span><span class="params">()</span></span>&#123;         </span><br><span class="line">    <span class="comment">//3.只能通过这个函数来创建并获得一个CSingleton实例，且这个实例是唯一的（因为没有其他途径创建CSingleton实例，构造函数是私有的）</span></span><br><span class="line">    <span class="keyword">if</span>(m_pInstance == <span class="literal">NULL</span>)&#123;<span class="comment">//防止每次锁定导致线程堵塞。</span></span><br><span class="line">    lock();<span class="comment">//线程锁</span></span><br><span class="line">    <span class="keyword">if</span>(m_pInstance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            m_pInstance = <span class="keyword">new</span> CStingleton;</span><br><span class="line">        &#125;</span><br><span class="line">        unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> m_pInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CSingleton *CSingleton::m_pInstance = <span class="literal">NULL</span>;    <span class="comment">//4.初始化类的静态成员变量</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="面试题3：数组中重复的数字（数组）"><a href="#面试题3：数组中重复的数字（数组）" class="headerlink" title="面试题3：数组中重复的数字（数组）"></a>面试题3：数组中重复的数字（数组）</h2><blockquote><p>题目一：找出数组中重复的数字</p><p>​    在一个长度为n的数组里的所有数字都在0~n-1的范围内。并不知道其中有几个重复的，重复几次。请找出数组中任意重复的数字。</p><p>eg：input:{2,3,1,0,2,5,3}</p><p>output:2或者3</p></blockquote><p>思路1：数组排序，然后从头到尾扫描即可，时间复杂度O(nlogn)。</p><p>思路2：用哈希表解决问题，时间复杂度O(n)，空间复杂度O(n)。</p><p>思路3：利用数组中数字小于n做文章。遍历将i与sample[i]通过交换一一对应，过程中发现两次对应就找到重复数字。时间复杂度O(n),空间复杂度O(1)。</p><p>input:sample[N]<br>for $i =1\to N$<br>if $i == sample[i]$<br>then $i\gets i+1$<br>​    else if $sample[i] == sample[sample[i]]$<br>​    then return sample[i]<br>​        else $swap(sample[i],sample[sample[i]])$</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span>* duplication)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == null || length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(length &lt;= numbers[i] || <span class="number">0</span> &gt; numbers[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] != i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] != numbers[numbers[i]])</span><br><span class="line">            swap(numbers[i],numbers[numbers[i]]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目二：不修改数组找出重复的数字</p><p>​    在一个长度为n+1的数组里所有数字都在1~n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2,3,5,4,3,2,6,7}，那么对应输出的重复数字应该是2或者3。</p></blockquote><ol><li>以时间换空间（时间复杂度O(nlogn)，空间复杂度O(1)）</li><li>以空间换时间（时间复杂度O(n)，空间复杂度O(n)）</li></ol><p>1：利用二分法的思路，把1~n分为1~m和m+1~n，然后检测两者在数组中占有的个数，大于自身大小时即发现重复数。</p><p>2：用哈希表的思路，新建一个大小相同的数组，下标代替实际数值，就很容易发现。</p><p>解答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDuplication</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *numbers, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>, end = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> lowCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] &lt;= mid &amp;&amp; numbers[i] &gt;= start) &#123;</span><br><span class="line">                lowCnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lowCnt &gt; (mid - start + <span class="number">1</span>)) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题4：二维数组的查找（二维数组）"><a href="#面试题4：二维数组的查找（二维数组）" class="headerlink" title="面试题4：二维数组的查找（二维数组）"></a>面试题4：二维数组的查找（二维数组）</h2><blockquote><p>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><p>思路：从右上角或者左下角开始查找，每次对比都能剔除一列或者一行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从左下角开始查找</span></span><br><span class="line"><span class="function">boll <span class="title">find</span><span class="params">(<span class="keyword">int</span> target,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = input.size();</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == row) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> col = input[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == col) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//左下角开始</span></span><br><span class="line">    <span class="keyword">int</span> i = row<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span> &lt;= i || col &gt; j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == input[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; input[i][j])&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题5：替换空格（字符串）"><a href="#面试题5：替换空格（字符串）" class="headerlink" title="面试题5：替换空格（字符串）"></a>面试题5：替换空格（字符串）</h2><blockquote><p>将字符串中的空格替换为%20。（背景：因为URL参数中含有特殊符号时需要转化为%+ASCII码的样式）</p></blockquote><p>思路：先遍历一次字符串，获得所有空格的个数，然后得到现有字符串的长度=原有字符串长度+2*空格个数。之后定义两个指针，P1指向原有字符串的末尾，P2指向现有字符串的末尾，从后向前扫描，遇到空格后进行替换。做到时间复杂度O(n)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">replaceBlank</span><span class="params">(<span class="keyword">char</span> input[],length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(null == input || <span class="number">0</span> &gt;= length )<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> originalLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> currentLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> blankCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *tmp = input;</span><br><span class="line">    <span class="keyword">while</span>(*tmp != <span class="string">'\0'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*tmp == <span class="string">' '</span>)blankCount ++;</span><br><span class="line">        originalLength++;</span><br><span class="line">        tmp++;</span><br><span class="line">    &#125;</span><br><span class="line">    currentLength = originalLength + blankCount*<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(currentLength+<span class="number">1</span> &gt; length)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    input[currnetLength]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">int</span> P1 = originalLength<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> P2 = currnetLength<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = originalLength<span class="number">-1</span>;i &gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(input[<span class="number">1</span>] != <span class="string">' '</span>)&#123;</span><br><span class="line">            input[P2--] = input[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            input[P2--] = <span class="string">'0'</span>;</span><br><span class="line">            input[P2--] = <span class="string">'2'</span>;</span><br><span class="line">            input[P2--] = <span class="string">'%'</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题6：从尾到头打印链表（链表）"><a href="#面试题6：从尾到头打印链表（链表）" class="headerlink" title="面试题6：从尾到头打印链表（链表）"></a>面试题6：从尾到头打印链表（链表）</h2><blockquote><p>从尾到头打印链表</p></blockquote><p>思路：利用栈stack先进后出的特性实现，或者用递归函数实现（不推荐）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//stack 实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printFromTailToHead</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">while</span>(head != nullnullptr)&#123;</span><br><span class="line">        tmp.push(head-&gt;val);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!tmp.empty())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,tmp.top());</span><br><span class="line">        tmp.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printFromTailToHead2</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            printFromTailToHead2(head-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,head-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题7：重建二叉树（树）"><a href="#面试题7：重建二叉树（树）" class="headerlink" title="面试题7：重建二叉树（树）"></a>面试题7：重建二叉树（树）</h2><blockquote><p>输入某二叉树的前序遍历和中序遍历的记过，请重建该二叉树。</p></blockquote><p>思路：前序遍历root-&gt;left-&gt;right，中序遍历left-&gt;root-&gt;right。由此可以根据前序遍历找到根节点，再由中序遍历找到左子树和右子树。然后用递归重构出整个树。</p><p>前序：</p><table><thead><tr><th>1</th><th>2</th><th>4</th><th>7</th><th>3</th><th>5</th><th>6</th><th>8</th></tr></thead><tbody><tr><td>root</td><td>左</td><td>子</td><td>树</td><td>右</td><td>子</td><td>树</td></tr></tbody></table><p>中序：</p><table><thead><tr><th>4</th><th>7</th><th>2</th><th>1</th><th>5</th><th>3</th><th>8</th><th></th></tr></thead><tbody><tr><td>左</td><td>子</td><td>树</td><td>root</td><td>右</td><td>子</td><td>树</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    binaryTreeNode *m_left;</span><br><span class="line">    binaryTreeNode *m_right;</span><br><span class="line">    binaryTreeNode(<span class="keyword">int</span> x) :val(x), m_left(<span class="literal">nullptr</span>), m_right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">binaryTreeNode *<span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder)</span></span>&#123;</span><br><span class="line">    <span class="comment">//检测输入</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == preorder.size() || preorder.size() == inorder)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> root = preorder[<span class="number">0</span>];</span><br><span class="line">    binaryTreeNode *newNode = <span class="keyword">new</span> binaryTreeNode(root);</span><br><span class="line">    <span class="comment">//递归结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == preorder.size())<span class="keyword">return</span> newNode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> rootInorder = find(inorder.begin(),inorder.end(),root);</span><br><span class="line">    <span class="keyword">if</span>(rootInorder == inorder.end())<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> leftSize = rootInorder - inorder.begin();</span><br><span class="line">    <span class="keyword">int</span> rightSize = inorder.end() - rootInorder <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="comment">//两个参数分别代表前序和中序里的左子树的范围</span></span><br><span class="line">    newNode-&gt;m_left = reConstructBinaryTree(</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (preorder.begin()+<span class="number">1</span>,preorder.begin()+leftSize+<span class="number">1</span>),</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (inorder.begin(),inorder.begin()+leftSize));</span><br><span class="line">    <span class="comment">//两个参数分别代表前序和中序里的右子树的范围</span></span><br><span class="line">    newNode-&gt;m_left = reConstructBinaryTree(</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (preorder.begin()+leftSize+<span class="number">1</span>,preorder.end()),</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (inorder.begin()+leftSize+<span class="number">1</span>,inorder.end()));</span><br><span class="line">       </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin&#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    TreeNode *newRoot = reConstructBinaryTree(pre, vin);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题8：二叉树的下一个节点"><a href="#面试题8：二叉树的下一个节点" class="headerlink" title="面试题8：二叉树的下一个节点"></a>面试题8：二叉树的下一个节点</h2><blockquote><p>给定一个二叉树和其中的一个节点，如何找出中序遍历序列的下一个节点？树中的节点除了有两个分别指向左右子节点的指针，还有一个指向父节点的指针。</p></blockquote><p>思路：left-&gt;root-&gt;right</p><ol><li>如果该节点有右子树，则它的下一个节点是其右子树的最左子节点。（节点为root）</li><li>如果该节点没有右子树，但是它本身是其父节点的左子节点，那么它的下一个节点就是其父节点。（节点为left）</li><li>如果如果该节点没有右子树，并且是其父节点的右子节点，则需要不断寻找父节点，直到找到一个节点是其父节点的左子节点，那么它的下一个节点是该节点的父节点。（节点是right?）</li><li>都没有找到，就说明不存在下一个节点，返回nullptr。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treeLinkNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeLinkNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeLinkNode</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">treeLinkNode</span> *<span class="title">parent</span>;</span></span><br><span class="line">    treeLinkNode(<span class="keyword">int</span> x) :val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">treeLinkNode *<span class="title">getNext</span><span class="params">(treeLinkNode *pNode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">nullptr</span> == pNode)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        pNode = pNode-&gt;right;</span><br><span class="line">        <span class="keyword">while</span>(pNode-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            pNode = pNode-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(pNode-&gt;parent != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            treeLinkNode* pRoot = pNode-&gt;parent;</span><br><span class="line">            <span class="keyword">if</span>(pRoot-&gt;left == pNode)&#123;</span><br><span class="line">                <span class="keyword">return</span> pRoot;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode = pNode-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题9：使用两个栈实现队列（栈）"><a href="#面试题9：使用两个栈实现队列（栈）" class="headerlink" title="面试题9：使用两个栈实现队列（栈）"></a>面试题9：使用两个栈实现队列（栈）</h2><blockquote><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail和deleteHead，分别再队列尾部插入节点和再队列头部删除节点。</p></blockquote><p>队列的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">CQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:        </span><br><span class="line">CQueue(<span class="keyword">void</span>);</span><br><span class="line">~CQueue(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">const</span> T&amp; node)</span></span>;</span><br><span class="line"><span class="function">T <span class="title">deleteHead</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;T&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;T&gt; stack2;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：插入操作使用常规push即可。删除操作可以将stack1中的所有元素push到stack2中，这样顺序正好相反，pop操作即删除操作。需要注意的地方是当stack2中元素不为空时，添加操作是否会造成影响，答案是不会。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">void</span> CQueue&lt;T&gt;::appendTail(<span class="keyword">const</span> T&amp; node)&#123;</span><br><span class="line">    stack1.push(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">T CQueue&lt;T&gt;::deleteHead()&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != stack2.size())&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">0</span> != stack1.size())&#123;</span><br><span class="line">            T tmp = stack1.top();</span><br><span class="line">            stack1.pop();</span><br><span class="line">            stack2.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == stack2.size())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> exception(<span class="string">"queue is empty!"</span>);</span><br><span class="line">    T tmp = stack2.top();</span><br><span class="line">    stack2.pop();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tmp;           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题10：斐波那契数列（循环与递归）"><a href="#面试题10：斐波那契数列（循环与递归）" class="headerlink" title="面试题10：斐波那契数列（循环与递归）"></a>面试题10：斐波那契数列（循环与递归）</h2><blockquote><p>题目1：求斐波那契数列的第n项</p></blockquote><p>思路：f(n)=f(n-1)+f(n-2)</p><p>递归解法（效率太低）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> &gt;= n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>)+Fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> &gt;= n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        sum = tmp2 + i;</span><br><span class="line">        tmp1 = tmp2;</span><br><span class="line">        tmp2 = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目2：青蛙跳台阶问题</p><p>一直青蛙啊一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级台阶总共有多少种跳发。</p></blockquote><p>思路：将n级台阶跳法看成一个函数，如果第一次跳1级，则后面会有f(n-1)中方法，如果第一次跳2级，则后面会有f(n-2)中方法，则f(n)=f(n-1)+f(n-2)。其实也是斐波那契数列。</p><blockquote><p>扩展：如果青蛙可以跳上n级台阶，其他条件不变，则用数学归纳法可以证明f(n)=2^(n-1)。</p></blockquote><blockquote><p>变种：用2x1的小矩形去覆盖一个更大的矩形，如果用8个2x1的矩形去覆盖一个2x8的大矩形，则一共会有多少种方法。</p></blockquote><p>思路：将第一个矩形竖直放置的时候，右边还剩2x7的区域，会有f(7)的方法。将第一个矩形横向放置的时候，需要在下面还添加一个2x1的矩形，则右边还剩2x6的区域，会有f(6)的方法。则f(8)=f(7)+f(6)，实质上还是斐波那契数列。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;剑指offer习题学习过程&quot;&gt;&lt;a href=&quot;#剑指offer习题学习过程&quot; class=&quot;headerlink&quot; title=&quot;剑指offer习题学习过程&quot;&gt;&lt;/a&gt;&lt;strong&gt;剑指offer习题学习过程&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>STL学习过程</title>
    <link href="http://yoursite.com/2019/04/13/STL%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/04/13/STL学习/</id>
    <published>2019-04-13T08:37:34.000Z</published>
    <updated>2019-04-13T08:37:53.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STL学习过程"><a href="#STL学习过程" class="headerlink" title="STL学习过程"></a>STL学习过程</h1><p>前言：STL的学习看的是“侯捷STL”的教学视频，学习是为了更好地了解C++，养成更好的编程习惯，视频比较杂，暂时用要点的方式把需要记录的东西一个个记录下来。</p><h2 id="STL体系结构基础介绍"><a href="#STL体系结构基础介绍" class="headerlink" title="STL体系结构基础介绍"></a>STL体系结构基础介绍</h2><blockquote><p>STL分为6大部件</p></blockquote><ul><li>容器（container）</li><li>分配器（allocatior）</li><li>算法（algorithm）</li><li>迭代器（iterator）</li><li>适配器（adapter）</li><li>仿函数（functor）</li></ul><p>技术基础：</p><ul><li><p>泛化：template \<class type\> struct _type_traits</class></p></li><li><p>全特化：template &lt;&gt; struct _type_traits\&lt;int></p></li><li><p>偏特化：template \<class t\> struct _type_traits&lt;T*&gt;</class></p><h2 id="分配器Allocators"><a href="#分配器Allocators" class="headerlink" title="分配器Allocators"></a>分配器Allocators</h2></li><li><p>要点operator new()操作会调用malloc(),并且返回的指针指向的空间会多出一部分内容用于内存管理(overhead)。</p></li><li>gcc2.9中使用特殊的alloc，其开辟的空间大小是8的倍数，并用链表实现，减少malloc调用，节省额外开销(overhead)。</li></ul><h2 id="容器Containter"><a href="#容器Containter" class="headerlink" title="容器Containter"></a>容器Containter</h2><ul><li>容器直接的关系不是继承（inheritance），而是复合（composition）。  </li></ul><p>序列式容器：</p><ul><li>array（12字节）</li><li>vector（12字节）<ul><li>heap</li></ul></li><li>list（8字节）</li><li>forward_list（4字节）</li><li>deque（40字节）<ul><li>stack</li><li>queue</li></ul></li></ul><p>关联式容器：</p><ul><li>rb_tree(红黑树)（24字节-&gt;3ptr+1color）<ul><li>set（key值不可以重复）</li><li>map</li><li>multiset（key值可以重复）</li><li>multimap</li></ul></li><li>hashtable（28字节）<ul><li>unordered_set</li><li>unordered_map</li><li>unordered_multiset</li><li>unordered_multimap</li></ul></li></ul><h3 id="容器list"><a href="#容器list" class="headerlink" title="容器list"></a>容器list</h3><p>操作符重载例子：</p><ul><li>postfix form（后++）：self operator++ (int)。</li><li><p>prefix form（前++）: self&amp; operator++ ( )。(返回类型的不同是为了模拟int，int中i++++操作不被允许)。</p></li><li><p>list是环装双向链表，在尾端加了一个空白节点，是为了复合STL的前闭后开的原则。</p></li></ul><h3 id="iterator迭代器设计原则"><a href="#iterator迭代器设计原则" class="headerlink" title="iterator迭代器设计原则"></a>iterator迭代器设计原则</h3><ul><li>所有容器iterator都会有5个typedef（traits特性）：<ol><li>iterator_category（迭代方式，例如只能向前传递或双向传递）</li><li>value_type（数值类型）</li><li>pointer（暂未被使用）</li><li>reference（暂未被使用）</li><li>difference_type（两个iterator之间距离的类型）</li></ol></li><li>Iterator Traits迭代器萃取机：分离class iterators和non-class iterators（防止遇到不含成员的低级指针的迭代器），用来分辨获得的iterator的类型并取得其特性。（使用模板的特化实现。）</li></ul><h3 id="容器vector"><a href="#容器vector" class="headerlink" title="容器vector"></a>容器vector</h3><ul><li>vector中有三个元素：start、finish、end_of_storage。</li><li>vector扩充空间时创建当前空间乘以2的大小的空间，并将数据复制过去。</li></ul><h3 id="容器deque"><a href="#容器deque" class="headerlink" title="容器deque"></a>容器deque</h3><ul><li>运用分段存储实现向前向后扩容。利用deque iterator模拟连续空间，操作符重载。</li><li>deque的迭代器中有4个元素：cur、first、last、node<ul><li>cur代表当前元素位置</li><li>first代表当前段的第一个节点</li><li>last代表当前段的最后一个节点</li><li>node代表其所在段在deque的位置</li></ul></li><li>每一个buff里有512/sizeof(T)个元素。</li></ul><h3 id="容器rb-tree"><a href="#容器rb-tree" class="headerlink" title="容器rb_tree"></a>容器rb_tree</h3><ul><li>rb_tree<class key,class value,class keyofvalue,class compare>（第三个用来找到value里的key）。</class></li><li>insert_unique()和insert_equal()分别是可以插入不重复和重复key值的函数。</li></ul><h4 id="容器set"><a href="#容器set" class="headerlink" title="容器set"></a>容器set</h4><ul><li>set实际上算是红黑树的adapter，其中iterator是const，为了禁止客户对元素进行赋值。</li></ul><h4 id="容器map"><a href="#容器map" class="headerlink" title="容器map"></a>容器map</h4><ul><li>通过定义  typedef pair<const key, t> value_type; 来实现key的不可修改。</const></li><li>容器map有独特的operator[]，会通过中括号寻找key对应的值，没有则创建新的元素。</li></ul><h3 id="容器hashtable"><a href="#容器hashtable" class="headerlink" title="容器hashtable"></a>容器hashtable</h3><ul><li>哈希表的大小刻意为质数（素数），有一个质数表以供使用。</li><li>如果需要扩充，则扩大两倍并找到最近的质数作为哈希表的大小。</li><li>默认计算方式为data%sizeof(hashtable)</li><li>如果有位置冲突，则在冲突地地方生产一个链表</li></ul><h2 id="算法Algorithm"><a href="#算法Algorithm" class="headerlink" title="算法Algorithm"></a>算法Algorithm</h2><p>通用形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line">Algorithm(Iterator itr1,Iterator itr2)</span><br><span class="line">&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> Cmp&gt;</span><br><span class="line">Algorithm(Iterator itr1,Iterator itr2,Cmp comp)</span><br><span class="line">&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代器对算法的影响"><a href="#迭代器对算法的影响" class="headerlink" title="迭代器对算法的影响"></a>迭代器对算法的影响</h3><p>迭代器的5种移动特性：</p><ul><li>input_iterator_tag（istream）</li><li>output_iterator_tag（ostream）</li><li>forward_iterator_tag（forward_list,unorderd_set,unorderd_map,unorderd_multiset,unorderd_multimap）</li><li>bidirectional_iterator_tag（list,map,set,multiset,multimap）</li><li>random_access_iterator_tag（array,vector,deque） </li></ul><p>copy算法会针对不同的迭代器采用不同的算法。比如如果遇到较为简单的const char*则会使用memmove()（速度极快的低阶system级别的拷贝函数）。</p><h3 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h3><p>accumulate()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认累加</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="title">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">BinaryOperation</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">accumulate</span>(<span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">            <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">            <span class="title">T</span> <span class="title">init</span>,</span></span><br><span class="line"><span class="class">            <span class="title">BinaryOperation</span> <span class="title">binary_op</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span>( ;first != last; first++)</span><br><span class="line">        init = binary_op(init,first*);</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for_each()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="title">class</span> <span class="title">Function</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Function</span> <span class="title">for_each</span>(<span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">            <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class"><span class="title">Function</span> <span class="title">f</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span>( ;first != last; first++)</span><br><span class="line">        f(first*);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>replace(),replace_if(),replace_copy()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="title">class</span> <span class="title">Function</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">replace</span>(<span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">            <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class"><span class="title">const</span> <span class="title">T</span>&amp; <span class="title">old_value</span>,</span></span><br><span class="line"><span class="class">         <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">new_value</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span>( ;first != last; first++)</span><br><span class="line">        <span class="keyword">if</span>(*first == old_value)</span><br><span class="line">    *first == new_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="title">class</span> <span class="title">Function</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">replace_if</span>(<span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">            <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class"><span class="title">Predicate</span> <span class="title">pred</span>,</span></span><br><span class="line"><span class="class">         <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">new_value</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span>( ;first != last; first++)</span><br><span class="line">        <span class="keyword">if</span>(pred(*first))</span><br><span class="line">    *first == new_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>count()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">iterator_traits</span>&lt;InputIterator&gt;:</span>:difference_type</span><br><span class="line">count(InputIterator first,</span><br><span class="line">            InputIterator last,</span><br><span class="line">         <span class="keyword">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( ;first != last; first++)</span><br><span class="line">        <span class="keyword">if</span>(*first == value)</span><br><span class="line">    ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>find(),find_if()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">find</span>(<span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">            <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">         <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(first != last &amp;&amp; first* != value)</span><br><span class="line">    ++first;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sort()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现复杂不写了</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">sort</span>(<span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">            <span class="title">InputIterator</span> <span class="title">last</span>)</span></span><br></pre></td></tr></table></figure><p>reverse():</p><p>思想：是通过将迭代器左右倒置，仅仅改变迭代器及其规则来实现容器的倒置。</p><p>binary_search():</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">binary_search</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">            <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">         <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//除了lower_bound之外还有upper_bound，区别是如果有寻找的是重复的数字，则前者输出第一次出现的位置，后者输出最后一次出现的下一个位置</span></span><br><span class="line">    first = <span class="built_in">std</span>::lower_bound(first,last,value)</span><br><span class="line">    <span class="keyword">return</span> (first != last &amp;&amp; !(value &lt; *first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="仿函数Functor"><a href="#仿函数Functor" class="headerlink" title="仿函数Functor"></a>仿函数Functor</h2><ul><li>Functor一般为算法服务</li><li>分为算术类、逻辑运算类、相对关系类。</li></ul><p>比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">plus</span> :</span> <span class="keyword">public</span> binary_function&lt;T,T,T&gt;&#123;</span><br><span class="line">        <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x,constT&amp; y)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x+y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><ul><li><p>传入算法函数中需要传入对象，比如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(myvec.begin(),myvec.end(),less&lt;<span class="keyword">int</span>&gt;());</span><br></pre></td></tr></table></figure><p>其中less\&lt;int>是类型，less\&lt;int>()是对象。</p><p>因为其中是这样定义的：（其中public binary_function&lt;T,T,bool&gt;是为了继承STL）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">less</span> :</span> <span class="keyword">public</span> binary_function&lt;T,T,<span class="keyword">bool</span>&gt;&#123;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x,<span class="keyword">const</span> T&amp; y)</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> x &gt; y;&#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="仿函数的可适配条件"><a href="#仿函数的可适配条件" class="headerlink" title="仿函数的可适配条件"></a>仿函数的可适配条件</h3><ul><li><p>STL规定每个Adaptable Function都应该选择适当的function继承：(两者的区别是function涉及操作数的个数)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg</span>,<span class="title">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">unary_function</span>&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line"><span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>,<span class="title">class</span> <span class="title">Arg2</span>,<span class="title">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">binary_function</span>&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line"><span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line"><span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="适配器Adapter"><a href="#适配器Adapter" class="headerlink" title="适配器Adapter"></a>适配器Adapter</h2><ul><li>不是通过继承而是通过内含的方式来实现adapter。</li><li>使用范例：stack，queue就是通过适配器deque来实现的。</li></ul><h3 id="函数适配器binder2nd"><a href="#函数适配器binder2nd" class="headerlink" title="函数适配器binder2nd"></a>函数适配器binder2nd</h3><p>用法：</p><p>std::cout&lt;&lt;count_if(vi.begin() ,vi.end(), not1( bind2nd( less\&lt;int>(), 40)));</p><ul><li>函数适配器not1</li></ul><h3 id="函数适配器bind"><a href="#函数适配器bind" class="headerlink" title="函数适配器bind"></a>函数适配器bind</h3><p>   std::bind可以绑定</p><ol><li>functions</li><li>function objects</li><li>member functions,_1必须是某个object地址</li><li>data members,_1必须是某个object地址</li></ol><p>使用实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">my_divide</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> x/y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fun1 = bind(my_divide,<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; fun1()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出5</span></span><br></pre></td></tr></table></figure><h3 id="迭代器适配器reverse-iterator"><a href="#迭代器适配器reverse-iterator" class="headerlink" title="迭代器适配器reverse_iterator"></a>迭代器适配器reverse_iterator</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reverse_iterator</span><br><span class="line">rbegin()</span><br><span class="line">&#123;<span class="keyword">return</span> reverse_iterator(end());&#125;</span><br><span class="line">reverse_iterator</span><br><span class="line">rend()</span><br><span class="line">&#123;<span class="keyword">return</span> reverse_iterator(begin());&#125;</span><br></pre></td></tr></table></figure><p>核心代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对逆向迭代器取值就是讲“对应的正向迭代器”退一位取值。</span></span><br><span class="line">reference <span class="keyword">operator</span>*()<span class="keyword">const</span>&#123;</span><br><span class="line">    Iterator tmp = current;</span><br><span class="line">    <span class="keyword">return</span> *--tmp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代器适配器inserter"><a href="#迭代器适配器inserter" class="headerlink" title="迭代器适配器inserter"></a>迭代器适配器inserter</h3><p>用法：inserter(containter,iterator)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; foo,bar;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    foo.push_back(i);</span><br><span class="line">    bar.push_back(i*<span class="number">10</span>);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = foo.begin();</span><br><span class="line">advance(it,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">copy(bar.begin(),bar.end(),inserter(foo,it));</span><br><span class="line"><span class="comment">//before:</span></span><br><span class="line"><span class="comment">//foo:1,2,3,4,5</span></span><br><span class="line"><span class="comment">//bar:10,20,30,40,50</span></span><br><span class="line"><span class="comment">//after:</span></span><br><span class="line"><span class="comment">//foo:1,2,3,10,20,30,40,50,4,5</span></span><br><span class="line"><span class="comment">//bar:10,20,30,40,50</span></span><br></pre></td></tr></table></figure><p>实现方法是通过操作符重载改变copy中’=’的操作。</p><h3 id="X适配器：ostream-iterator"><a href="#X适配器：ostream-iterator" class="headerlink" title="X适配器：ostream_iterator"></a>X适配器：ostream_iterator</h3><p>使用实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ostream_iterator&lt;<span class="keyword">int</span>&gt; out_it(<span class="built_in">std</span>::<span class="built_in">cout</span>,<span class="string">','</span>);</span><br><span class="line"><span class="built_in">std</span>::copy (myvector.begin(),myvector.end(),out_it);</span><br><span class="line"><span class="comment">//结果会cout出myvector中的每一个元素，并在其中夹杂','。</span></span><br></pre></td></tr></table></figure><h3 id="X适配器：istream-iterator"><a href="#X适配器：istream-iterator" class="headerlink" title="X适配器：istream_iterator"></a>X适配器：istream_iterator</h3><p>使用实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::istream_iterator&lt;<span class="keyword">int</span>&gt; iit(<span class="built_in">std</span>::<span class="built_in">cin</span>),eos;<span class="comment">//eos(end of stream)用于标记终点</span></span><br><span class="line"><span class="built_in">std</span>::copy (iit,eos,inserter(c,c.begin()));</span><br><span class="line"><span class="comment">//结果会cin输入数据到容器c</span></span><br></pre></td></tr></table></figure><h2 id="一些用例"><a href="#一些用例" class="headerlink" title="一些用例"></a>一些用例</h2><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="built_in">string</span>,<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt;&gt; t;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(t)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出32 </span></span><br><span class="line"><span class="comment">//string:4int:4double:8    complex&lt;double&gt;:16</span></span><br><span class="line"><span class="comment">//应该是4+4+4+16 = 28</span></span><br></pre></td></tr></table></figure><p>实现原理（挺复杂的，只记下定义）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head,<span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;Head,Tail...&gt;</span></span><br><span class="line"><span class="class">:</span> <span class="keyword">private</span> tuple&lt;Tail&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> tuple&lt;Tail...&gt;inherited;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">tuple()&#123;&#125;</span><br><span class="line"><span class="comment">//这里是初始化列表</span></span><br><span class="line">tuple(Head v,Tail... vtail)</span><br><span class="line">:m_head(v),inherited(vtail...)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typename</span> Head::<span class="function">type <span class="title">head</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line"><span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Head m_head;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="type-traits"><a href="#type-traits" class="headerlink" title="type traits"></a>type traits</h3><p>用来保存数据中一些特性的重要性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛化版本  Gcc2.9版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">type_traits</span>&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> __true_type this_dummy_member_must_be_first;</span><br><span class="line"><span class="keyword">typedef</span> __false_type has_trivial_default_constructor;</span><br><span class="line"><span class="keyword">typedef</span> __false_type has_trivial_copy_constructor;</span><br><span class="line"><span class="keyword">typedef</span> __false_type has_trivial_assignment_operator;</span><br><span class="line"><span class="keyword">typedef</span> __false_type has_trivial_destructor;</span><br><span class="line"><span class="keyword">typedef</span> __false_type is_POD_type;<span class="comment">//Plain Old Data</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>会对算法里面一些操作有影响，比如copy()。</p><ul><li>POD用来表明C++中与C相兼容的数据类型，可以按照C的方式来处理（运算、拷贝等）。非POD数据类型与C不兼容，只能按照C++特有的方式进行使用。其实POD本质就是与c兼容的数据类型。 </li></ul><h3 id="moveable对各种容器速度的影响"><a href="#moveable对各种容器速度的影响" class="headerlink" title="moveable对各种容器速度的影响"></a>moveable对各种容器速度的影响</h3><ul><li>moveable元素对vector的影响极大</li></ul><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul><li><p>memcpy和memmove（）都是C语言中的库函数，在头文件string.h中，作用是拷贝一定长度的内存的内容，原型分别如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>他们的作用是一样的，唯一的区别是，当内存发生局部重叠的时候，memmove保证拷贝的结果是正确的，memcpy不保证拷贝的结果的正确。</p></li><li><p>深拷贝和浅拷贝的区别：浅拷贝只复制指针，深拷贝复制内容。</p></li><li>编译器自动提供的copy函数是浅拷贝。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;STL学习过程&quot;&gt;&lt;a href=&quot;#STL学习过程&quot; class=&quot;headerlink&quot; title=&quot;STL学习过程&quot;&gt;&lt;/a&gt;STL学习过程&lt;/h1&gt;&lt;p&gt;前言：STL的学习看的是“侯捷STL”的教学视频，学习是为了更好地了解C++，养成更好的编程习惯，视
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>苹果自动采摘机器人项目总结</title>
    <link href="http://yoursite.com/2019/03/12/%E9%87%87%E6%91%98%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/03/12/采摘机器人项目总结/</id>
    <published>2019-03-12T04:20:00.000Z</published>
    <updated>2019-03-12T04:20:53.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="苹果自动采摘机器人项目总结"><a href="#苹果自动采摘机器人项目总结" class="headerlink" title="苹果自动采摘机器人项目总结"></a>苹果自动采摘机器人项目总结</h1><p>前言：研究生期间老板交给我的主要项目了，就算代码写得再怎么烂，总得留点记录以供之后回忆。</p><h2 id="硬件组成"><a href="#硬件组成" class="headerlink" title="硬件组成"></a>硬件组成</h2><p><img src="/2019/03/12/采摘机器人项目总结/小车.jpg" alt="小车"></p><p>图中部件分别为：</p><ol><li>末端执行器 （中间嵌有摄像头）</li><li>Festo 气动推杆 </li><li>小臂关节 </li><li>大臂关节 </li><li>台达伺服电机 </li><li>腰部关节 </li><li>台达 A2伺服驱动器 </li><li>移动小车</li></ol><p>其中Festo气动通过OPC通信连接，台达电机通过串口通信连接。</p><h2 id="软件组成"><a href="#软件组成" class="headerlink" title="软件组成"></a>软件组成</h2><p>软件部分上位机部分用MFC框架编写，运行在工控机的WindowsXP系统上，有使用opencv视觉库和OPC通信库。其具体运作逻辑如下所示：(虽然看起来逻辑简单，但是有好多细节问题没法表示)</p><div id="flowchart-0" class="flow-chart"></div><h2 id="重要的细节点"><a href="#重要的细节点" class="headerlink" title="重要的细节点"></a>重要的细节点</h2><p>整个工程一共有三个并行的线程，其中主线程1负责整体逻辑的控制，一个子线程2负责摄像头的读取与苹果的识别并在人机界面显示，一个子线程3负责使用电机控制机械臂完成末端执行器和苹果的对准。</p><ul><li>其中在主线程1中使用三个定时器实现对气动的控制和整体逻辑的控制。<ol><li>定时器1：控制气动推出、抓手闭合和割刀启动。</li><li>定时器2：持续地读取气动推杆的绝对位置，从气动初始化之后一直运行，直到程序结束。</li><li>定时器3：控制抓手松开、电机线程重整的。<br>（定时器的开关由一系列状态标志位控制）</li></ol></li><li>负责苹果识别的子线程2完成摄像头对图像的读取，苹果的识别（为整个流程提供目标中心坐标ex，ey），和画面的显示。</li><li>负责电机控制的子线程3读取苹果的坐标(ex,ey)来实现抓手的位置校正。</li></ul><p>整体系统中不同线程中公用的资源有一系列状态的标志位和目标的中心点坐标（ex，ey），并没有冲突的地方，所以没有用到锁，也就没有死锁的问题。</p><p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始自动采摘e=>end: 采摘结束op1=>operation: 苹果识别获取坐标op2=>operation: 机械臂扫描op3=>operation: 气动推杆推出op4=>operation: 机械臂减速对准op5=>operation: 割刀启动，夹手夹住op6=>operation: 气动推杆收回，夹手松开cond1=>condition: 是否检测到苹果cond2=>condition: 光电门检测到物体或达到最大工作距离st->op2->cond1cond1(yes)->op4op4->op3op3->cond2cond2(yes)->op5cond2(no)->op3op5->op6op6->econd1(no)->op2</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;苹果自动采摘机器人项目总结&quot;&gt;&lt;a href=&quot;#苹果自动采摘机器人项目总结&quot; class=&quot;headerlink&quot; title=&quot;苹果自动采摘机器人项目总结&quot;&gt;&lt;/a&gt;苹果自动采摘机器人项目总结&lt;/h1&gt;&lt;p&gt;前言：研究生期间老板交给我的主要项目了，就算代码写得
      
    
    </summary>
    
    
      <category term="碎碎念" scheme="http://yoursite.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概述</title>
    <link href="http://yoursite.com/2019/03/11/%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2019/03/11/网络概述/</id>
    <published>2019-03-11T09:15:47.000Z</published>
    <updated>2019-03-13T08:08:49.551Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络概述</p><p>[TOC]</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h2><p>互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</p><p>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。</p><h2 id="主机之间的通信方式"><a href="#主机之间的通信方式" class="headerlink" title="主机之间的通信方式"></a>主机之间的通信方式</h2><p>客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。</p><p>对等（P2P）：不区分客户和服务器。</p><h2 id="电路交换与分组交换"><a href="#电路交换与分组交换" class="headerlink" title="电路交换与分组交换"></a>电路交换与分组交换</h2><ol><li><p>电路交换<br>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p></li><li><p>分组交换<br>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</p></li></ol><p>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。</p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</p><ol><li><p>排队时延<br>分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</p></li><li><p>处理时延<br>主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</p></li><li><p>传输时延<br>主机或路由器传输数据帧所需要的时间。<br>$delay=l(bit)/v(bit/s)$<br>其中$ l $表示数据帧的长度，$v ​$表示传输速率。</p></li><li><p>传播时延<br>电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。<br>$delay=l(m)/v(m/s)$<br>其中$l$表示信道长度，$v$表示电磁波在信道上的传播速度。</p></li></ol><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><ol><li><p>五层协议</p><ul><li>应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</li><li>传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li><li>网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li><li>数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li><li>物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul></li><li><p>OSI<br>OSI比五层协议在应用层多了表示层和会话层。<br>其中表示层和会话层用途如下：</p><ul><li>表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li><li>会话层 ：建立及管理会话。</li></ul></li></ol><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p><ol start="3"><li>TCP/IP</li></ol><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><ol start="4"><li>数据在各层之间的传递过程<br>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</li></ol><p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p><h1 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1.物理层"></a>1.物理层</h1><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p><ul><li>单工通信：单向传输</li><li>半双工通信：双向交替传输</li><li>全双工通信：双向同时传输</li></ul><h2 id="带通调制"><a href="#带通调制" class="headerlink" title="带通调制"></a>带通调制</h2><p>模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。</p><h1 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2.数据链路层"></a>2.数据链路层</h1><h2 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h2><ol><li><p>封装成帧<br>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p></li><li><p>透明传输<br>透明表示一个实际存在的事物看起来好像不存在一样。</p></li></ol><p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p><ol start="3"><li>差错检测<br>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</li></ol><p>CRC检验的原理：CRC 算法的基本思想是将传输的数据当做一个位数很长的数。将这个数除以另一个数。得到的余数作为校验数据附加到原数据后面。</p><h2 id="信道分类"><a href="#信道分类" class="headerlink" title="信道分类"></a>信道分类</h2><ol><li>广播信道<br>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</li></ol><p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p><p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</p><ol start="2"><li>点对点信道<br>一对一通信。</li></ol><p>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><ol><li><p>频分复用<br>频分复用的所有主机在相同的时间占用不同的频率带宽资源。</p></li><li><p>时分复用<br>时分复用的所有主机在不同的时间占用相同的频率带宽资源。</p></li></ol><p>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。</p><ol start="3"><li><p>统计时分复用<br>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。</p></li><li><p>波分复用<br>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p></li><li><p>码分复用<br>为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片$\vec{S}$和$\vec{T}$ 有<br>$$ 1/m \cdot\vec{S}\vec{T}=0 $$</p></li></ol><p>为了讨论方便，取 m=8，设码片$\vec{S}$为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。</p><p>在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到</p><p>$$ 1/m \cdot\vec{S}\vec{S}=1 $$</p><p>$$ 1/m \cdot\vec{S}\vec{S}^,=-1 $$</p><p>其中$\vec{S}^,$为$\vec{S}$的反码。</p><p>利用上面的式子我们知道，当接收端使用码片 $\vec{S}$对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。</p><p>码分复用需要发送的数据量为原先的 m 倍。</p><h2 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h2><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p><ul><li>多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li><li>载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li><li>碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。<br>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</li></ul><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p><h2 id="PPP-协议"><a href="#PPP-协议" class="headerlink" title="PPP 协议"></a>PPP 协议</h2><p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><p>PPP 的帧格式：</p><ul><li><p>F 字段为帧的定界符</p></li><li><p>A 和 C 字段暂时没有意义</p></li><li><p>FCS 字段是使用 CRC 的检验序列</p></li><li><p>信息部分的长度不超过 1500</p><p>F|A|C|协议|IP数据报|FCS|F<br>:–:|:–:|:–:|:–:|:–:|:–:|:–:<br>| | | | | | </p></li></ul><h2 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h2><p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p><p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p><p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p><p>可以按照网络拓扑结构对局域网进行分类：星型，环型，直线型</p><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>以太网是一种星型拓扑结构局域网。</p><p>早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。</p><p>目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。</p><p>以太网帧格式：</p><ul><li>类型 ：标记上层使用的协议；</li><li>数据 ：长度在 46-1500 之间，如果太小则需要填充；</li><li><p>FCS ：帧检验序列，使用的是 CRC 检验方法；</p><p>目的地址|源地址|类型|IP数据报|FCS<br>:–:|:–:|:–:|:–:|:–:<br>6|6|2|46-1500|4| </p></li></ul><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。</p><p>正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</p><p>交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p><h2 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h2><p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。</p><p>(A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。</p><p>使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。</p><h1 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3.网络层"></a>3.网络层</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。</p><p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议 IGMP（Internet Group Management Protocol）</li></ul><h2 id="IP-数据报格式"><a href="#IP-数据报格式" class="headerlink" title="IP 数据报格式"></a>IP 数据报格式</h2><p><img src="/2019/03/11/网络概述/ip.jpg" alt="ip"></p><ul><li>版本 : 有 4（IPv4）和 6（IPv6）两个值；</li><li>首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li><li>区分服务 : 用来获得更好的服务，一般情况下不使用。</li><li>总长度 : 包括首部长度和数据部分长度。</li><li>生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li><li>协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li><li>首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li><li>标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li><li>片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li></ul><h2 id="IP-地址编址方式"><a href="#IP-地址编址方式" class="headerlink" title="IP 地址编址方式"></a>IP 地址编址方式</h2><p>IP 地址的编址方式经历了三个历史阶段：</p><ul><li>分类</li><li>子网划分</li><li>无分类</li><li></li></ul><ol><li>分类<br>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</li></ol><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p><ol start="2"><li>子网划分<br>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</li></ol><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p><p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p><p>注意，外部网络看不到子网的存在。</p><ol start="3"><li>无分类<br>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</li></ol><p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p><p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p><p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p><p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。</p><p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p><h2 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议 ARP"></a>地址解析协议 ARP</h2><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p><p>ARP 实现由 IP 地址得到 MAC 地址。</p><p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p><p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p><h2 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h2><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p><p>ICMP 报文分为差错报告报文和询问报文。</p><ol><li><p>Ping<br>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。<br>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p></li><li><p>Traceroute<br>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。<br>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p><ul><li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li><li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li><li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ul></li></ol><h2 id="虚拟专用网-VPN"><a href="#虚拟专用网-VPN" class="headerlink" title="虚拟专用网 VPN"></a>虚拟专用网 VPN</h2><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p><p>有三个专用地址块：</p><p>10.0.0.0 ~ 10.255.255.255<br>172.16.0.0 ~ 172.31.255.255<br>192.168.0.0 ~ 192.168.255.255<br>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p><p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p><h2 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h2><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p><p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p><h2 id="路由器的结构"><a href="#路由器的结构" class="headerlink" title="路由器的结构"></a>路由器的结构</h2><p>路由器从功能上可以划分为：路由选择和分组转发。</p><p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p><h2 id="路由器分组转发流程"><a href="#路由器分组转发流程" class="headerlink" title="路由器分组转发流程"></a>路由器分组转发流程</h2><ul><li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li><li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li><li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li><li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li><li>报告转发分组出错。</li></ul><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p><p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p><p>可以把路由选择协议划分为两大类：</p><ul><li>自治系统内部的路由选择：RIP 和 OSPF</li><li>自治系统间的路由选择：BGP</li></ul><ol><li>内部网关协议 RIP<br>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</li></ol><p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p><p>距离向量算法：</p><pre><code>+ 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；+ 对修改后的 RIP 报文中的每一个项目，进行以下步骤：    + 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；    + 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。+ 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</code></pre><p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p><ol start="2"><li>内部网关协议 OSPF<br>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</li></ol><p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p><p>OSPF 具有以下特点：</p><ul><li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li><li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li><li>只有当链路状态发生变化时，路由器才会发送信息。</li></ul><p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p><ol start="3"><li>外部网关协议 BGP<br>BGP（Border Gateway Protocol，边界网关协议）</li></ol><p>AS 之间的路由选择很困难，主要是由于：</p><ul><li>互联网规模很大；</li><li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li><li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。<br>BGP 只能寻找一条比较好的路由，而不是最佳路由。</li></ul><p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p><h1 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4.传输层"></a>4.传输层</h1><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p><h2 id="UDP-和-TCP-的特点-bigstar"><a href="#UDP-和-TCP-的特点-bigstar" class="headerlink" title="UDP 和 TCP 的特点$\bigstar$"></a>UDP 和 TCP 的特点$\bigstar$</h2><ul><li><p>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p></li><li><p>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p></li></ul><h2 id="UDP-首部格式"><a href="#UDP-首部格式" class="headerlink" title="UDP 首部格式"></a>UDP 首部格式</h2><p><img src="/2019/03/11/网络概述/UDP格式.jpg" alt="UDP格式"></p><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p><h2 id="TCP-首部格式"><a href="#TCP-首部格式" class="headerlink" title="TCP 首部格式"></a>TCP 首部格式</h2><p><img src="/2019/03/11/网络概述/TCP格式.png" alt="TCP格式"></p><ul><li><p>序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p></li><li><p>确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p></li><li><p>数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p></li><li><p>确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p></li><li><p>同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p></li><li><p>终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p></li><li><p>窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p></li></ul><h2 id="TCP-的三次握手-bigstar"><a href="#TCP-的三次握手-bigstar" class="headerlink" title="TCP 的三次握手$\bigstar$"></a>TCP 的三次握手$\bigstar$</h2><p><img src="/2019/03/11/网络概述/TCP三次握手.png" alt="TCP三次握手"></p><p>假设 A 为客户端，B 为服务器端。</p><ul><li><p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p></li><li><p>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</p></li><li><p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</p></li><li><p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p></li><li><p>B 收到 A 的确认后，连接建立。</p></li></ul><p>三次握手的原因</p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><h2 id="TCP-的四次挥手-bigstar"><a href="#TCP-的四次挥手-bigstar" class="headerlink" title="TCP 的四次挥手$\bigstar$"></a>TCP 的四次挥手$\bigstar$</h2><p><img src="/2019/03/11/网络概述/TCP四次挥手.jpg" alt="TCP四次挥手"></p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li><p>A 发送连接释放报文，FIN=1。</p></li><li><p>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</p></li><li><p>当 B 不再需要连接时，发送连接释放报文，FIN=1。</p></li><li><p>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</p></li><li><p>B 收到 A 的确认后释放连接。</p></li></ul><h3 id="四次挥手的原因-bigstar"><a href="#四次挥手的原因-bigstar" class="headerlink" title="四次挥手的原因$\bigstar$"></a>四次挥手的原因$\bigstar$</h3><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><h3 id="TIME-WAIT-bigstar"><a href="#TIME-WAIT-bigstar" class="headerlink" title="TIME_WAIT$\bigstar$"></a>TIME_WAIT$\bigstar$</h3><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><p>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</p><p>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p><h2 id="TCP-可靠传输"><a href="#TCP-可靠传输" class="headerlink" title="TCP 可靠传输"></a>TCP 可靠传输</h2><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p><p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p><p>$$ RTTs=(1-a)<em>(RTTs)+a</em>RTT$$</p><p>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。</p><p>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：</p><p>$$ RTO=RTTs+4*RTT_d$$</p><p>其中 RTTd 为偏差的加权平均值。</p><h2 id="TCP-滑动窗口-bigstar"><a href="#TCP-滑动窗口-bigstar" class="headerlink" title="TCP 滑动窗口$\bigstar$"></a>TCP 滑动窗口$\bigstar$</h2><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><p><img src="/2019/03/11/网络概述/滑动窗口.jpg" alt="滑动窗口"></p><h2 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h2><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p><p><img src="/2019/03/11/网络概述/阻塞控制.jpg" alt="阻塞控制"></p><p>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p><p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p><p>为了便于讨论，做如下假设：</p><ul><li>接收方有足够大的接收缓存，因此不会发生流量控制；</li><li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li></ul><p><img src="/2019/03/11/网络概述/TCP拥塞变化.png" alt="TCP拥塞变化"></p><ol><li>慢开始与拥塞避免<br>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</li></ol><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p><ol start="2"><li>快重传与快恢复<br>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</li></ol><p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p><p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p><h1 id="5-应用层"><a href="#5-应用层" class="headerlink" title="5.应用层"></a>5.应用层</h1><h2 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h2><p>DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p><p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p><p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传来保证可靠性。在两种情况下会使用 TCP 进行传输：</p><p>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。<br>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</p><h2 id="文件传送协议"><a href="#文件传送协议" class="headerlink" title="文件传送协议"></a>文件传送协议</h2><p>FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：</p><p>控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。<br>数据连接：用来传送一个文件数据。<br>根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</p><p>主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</p><p>被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</p><p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p><h2 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h2><p>DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。</p><p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p><p>DHCP 工作过程如下：</p><ul><li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li><li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li><li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li><li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li></ul><h2 id="远程登录协议"><a href="#远程登录协议" class="headerlink" title="远程登录协议"></a>远程登录协议</h2><p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</p><p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p><h2 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h2><p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。</p><p>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p><ol><li><p>SMTP<br>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p></li><li><p>POP3<br>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。</p></li><li><p>IMAP<br>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p></li></ol><h2 id="常用端口"><a href="#常用端口" class="headerlink" title="常用端口"></a>常用端口</h2><table><thead><tr><th style="text-align:center">应用</th><th style="text-align:center">应用层协议</th><th style="text-align:center">端口号</th><th style="text-align:center">传输层协议</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">域名解析</td><td style="text-align:center">DNS</td><td style="text-align:center">53</td><td style="text-align:center">UDP/TCP</td><td style="text-align:center">长度超过 512 字节时使用 TCP</td></tr><tr><td style="text-align:center">动态主机配置协议</td><td style="text-align:center">DHCP</td><td style="text-align:center">67/68</td><td style="text-align:center">UDP    </td></tr><tr><td style="text-align:center">简单网络管理协议</td><td style="text-align:center">SNMP</td><td style="text-align:center">161/162</td><td style="text-align:center">UDP    </td></tr><tr><td style="text-align:center">文件传送协议</td><td style="text-align:center">FTP</td><td style="text-align:center">20/21</td><td style="text-align:center">TCP</td><td style="text-align:center">控制连接 21，数据连接 20</td></tr><tr><td style="text-align:center">远程终端协议</td><td style="text-align:center">TELNET</td><td style="text-align:center">23</td><td style="text-align:center">TCP    </td></tr><tr><td style="text-align:center">超文本传送协议</td><td style="text-align:center">HTTP</td><td style="text-align:center">80</td><td style="text-align:center">TCP    </td></tr><tr><td style="text-align:center">简单邮件传送协议</td><td style="text-align:center">SMTP</td><td style="text-align:center">25</td><td style="text-align:center">TCP    </td></tr><tr><td style="text-align:center">邮件读取协议</td><td style="text-align:center">POP3</td><td style="text-align:center">110</td><td style="text-align:center">TCP    </td></tr><tr><td style="text-align:center">网际报文存取协议</td><td style="text-align:center">IMAP</td><td style="text-align:center">143</td><td style="text-align:center">TCP    </td></tr></tbody></table><h2 id="Web-页面请求过程"><a href="#Web-页面请求过程" class="headerlink" title="Web 页面请求过程"></a>Web 页面请求过程</h2><ol><li>DHCP 配置主机信息</li></ol><p>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</p><p>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</p><p>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</p><p>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FFFFFFFFFF:FF，将广播到与交换机连接的所有设备。</p><p>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</p><p>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</p><p>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</p><ol start="2"><li>ARP 解析 MAC 地址</li></ol><p>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</p><p>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</p><p>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</p><p>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</p><p>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</p><p>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FFFFFFFFFF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</p><p>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</p><ol start="3"><li>DNS 解析域名</li></ol><p>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</p><p>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</p><p>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</p><p>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</p><p>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</p><ol start="4"><li>HTTP 请求页面</li></ol><p>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</p><p>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</p><p>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</p><p>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</p><p>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</p><p>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机网络概述&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;ISP&quot;&gt;&lt;a href=&quot;#ISP&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>why</title>
    <link href="http://yoursite.com/2019/03/07/why/"/>
    <id>http://yoursite.com/2019/03/07/why/</id>
    <published>2019-03-07T13:55:08.000Z</published>
    <updated>2019-03-07T14:02:08.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于我为什么写这个博客"><a href="#关于我为什么写这个博客" class="headerlink" title="关于我为什么写这个博客"></a>关于我为什么写这个博客</h1><p>一直以来的学习太宽泛了，啥都学啥都不会，临近找工作时发现自己的专业技能深度还不够，写这个博客一方面是为了记录学习过程，一方面是经营博客的新奇感，还有就是为了养成良好的学习习惯。先给自己立一个一年内不荒废的毒誓吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于我为什么写这个博客&quot;&gt;&lt;a href=&quot;#关于我为什么写这个博客&quot; class=&quot;headerlink&quot; title=&quot;关于我为什么写这个博客&quot;&gt;&lt;/a&gt;关于我为什么写这个博客&lt;/h1&gt;&lt;p&gt;一直以来的学习太宽泛了，啥都学啥都不会，临近找工作时发现自己的专业技
      
    
    </summary>
    
    
      <category term="碎碎念" scheme="http://yoursite.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式系统开发技术摘要</title>
    <link href="http://yoursite.com/2019/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/"/>
    <id>http://yoursite.com/2019/03/06/计算机三级/</id>
    <published>2019-03-06T08:44:47.000Z</published>
    <updated>2019-03-06T11:47:51.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="嵌入式系统开发技术"><a href="#嵌入式系统开发技术" class="headerlink" title="嵌入式系统开发技术"></a>嵌入式系统开发技术</h1><p>前言：写来给计算机三级整理用的，虽然意义不是很大。</p><h2 id="TOC"><a href="#TOC" class="headerlink" title="[TOC]"></a>[TOC]</h2><h2 id="第一章：嵌入式系统概论"><a href="#第一章：嵌入式系统概论" class="headerlink" title="第一章：嵌入式系统概论"></a>第一章：嵌入式系统概论</h2><h2 id="1-1嵌入式系统及其应用"><a href="#1-1嵌入式系统及其应用" class="headerlink" title="1.1嵌入式系统及其应用"></a>1.1嵌入式系统及其应用</h2><h3 id="1-1-1嵌入式系统"><a href="#1-1-1嵌入式系统" class="headerlink" title="1.1.1嵌入式系统"></a>1.1.1嵌入式系统</h3><p>  嵌入式计算机系统的简称，广泛应用于各个领域，它几乎无处不在。<br>  概念：嵌入式系统是以应用为中心，以计算机技术为基础，软硬件可裁剪，适应应用系统对功能、可靠性、成本、体积、功耗等多种约束的专用计算机系统。 </p><p>特点：</p><ol><li>专用性：  具体应用紧密结合，目标明确，很强的专用性。例如采集环境温度</li><li>隐蔽性：  例如：ATM机，数码相机等</li><li>资源受限：通常要求系统小型化、轻量化、低功耗、低成本等</li><li>高可靠性：例如汽车、数控机床等</li><li>实时性：  报警领域</li><li>软件固化：程序固化在ROM中，用户不能随便修改。</li></ol><p>应用领域:</p><ul><li>消费类：冰箱、洗衣机、空调、数码相机、游戏机等</li><li>产业类：数控机床、汽车、飞机、监护仪等</li><li>业务类：电话机、打印机、POS机、路由器、手机等</li><li><p>军用类：火炮、导弹等军用电子设备</p><p>嵌入式系统在应用数量上远远超过了各种类型的通用计算机系统。</p></li></ul><h3 id="1-1-2嵌入式系统组成及分类"><a href="#1-1-2嵌入式系统组成及分类" class="headerlink" title="1.1.2嵌入式系统组成及分类"></a>1.1.2嵌入式系统组成及分类</h3><p>逻辑组成：<br><strong>硬件：</strong></p><ul><li>处理器：采用微米级（深亚微米级至纳米级）半导体加工工艺。<br>CPU：中央处理器[4/8/16/32位字长，使用最多8/16位，32/64位是技术发展主流]<br>DSP：数字信号处理器<br>决定嵌入式系统性能的参数：<strong>主频、指令系统、缓存、逻辑结构</strong></li><li>存储器：     <ul><li>易失性存储器 RAM: DRAM存放正在运行的程序/数据，<br>SRAM 存储速度快，高速缓存使用</li><li>非易失性存储器 ROM：Flash ROM NOR Flash 字节为单位存储<br>NAND Flash 页为单位存储</li></ul></li><li>I/O设备与I/O接口: <ul><li>人机交互：按键、LED、触摸板、</li><li>机机交互：各种传感器和伺服执行机构</li><li>VGA：视频图像阵列</li><li>HDMI：高清晰度多媒体接口</li><li>DVI：数字视频接口</li><li>CAN：控制器局域网</li></ul></li><li>数据总线: Data Bus，简称总线；数据线和控制电路组成</li></ul><p><strong>软件：</strong></p><p>安卓Android为例:</p><ul><li>最底层：各种驱动程序和Linux内核</li><li>第二层：系统库和Android运行环境</li><li>第三层：应用软件框架</li><li>第四层：应用程序</li><li>BSP：板级支持包</li></ul><p>嵌入式处理芯片<br>特点：支持实时处理、低功耗、结构可扩展、集成测试电路</p><p>目前嵌入式处理芯片有4种产品类型：</p><ol><li>微处理器</li><li>数字信号处理器DSP：哈佛结构、SIMD</li><li>微控制器</li><li>片上系统Soc</li></ol><p>嵌入式系统的分类与发展</p><ul><li>用途:    军用、工业用、民用</li><li>实时性:    非实时系统、软实时系统、硬实时系统</li><li>产品形态:   系统级：PC104模块 板级：带CPU的主板</li><li>片级：单片机、微处理器、DSP、Soc</li><li>系统复杂程度:     低端系统、中端系统、高端系统</li><li>发展:     1/4/8/16/32/64 位</li></ul><p>应用系统举例:数码相机</p><h3 id="1-1-3-Soc芯片"><a href="#1-1-3-Soc芯片" class="headerlink" title="1.1.3  Soc芯片"></a>1.1.3  Soc芯片</h3><p>微电子技术    </p><ul><li>核心：半导体集成电路</li><li>分类：小规模、中规模、大规模、超大规模、及大规模</li><li>摩尔定律：单块集成电路的集成度平均每18-24个月翻一番</li></ul><p>通用Soc和专用Soc：</p><ul><li><strong>通用Soc芯片</strong>：半导体企业通过自主开发处理器内核或购买其他企业的处理器内核的IP授权，按照目标应用领域功能要求所开发的SoC芯片系列。</li><li><strong>专用SoC芯片</strong>：嵌入式系统开发商依据待开发产品的特殊要求，向半导体企业定制的SoC芯片。</li></ul><p>Soc芯片开发流程:  主要工作是借助EDA(电子设计自动化)工具完成。<br>1、总体设计2、逻辑设计3、综合与仿真4、芯片制造</p><p>IP核及其复用   :   </p><ul><li>IP：（Intellectual Property）知识产权</li><li>分类：<strong>固核、软核、硬核</strong></li><li>IP复用：减少研发成本、缩短研发时间、实现快速设计、尽早投放市场的有效途径。</li></ul><h2 id="1-2嵌入式系统与数字媒体"><a href="#1-2嵌入式系统与数字媒体" class="headerlink" title="1.2嵌入式系统与数字媒体"></a>1.2嵌入式系统与数字媒体</h2><h3 id="1-2-1数字文本-Text"><a href="#1-2-1数字文本-Text" class="headerlink" title="1.2.1数字文本(Text)"></a>1.2.1数字文本(Text)</h3><p>字符集及编码：   </p><ol><li>西文字符：ASCII字符集：128个字符+96个可打印字符+32个控制字符【7个2进制进行编码】</li><li>汉字编码：</li></ol><ul><li>GB2312:包含汉字和拉丁字母、俄文、日文、希腊字母和汉语拼音等【十六个2进制进制标识】</li><li>GB18030：和国际标准的UCS/Unicode字符集基本兼容</li></ul><ol start="3"><li>UCS/Unicode：</li></ol><ul><li>UTF-8 : 采用单字节可变长编码。</li><li>UTF-16: 采用双字节可变长编码。</li></ul><p>文本类型：数字文本也称电子文本或文本                </p><ol><li>：简单文本，纯文本，后缀名为.txt                </li><li>：丰富文本，PDF、.doc等格式                </li><li>：超文本，【超链接】</li></ol><p>文本制作和展现: 字符的形状有两种描述方法：          </p><ul><li>点阵法，描述字符离散点阵中笔画的占位信息          </li><li>轮廓法，描述字符的轮廓</li></ul><h3 id="1-2-2-数字图像"><a href="#1-2-2-数字图像" class="headerlink" title="1.2.2 数字图像"></a>1.2.2 数字图像</h3><p>数字图像获取及主要参数</p><p>获取方法：数码相机和扫描仪<br><strong>获取步骤：扫描–&gt;分色–&gt;取样–&gt;量化</strong><br>参数： 图像大小、位平面数目(像素颜色分量数目)、像素深度、颜色模型</p><p>常用格式及应用<br>  <strong>图像数据量(单位：字节)=图像水平分辨率×图像垂直分辨率×像素深度/8</strong>  </p><p>常用格式：</p><ul><li>BMP：Windows应用程序            </li><li>GIF：互联网，颜色数目不超过256色，文件小，适合互联网传输。</li><li>JPEG：互联网、数码相机【有损】，静止图像数据压缩编码的国际标准           </li><li>PNG：互联网、桌面出版            </li><li>TIF：桌面出版</li></ul><h3 id="1-2-3-数字音频及视频"><a href="#1-2-3-数字音频及视频" class="headerlink" title="1.2.3 数字音频及视频"></a>1.2.3 数字音频及视频</h3><p>音频视频的数字化<br>音频：</p><ul><li>音频频率范围：20Hz-20kHz的模拟信号。</li><li>语音信号范围：300-3400Hz，电话取样频率为8kHz，音乐为全频，取样频率为40kHz。</li></ul><p>音频数字化步骤：<strong>取样–&gt;量化–&gt;编码</strong>。<br><strong>数字信号码率(单位：b/s)=取样频率×量化位数×声道数/压缩比</strong></p><p>编码类型：</p><ul><li>未压缩  ：WAV </li><li>无损压缩：FLAC、APE、M4A </li><li>有损压缩：MP3、WMA、AC3、AAC<br>视频：压缩编码标准：</li><li>MPEG-1： VCD、数码相机、数字摄像机 </li><li>H.261 </li><li>MPEG-2： 用途最广，DVD，数字卫星电视、数字有线电视 </li><li>MPEG-2   High Profile </li><li>MPEG-4   ASP </li><li>MPEG-4 AVC：最新应用最多的标准</li></ul><h2 id="1-3数字通讯与计算机网络"><a href="#1-3数字通讯与计算机网络" class="headerlink" title="1.3数字通讯与计算机网络"></a>1.3数字通讯与计算机网络</h2><h3 id="1-3-1数字通讯"><a href="#1-3-1数字通讯" class="headerlink" title="1.3.1数字通讯"></a>1.3.1数字通讯</h3><p>模拟/数字通讯</p><ul><li>模拟信号：连续变化的物理量(如电平的幅度或电流的强度)来表示，信号容易受到干扰，传输不稳定。</li><li>数字信号：用高低电平来表示电流的大小，抗干扰能力强，差错可控制。</li></ul><p>有线/无线通讯</p><ul><li>有线通讯：传输介质通常为金属导体或者光导纤维。双绞线、同轴电缆、光缆 。</li><li>无线通讯：不需要物理连接，通过电磁波在自由空间的传播来传输信息。</li></ul><p>无线电波按照频率/波长分为<strong>中波、短波、超短波、微波</strong>。</p><ul><li>中波：沿地面传播，绕射能力强，适合广播和海上通讯 </li><li>短波：较强的电离层反射能力，适合环球通讯。 </li><li>超短波/微波：绕射能力弱，适用于视距或超视距中继通讯 </li><li>微波：300MHz-300GHz，微波中继距离在50km，典型代表：手机。</li></ul><blockquote><ul><li>第1代个人移动通讯：模拟传输技术。</li><li>第2代个人移动通讯：数字通讯，频段900MHZ-1800MHz，使用GSM和CDMA，俗称全球移动通讯系统，简称2G。</li><li>第3代个人移动通讯：使用频段1885-2025MHz，2110-2200MHz，传输速率几个Mb/s,中国移动自主研发TD-SCDMA，中国电信CDMA2000,中国联通WCDMA，不同标准的网络互通，但终端设备（手机）不兼容。</li><li>第4代个人移动通讯; 传输速率100Mb/s,中国移动TD-LTE,兼容3G(TD-SDMA)和2G(GSM)，中国联通和电信采用FDD-LTE,终端设备采用多模工作方式，兼容之前的3G和2G网络。</li></ul></blockquote><p>数字通讯传输技术</p><ul><li>调制与解调技术</li><li>多路复用技术 <ul><li>时分多路复用TDM</li><li>频分多路复用FDM</li><li>波分多路复用WDM</li></ul></li><li>交换技术  分组交换技术</li></ul><h3 id="1-3-2-计算机网络"><a href="#1-3-2-计算机网络" class="headerlink" title="1.3.2 计算机网络"></a>1.3.2 计算机网络</h3><p>网络组成：</p><ul><li>计算机等智能电子设备终端</li><li>数据通讯链路</li><li>通讯协议</li><li>网络软件</li></ul><p>网络类型：</p><ul><li>局域网LAN</li><li>城域网MAN</li><li>广域网WAN</li></ul><p>以太局域网：</p><ul><li>传输方式：分组交换技术，</li><li>格式为：发送设备MAC地址，接收设备MAC地址，控制信息，有效载荷，信息校验</li><li>MAC地址：全球唯一，48个二进制组成。</li></ul><p>无线局域网：无线电波进行数据传输，分为2.4GHz和5.8GHz两个频段<br>协议：</p><ul><li>IEEE802.11，俗称WiFi.       </li><li>IEEE802.11b（2.4GHz频段），传输速率11Mbps        </li><li>IEEE802.11a（5.8GHz频段）</li><li>IEEE802.11g（2.4GHz频段） 传输速率54Mbps    </li><li>IEEE802.11n                传输速率108Mbps    </li><li>IEEE802.11ac               传输速率1000Mbps    </li><li>无线接入点（WAP或AP）。</li><li>蓝牙Bluetooth 瑞典爱立信公司提出，无线协议IEEE802.15.</li></ul><h3 id="1-3-3-互联网"><a href="#1-3-3-互联网" class="headerlink" title="1.3.3 互联网"></a>1.3.3 互联网</h3><p>IP协议和路由器<br>IP协议：</p><ul><li>IPv4协议中，每个IP地址使用32个二进制表示。 </li><li>IPv6协议中，每个IP地址使用128个二进制表示。</li><li>IP协议分为A,B,C三个基本类 </li></ul><p>IP数据报：头部和数据区。<br>路由器：选择路由和转发IP数据报。</p><p>互联网及其组成<br>互联网的接入: </p><ol><li>ADSL接入 </li><li>有线电视网接入 </li><li>光纤接入网 </li><li>无线接入：无线局域网接入、GPRS移动电话网接入、3G移动电话网接入、4G移动电话网接入</li></ol><h2 id="第二章：嵌入式处理器"><a href="#第二章：嵌入式处理器" class="headerlink" title="第二章：嵌入式处理器"></a>第二章：嵌入式处理器</h2><h2 id="2-1处理器概述"><a href="#2-1处理器概述" class="headerlink" title="2.1处理器概述"></a>2.1处理器概述</h2><h3 id="2-1-1嵌入式处理器结构类型"><a href="#2-1-1嵌入式处理器结构类型" class="headerlink" title="2.1.1嵌入式处理器结构类型"></a>2.1.1嵌入式处理器结构类型</h3><p>指令集：</p><ul><li>复杂指令集结构<strong>CISC</strong>(Complex Instruction Set Computer)</li><li>精简指令集结构<strong>RISC</strong>(Reduced Instruction Set Computer)</li></ul><p>存储机制：</p><ul><li>冯·诺依曼von Neumann：数据和程序代码存放在一起</li><li>哈佛结构Harvard：数据和程序代码分开存储</li></ul><p>字长：8位、16位、32位、64位</p><p>内核系列：51、AVR、PIC、MSP430、MIPS、PowerPC、MC68K、ColdFire、ARM</p><h3 id="2-1-2嵌入式处理器简介"><a href="#2-1-2嵌入式处理器简介" class="headerlink" title="2.1.2嵌入式处理器简介"></a>2.1.2嵌入式处理器简介</h3><p>  51、AVR、PIC、MPS430、MIPS、PowerPC、MC68K、ColdFire、ARM等内核</p><h3 id="2-1-3-ARM处理器概述"><a href="#2-1-3-ARM处理器概述" class="headerlink" title="2.1.3 ARM处理器概述"></a>2.1.3 ARM处理器概述</h3><p>ARM处理器特点</p><ol><li>单周期操作</li><li>只使用加载/存储指令访问内存</li><li>指令长度固定</li><li>三地址指令格式</li><li>指令流水线技术</li><li>低功耗设计</li></ol><p>ARM处理器架构发展</p><ul><li>ARMv1  1985    </li><li>ARMv2  1987    </li><li>ARMv3  1992 </li><li>ARMv4/ARMv4T  1996    S3C2410 </li><li>ARMv5  1999    ARMv5TE  1999    ARMv5TEJ  1999 </li><li>ARMv6  2001 ARMv7M  2004 ARMv6M  2004 </li><li>ARMv7R  2004    Coetex-R4/R5/R7 </li><li>ARMv7A  2004    Coetex-A5/A7/A8/    A9/A15/A17 </li><li>ARMv8A  2011    Coetex-A53/A57</li></ul><p>ARM指令集比较</p><ul><li>Thumb-2指令集：混合指令集，既有16位指令也有32位指令</li><li>Thumb指令集：全部为16位指令</li><li>ARM指令集：全部为32位指令</li></ul><h2 id="2-2-ARM典型处理器介绍"><a href="#2-2-ARM典型处理器介绍" class="headerlink" title="2.2 ARM典型处理器介绍"></a>2.2 ARM典型处理器介绍</h2><p>经典ARM处理器：ARM7、ARM9、ARM11(ARMv4T、ARMv5TE、ARMv6架构)</p><p>ARM Cortex嵌入处理器：<strong>ARM Cortex-M</strong>系列Cortex-M0/M0+/M1/M3/M4，<strong>成本和功耗敏感低端处理器</strong></p><p>ARM Cortex<strong>实时</strong>处理器：<strong>ARM Cortex-R</strong>系列包括Cortex-R4/R5/R7,<strong>中档处理器</strong></p><p>ARM Cortex<strong>应用</strong>处理器：<strong>ARM Cortex-A</strong>系列包括Cortex-A17/A15/A12/A9/A8/A7/A5，<strong>高端处理器</strong></p><p>ARM专家处理器：SC100、SC300</p><h2 id="2-3-ARM处理器体系结构"><a href="#2-3-ARM处理器体系结构" class="headerlink" title="2.3 ARM处理器体系结构"></a>2.3 ARM处理器体系结构</h2><h3 id="2-3-1-ARM处理器工作状态和模式"><a href="#2-3-1-ARM处理器工作状态和模式" class="headerlink" title="2.3.1 ARM处理器工作状态和模式"></a>2.3.1 ARM处理器工作状态和模式</h3><p>工作状态：ARM和Thumb之间的切换 :<br>指令BX    </p><ul><li>ARM到Thumb：R[0]=1;    BX R0             </li><li>Thumb到ARM：R[0]=0;    BX R0</li></ul><ol><li>ARM状态：          ARM处理器复位后总是处于ARM状态</li><li>Thumb/Thumb-2状态：（Cortex-M处理器只有Thumb-2状态和调试状态）</li><li>调试状态</li></ol><p>工作模式CPSR:[M4:M0]（Cortex除外）</p><ul><li><strong>用户模式User [10000]</strong></li><li><strong>快速中断模式FIQ [10001]</strong></li><li><strong>外部中断模式IRQ [10010]</strong></li><li><strong>管理模式SVC [10011]</strong></li><li><strong>中止模式ABT [10111]</strong></li><li><strong>系统模式SYS [11111]</strong></li><li><strong>未定义指令模式UND [11011]</strong></li></ul><h3 id="2-3-2-ARM处理器的寄存器组织"><a href="#2-3-2-ARM处理器的寄存器组织" class="headerlink" title="2.3.2 ARM处理器的寄存器组织"></a>2.3.2 ARM处理器的寄存器组织</h3><p>ARM状态下寄存器组织</p><ul><li>ARM处理器共37个寄存器：31个通用寄存器和6个状态寄存器</li><li>R15：  程序计数器（PC） </li><li><strong>CPSR</strong>： 当前程序状态寄存器 </li><li>R7~R0：通用寄存器</li></ul><p>状态寄存器：当前程序状态寄存器CPSR和备份程序状态寄存器SPSR </p><ul><li>N：符号标志，N=1运算结果为负数 </li><li>Z：全0标志，Z=1运算结果为0 </li><li>C：进位、借位标志，C=1，加法有进位，减法无借位 </li><li>V：溢出标志，V=1,加减法运算结果有溢出 </li><li>Q：增强的DSP运算指令溢出标志，Q=1，有溢出 </li><li>I：外部中断控制位，I=1，禁止外部IRQ中断 </li><li>F：快速中断控制位，F=1，禁止FIQ中断 </li><li>T：ARM与Thumb指令切换，T=1，Thumb指令 </li><li>M4~M0：模式选择位</li></ul><p>CPSR状态寄存器分为4个域：标志域F(31:24)、状态域S(23:16)、扩展域X(15:8)、控制域(7:0)，单个字节可以单独操作域而不影响其他位。</p><p>Thumb状态下寄存器组织：在Thumb状态下R8-R12下不可见<br>带MMU的ARM处理器中的控制寄存器（略过）</p><h3 id="2-3-3-ARM处理器的异常"><a href="#2-3-3-ARM处理器的异常" class="headerlink" title="2.3.3 ARM处理器的异常"></a>2.3.3 ARM处理器的异常</h3><p>ARM异常种类、异常向量表和优先级<br>异常类型|优先级|工作模式<br>:————-:|:——–:|:———:<br>复位RESET |1 | 管理模式<br>未定义UND| 6|中止模式<br>软件中断SWI|6|管理模式<br>指令预取中止PABT|5|中止模式<br>数据访问中止DABT|2 |中止模式<br>外部中断请求IRQ|4|外部中断模式<br>快速中断请求FIQ|3|快速中断模式</p><p>异常中断响应过程<br>异常处理程序返回</p><h3 id="2-3-4-存储器格式和数据类型"><a href="#2-3-4-存储器格式和数据类型" class="headerlink" title="2.3.4 存储器格式和数据类型"></a>2.3.4 存储器格式和数据类型</h3><p>存储字格式：<strong>大端模式</strong><br>32位数据字的高字节存储在低地址中，而数据字的低字节存放在高地址中。<br>例如：0x12345678存放的起始地址为0x30001000，<br>大端模式下，</p><blockquote><p>0x30001000单元存放0x12；<br>0x30001001单元存放0x34；<br>0x30001002单元存放0x56；<br>0x30001003单元存放0x78；</p></blockquote><p><strong>小端模式</strong><br>32位数据字的高字节存储在高地址中，而数据字的低字节存放在低地址中。<br>例如：0x12345678存放的起始地址为0x30001000，<br>小端模式下，</p><blockquote><p>0x30001000单元存放0x78；<br>0x30001001单元存放0x56；<br>0x30001002单元存放0x34；<br>0x30001003单元存放0x12；</p></blockquote><p><strong>与大端模式存放数据完全不同。系统复位时一般自动默认为小端模式</strong>。</p><p>数据类型：32位ARM处理器支持字节（8位）、半字（16位）、字（32位）3种数据类型。字需要4字节对齐，半字需要2字节对齐。<br>ARM指令固定长度32位指令，<strong>且字对齐</strong>。<br>Thumb指令长度16位指令，且2<strong>字节字对齐</strong>。</p><h3 id="2-3-5-MMU和MPU"><a href="#2-3-5-MMU和MPU" class="headerlink" title="2.3.5 MMU和MPU"></a>2.3.5 MMU和MPU</h3><p>MMU虚拟存储器技术：通过地址映射，使需要运行在连续地址空间的软件可以运行在不连续的物理存储空间，需要较大存储空间的软件可以运行在较小容量的物理存储器中。</p><p>MMU：存储器管理单元，高性能处理器所必须的重要部件之一<br>MMU的功能：①虚拟地址到物理地址映射、②存储器访问权限控制。<br>MPU：存储器保护单元</p><h2 id="2-4-ARM处理器指令集"><a href="#2-4-ARM处理器指令集" class="headerlink" title="2.4 ARM处理器指令集"></a>2.4 ARM处理器指令集</h2><h3 id="2-4-1-ARM指令分类和格式"><a href="#2-4-1-ARM指令分类和格式" class="headerlink" title="2.4.1 ARM指令分类和格式"></a>2.4.1 ARM指令分类和格式</h3><p>ARM指令分类：</p><ol><li>分支指令 </li><li>数据处理指令 </li><li>程序状态寄存器处理指令 </li><li>加载/存储指令 </li><li>协处理器指令 </li><li>异常指令</li></ol><p>ARM指令格式<br>ARM状态下寄存器组织</p><p>\<opcode> {\<cond>} {S}   \<rd> , \<rn> {,\<op2>}    </op2></rn></rd></cond></opcode></p><p>\&lt;&gt;不可省略<br>{}可省略<br>\<opcode>        指令操作码        [31:28]<br>{cond}            条件域                【可省略】<br>{S}            指令执行是否更新CPSR    【可省略】<br>Rd                目的寄存器<br>Rn                第一个源操作数<br>op2                第二个源操作数<br>opcode，cond与S之间没有分隔符<br>{S}和Rd之间用空格隔开。</opcode></p><p>imm8m：</p><ul><li>ARM指令集：imm8m表示一个由8位立即数经循环右移任意偶数位次形成的32位操作数</li><li>Thumb指令集：imm8m表示一个由8位立即数经左移任意位次形成的32位操作数</li></ul><p>ARM指令中操作数符号</p><ol><li>‘#’–立即数符号，后面是十进制或十六进制数 </li><li>‘0x’–十六进制符号，后面的数据表示十六进制 </li><li>‘！’–更新基址寄存器符号，表示指令完成操作后最后的地址应该写入的基址寄存器 </li><li>‘^’–复制SPSR到CPSR符号 </li><li>’-‘–寄存器列表范围 R7-R0；</li></ol><p>移位操作符</p><ol><li>逻辑左移    LSL </li><li>算数左移    ASL </li><li>逻辑右移    LSR </li><li>算数右移    ASR </li><li>循环右移    ROR </li><li>带扩展的循环右移  RRX</li></ol><h3 id="2-4-2-ARM指令寻址方式："><a href="#2-4-2-ARM指令寻址方式：" class="headerlink" title="2.4.2 ARM指令寻址方式："></a>2.4.2 ARM指令寻址方式：</h3><ul><li>立即寻址</li><li>寄存器寻址</li><li>寄存器间接寻址</li><li>变址寻址</li><li>相对寻址</li><li>堆栈寻址</li><li>块拷贝寻址</li></ul><p>ARM指令集<br>Thumb指令集<br>ARM处理器伪指令</p><h3 id="2-5-ARM汇编语言程序设计"><a href="#2-5-ARM汇编语言程序设计" class="headerlink" title="2.5 ARM汇编语言程序设计"></a>2.5 ARM汇编语言程序设计</h3><p>ARM汇编器支持的伪指令<br>ARM汇编语言语句格式<br>汇编语言程序设计举例<br>C语言汇编语言混合编程</p><h2 id="第三章：嵌入式系统硬件组成"><a href="#第三章：嵌入式系统硬件组成" class="headerlink" title="第三章：嵌入式系统硬件组成"></a>第三章：嵌入式系统硬件组成</h2><h2 id="3-1-硬件组成概述"><a href="#3-1-硬件组成概述" class="headerlink" title="3.1 硬件组成概述"></a>3.1 硬件组成概述</h2><p>嵌入式系统由嵌入式硬件系统和嵌入式软件系统组成。 </p><ul><li>嵌入式硬件系统由嵌入式处理器、存储器、I/O接口等构件。 </li><li>嵌入式硬件系统可分为：嵌入式最小系统和典型嵌入式硬件系统、</li></ul><p>最小硬件系统：</p><ul><li>电源电路：<ul><li>交流变直流模块（AC-DC）</li><li>直流到直流模块（DC-DC）</li><li>低压差稳压器LDO（Low Dropout Regulator）</li></ul></li><li>时钟电路：<ul><li>为嵌入式处理器提供时钟信号 </li><li>晶振：有源晶振和无源晶振</li></ul></li><li>复位电路：<ul><li>嵌入式处理器有一个系统复位引脚nRESET或RESET，n表示低电平复位。 ARM复位后PC指针指向唯一的地址0x00000000，此处通常有一条无条件转移指令B RESET，转向RESET开始系统的初始化程序。</li></ul></li><li>JTAG测试接口：内部测试电路 JTAG(Joint Test Action Group)是一种国际标准测试协议。<br>SWD是Cortex-M内核提供的另外一种少引脚调试接口，串行线调试接口：SWD和SWCLK两根信号线；调试时也需要加上地线和复位信号线。</li></ul><p>ARM内核典型嵌入式应用系统硬件组成</p><p>典型的嵌入式应用系统硬件由以下几部分组成： </p><ol><li>嵌入式最小硬件系统： </li><li>前向通道：即<strong>输入接口</strong>，由模拟量输入接口（传感器、信号调整电路，<br>A/D转换器等）和数字量输入接口组成 </li><li>后向通道：即<strong>输出接口</strong>，由模拟输出接口（D/A转换器、功率放大器和<br>执行器等）和数字输出接口组成。 </li><li>人机交互通道：键盘、触摸屏输入接口以及LED或LCD输出显示接口 </li><li>相互互连通讯通道：RS-232/RS-485串行通信接口，CAN通信接口，以太<br>网通信接口、USB通信接口</li></ol><h2 id="3-2-嵌入式处理芯片"><a href="#3-2-嵌入式处理芯片" class="headerlink" title="3.2 嵌入式处理芯片"></a>3.2 嵌入式处理芯片</h2><h3 id="3-2-1-AMBA总线体系结构及标准"><a href="#3-2-1-AMBA总线体系结构及标准" class="headerlink" title="3.2.1 AMBA总线体系结构及标准"></a>3.2.1 AMBA总线体系结构及标准</h3><p>AMBA(Advanced Microcontroller Bus Architecture)：先进微控制器总线体系结构。 </p><ol><li>ARM公司公布的总线协议，用于连接和管理偏上系统中功能模块的开放标准和片上互联规范。 </li><li><strong>AMBA</strong>总线1995年推出AMBA1.0到2011年AMBA4.0共计4个版本，总线性能不断提升。 </li><li><strong>ASB**</strong>(Advanced System Bus)先进系统总线<strong> </strong>AHB<strong>(Advanced Hign-performance Bus)</strong>先进高性能总线**（ASB发展而来）主要用于连接高宽带快速组件。 </li><li><strong>APB(Advanced Peripheral Bus)先进外围总线</strong>，主要连接低带宽组件与外部相连的硬件组件。 <strong>系统组件通过桥接器（Bridge）与外围总线互联</strong>。</li></ol><h3 id="3-2-2-ARM内核嵌入式芯片的硬件组成"><a href="#3-2-2-ARM内核嵌入式芯片的硬件组成" class="headerlink" title="3.2.2 ARM内核嵌入式芯片的硬件组成"></a>3.2.2 ARM内核嵌入式芯片的硬件组成</h3><p><strong>AHB连接的高带宽组件包括</strong>：电源管理和时钟管理器、测试接口JTAG、外部存储器控制器接口、DMA控制器、USB主机、片上SRAM及FLASH、Etherent、高速GPIO中断控制器、LCD控制器等。<br><strong>APB连接的低速带宽组件包括</strong>：GPIO、UART、SPI、I2C、USB设备、CAN、ADC、DAC、WDT、Timer、RTC、PWM等。</p><ul><li>存储器与控制器：片内程序存储器通常是Flash ROM； 片内数据存储器通常是SRAM；</li><li>中断控制器： VIC：中断向量 NVIC：嵌套向量中断 处理中断两种形式：标准的中断控制器和向量中断控制器（VIC）</li><li>DMA控制器：（Direct Memory Access）：直接存储器访问控制器 使用它可以将数据块从外设传输至内存、从内存传输至外设或从内存传输至内存。 数据的传输过程中不需要CPU的参与，可以显著降低处理器的负荷，提高数据处理的效率。</li><li>电源管理与时钟管理器：ARM处理器内部电源管理主要有：<strong>正常工作模式、慢时钟模式、空闲模式、掉电模式、休眠模式、深度休眠模式</strong>等。 时钟控制器负责对时钟的分配，产生不同频率的定时时钟可供片内个组件作为同步时钟使用。</li><li>GPIO端口： (General Purpose Input Output)即通用输入/输出端口。 作为<strong>输入具有缓冲</strong>功能，而作为<strong>输出时则具有锁存</strong>功能。 有的引脚是双功能，也有三功能甚至四功能的引脚。</li><li>定时计数组件：包括：①WDT（Watchdog Timer）：看门狗定时器 ②Timer通用定时器，用于一般的定时 ③RTC：提供年月日时分秒 ④脉冲宽度调制器PWM（Pulse Width Modulation）：用于电机等控制</li><li>模拟通道组件：内部的模拟组件包括ADC和DAC： <ul><li>ADC：模拟到数字的转换器，可完成从模拟信号到数字信号的变换。它是一个模拟输入的组件。</li><li>DAC：数字到模拟的变换器，可完成从数字信号到模拟信号的变换，一般在后级还需要加功率放大才能接到实际应用系统中。</li></ul></li><li>互联通信组件：<ol><li>UART通用异步收发器（Universal Asynchronous Receiver/Transmitter)：标准的串行通信接口。字符格式按照地位在前、高位在后，1位起始位、5-8位数据位、1位奇偶校验位，1-2位停止位。 </li><li>I2C（Inter－Integrated Circuit）集成电路互联的一种总线标准。两根信号线，时钟线（SCL）和数据线（SDA） </li><li>I2S（Inter－Integrated Circuit Sound Bus）多媒体应用的音频串行总线 </li><li>SPI（Serial Peripheral Interface）是串行外设接口，它是一种同步串行外设接口，通常用四线制，包括MISO（主输入从输出）、MOSI（主输出从输入）、SSL（芯片选择）、SCK（时钟） </li><li>CAN(Controller Area Network)控制器局域网，仅有CANH和CANL两根信号线，采用差分传输方式，远距离1200m，抗干扰能力强，可组成多主多从系统。 </li><li>USB（Universal Serial Bus）通用串行总线，主要应用于与外部设备的短距离通信，采用查分信号传输数据，速度快，效率高。 </li><li>Ethernet是以太网通讯接口。</li></ol></li></ul><h3 id="3-2-3-常用ARM嵌入式处理芯片"><a href="#3-2-3-常用ARM嵌入式处理芯片" class="headerlink" title="3.2.3 常用ARM嵌入式处理芯片"></a>3.2.3 常用ARM嵌入式处理芯片</h3><ul><li>NXP的ARM芯片</li><li>TI的ARM芯片</li><li>Samsung的ARM芯片（基于ARM920T内核的S3C4xx系列）</li><li>Atmel的ARM芯片</li><li>ST的ARM芯片</li><li>Freescale的ARM芯片</li><li>Nuvoton的ARM芯片</li><li>Intel的ARM芯片</li><li>其他ARM芯片厂家</li></ul><h3 id="3-2-4-嵌入式处理芯片的选型"><a href="#3-2-4-嵌入式处理芯片的选型" class="headerlink" title="3.2.4  嵌入式处理芯片的选型"></a>3.2.4  嵌入式处理芯片的选型</h3><p>性价比原则：完全能够满足要求且略有余量的嵌入式处理器芯片<br>参数选择原则</p><h2 id="3-3-嵌入式系统存储器"><a href="#3-3-嵌入式系统存储器" class="headerlink" title="3.3 嵌入式系统存储器"></a>3.3 嵌入式系统存储器</h2><h3 id="3-3-1-层次结构："><a href="#3-3-1-层次结构：" class="headerlink" title="3.3.1 层次结构："></a>3.3.1 层次结构：</h3><p>缓存（Cache）技术，目前嵌入式系统采用SRAM作为Cache，分为一级Cache(L1)h和二级Cache(L2)</p><h3 id="3-3-2-分类：半导体存储器："><a href="#3-3-2-分类：半导体存储器：" class="headerlink" title="3.3.2 分类：半导体存储器："></a>3.3.2 分类：半导体存储器：</h3><p>RAM：</p><ul><li>SRAM:静态随机存取存储器（嵌入式内嵌的数据存储器）</li><li>DRAM:动态随机存取存储器（外部扩展的存储器）<br>ROM：</li><li>MROM:掩膜型只读存储器</li><li>PROM:一次可编程只读存储器</li><li>EPROM:紫外线可擦除可编程只读存储器</li><li>E2PROM:电可擦除可编程只读存储器</li><li>Flash:闪速存储器<ul><li><strong>NOR Flash ROM</strong>：以页（行）为单位随机存取，数据存储器使用</li><li><strong>NAND Flash ROM</strong>：以字节为单位随机存取</li></ul></li></ul><p>新型存储器:</p><ul><li><strong>FRAM:铁电</strong>随机存取存储器</li><li><strong>MRAM:磁性</strong>随机存取存储器</li></ul><h3 id="3-3-3性能指标"><a href="#3-3-3性能指标" class="headerlink" title="3.3.3性能指标"></a>3.3.3性能指标</h3><p>容量:<br>存储器容量是指每一个存储芯片或模块能够存储的二进制位数。 存储1位二进制位为最小单位（b）。<br>容量单位有字节（Byte，B）、千字节（Kilo-Byte，KB）、兆字节（Mega-Byte，MB）、吉字节（Giga-Byte，GB）、太字节（Tera-Byte，TB）。<br><strong>对内存而言</strong>：容量单位之间的相互关系为<strong>2^10=1024倍</strong>表示；<br><strong>对外存容量</strong>：容量单位之间的相互关系为<strong>10^3=1000倍</strong>表示； </p><p>存储器容量计算公式：</p><blockquote><p>V=2^m×n<br>V：存储器容量<br>m：地址线条数<br>n：数据线条数</p></blockquote><p>存取时间：从CPU给出有效的存储器地址开始到存储器读出数据（或者把数据写入存储器）所需要的时间。 </p><blockquote><p>1s=10^3ms=1000ms<br>1ms=10^3μs=1000μs<br>1μs=10^3ns=1000ns</p></blockquote><p>带宽:存储器带宽是指：每秒可以传输（读出/写入）的最大数据总量。单位：B/s、KB/s、MB/s、GB/s、<br>传输带宽与存储器<strong>总线的频率、数据位数（宽度）、总线周期的传输次数有关</strong>。<br>并行总线存储器带宽：</p><blockquote><p><strong>带宽=总线频率×数据宽度/8×传输次数/总线周期 （B/s）</strong></p></blockquote><p>例如：存储器频率333MHz，数据宽度32位，每周期传输1次，<br>则带宽为：333×32/8×1 B/s =1332MB/s<br>并行总线存储器带宽：</p><blockquote><p>带宽=总线频率×（1/10）（B/s）</p></blockquote><h3 id="3-3-4-片内存储器"><a href="#3-3-4-片内存储器" class="headerlink" title="3.3.4 片内存储器"></a>3.3.4 片内存储器</h3><ul><li>片内Cache： 容量几KB、几百KB或几MB，有一级Cache、二级Cache</li><li>片内Flash ROM：程序存储器</li><li>片内SRAM：  数据存储器（系统复位要对SRAM初始化）</li><li>片内E2PROM：做长期保存重要的数据</li><li>片内FRAM：  具有ROM和RAM的优点，因此既可以做ROM也可做RAM</li></ul><h3 id="3-3-5-片外存储器"><a href="#3-3-5-片外存储器" class="headerlink" title="3.3.5 片外存储器"></a>3.3.5 片外存储器</h3><p>片外程序存储器:  </p><ol><li>NOR Flash(参见P130的表3-4) </li><li>NAND Flash<br>重要的几个引脚说明：        </li></ol><ul><li>BYTE#：8位（0）/16位选择（1）        </li><li>CE#：芯片使能          </li><li>OE#：数据输出使能         </li><li>WE#：写使能       </li><li>RESET#：硬件复位       </li><li>RY/BY#：准备就绪/忙输入 </li><li>引脚低电平有效的几种表示方式：(prague.jing)        </li><li>带#号：OE#     </li><li>带上划线：       </li><li>带n号：nRESET</li><li>片外数据存储器：SDRAM\DDR/DDR2/DDR3/DDR4</li></ul><h3 id="3-3-6外部辅助存储设备"><a href="#3-3-6外部辅助存储设备" class="headerlink" title="3.3.6外部辅助存储设备"></a>3.3.6外部辅助存储设备</h3><ul><li>SM卡：被SD卡和MMC卡取代</li><li>CF卡：采用NAND Flash ROM作为存储器</li><li>MMC卡：应用于数码影像、音乐、手机、PAD等</li><li>SD卡：mimiSD卡和microSD卡（TF卡）</li><li>记忆棒</li><li>XD卡</li><li>U盘：全称为USB闪存盘，USB flash disk</li><li>微硬盘</li></ul><h2 id="3-4-I-O接口和I-O设备"><a href="#3-4-I-O接口和I-O设备" class="headerlink" title="3.4  I/O接口和I/O设备"></a>3.4  I/O接口和I/O设备</h2><ul><li>通用I/O接口GPIO：<ul><li>通用输入输出接口：输入时具备缓冲功能，而输出时具有锁存功能。 </li><li>GPIO一般有三种状态：<strong>0态、1态和高阻状态</strong>。</li></ul></li><li>集成电路互联总线接口I2C：用于连接嵌入式处理器及外围器件广泛采用的<strong>一种串行半双工</strong>传输总线标准。<ul><li>通讯速率：400kb/s、3.4Mb/s（高速模式） </li><li>只有两条线：<strong>数据线SDA和时钟线SCL</strong>。数据线SDA上的数据必须在时钟的高电平期间保持稳定，它的高/低电平状态只有在SCL时钟信号线是低电平时才能改变。 </li></ul><ol><li>起始和停止条件：     <ul><li>起始：<strong>SCL保持高电平时SDA线由高电平转为低电平</strong>，此时主控器件在SCL产生时钟信号，SDA线开始数据传送。     </li><li>停止：<strong>SCL为高电平时SDA电平由低转为高</strong>，则总线停止工作，恢复为空闲状态。 </li></ul></li><li>数据传送格式：数据传送时高位在前，低位在后，每次传送的字节数目没有限制。传送操作启动后主控器件传送的第一个字节为地址，其中前7位指出与哪一个从器件进行通讯，第8位指出数据传送的方向（发送还是接收）。 </li><li>应答信号：完成一字节的传送，接受方应该发送一个确认信号ACK给发送方。ACK信号在SCL的第9个时钟上，有效的应答ACK在SDA上呈现低电平。 </li><li>读/写操作：     <ul><li>发送：数据被发送出去后，I2C接口将处于等待状态（SCL线将保持低电平），直到有新的数据写入I2C数据发送寄存器后，SCL线才被释放，继续发送数据。   </li><li>接收：I2C接口接收到数据后，将处于等待状态，直到数据接收寄存器内容被读取后，SCL线才被释放，继续传输数据。 </li></ul></li><li>总线仲裁：<strong>I2C总线属于多主总线</strong>，允许总线上有一个或多个主控制器和若干从器件同时进行操作。 仲裁机制为线与机制，即总线控制器遵循“SDA线低电平优先”的原则。 </li><li>P139 图3-16/17</li></ol></li><li>串行外设接口SPI：   <ul><li>SPI是一种<strong>同步串行外设接口</strong>，数据传输格式为高位在前，低位在后。</li><li>SCK：时钟信号线 </li><li>SSEL：设备使能线</li><li>MOSI：主设备输出从设备输入 </li><li>MISO：主设备输入从设备输出 </li><li>可以实现<strong>一主一从、互为主从、一主多从、多主多从</strong>等连接。</li></ul></li><li>串行异步通讯接口UART：通用异步收发传输器，通常称作UART，是一种全双工异步<br>收发传输器。 <ul><li>UART由<strong>发送器、接收器、控制单元、波特率发生器</strong>等构成。 </li><li>UART字符格式约定：<br>1.字符总是以起始位为开始，以停止位为结束<br>2.数据以低位在前，高位在后按次序传输<br>3.数据位可以是5、6、7、8，由编程决定<br>4.数据位之后是校验位，可以是奇校验或偶校验，也可以没有校验<br>5.起始位以逻辑0为标志，停止位以逻辑1为标志，停止位可以为1、1.5、2位<br>6.通常情况接收采用中断方式，<strong>发送采用查询</strong>方式。<br>7.UART通讯仅限于板间或芯片间通讯，连接方式仅需三根线，<strong>TXD、RXD及GND</strong>。</li></ul></li><li>通用串行总线USB：  <ul><li>USB是通用串行总线（Universal Serial Bus）的首字母缩写 USB（1.1和2.0）有4根信号线：Vbus，D+、D-、GND。D+、D-为差分信号线。 </li><li>采用差分方式进行通讯 </li><li>USB 2.0速度480Mb/s，USB 3.0速度5Gb/s，即640MB/s USB电源5V/500mA，USB 3.0提供5V/900mA; </li><li>编码方式：翻转不归零制NRZI</li></ul></li><li>高清多媒体接口HDMI：<ul><li>HDMI是（High Definition Multimedia Interface）的缩写，意思是高清晰度多媒体接口，是一种数字化视频/音频接口技术，适合影像传输的专用型数字化接口，可同时传送音频和影像信号，即插即用。 </li><li>HDMI有两种接口形式：<strong>19针的Type-A和29针的Type-B</strong>。 DVI是24针的接口，有多种规格，</li></ul><ol><li>DVI-A：仅用于传输模拟信号，和D-SUB一样；</li><li>DVI-D：仅用于传输数字信号；</li><li>DVI-I：模拟信号和数字信号都可传输，专为LCD显示器和投影仪等数字显示设备设计的。 </li></ol><ul><li><strong>相比DVI，HDMI接口体积小，传输距离可达15m，DVI传输距离不能超过8m</strong>。 </li></ul></li><li>常用简单输入设备：<ul><li>键盘  分为两种：1. 线性键盘，2. 矩阵键盘 键盘消抖时间一般为5-30ms</li><li>触摸屏  电阻式触摸屏（软屏）：利用压力感应进行控制。</li><li>电容式触摸屏（硬屏）</li></ul></li><li>常用简单输出设备：<ul><li>LED二极管和数码管</li><li>LED发光二极管：常亮、长灭、闪亮（快闪、慢闪） 普通发光二极管电流5-20mA，电压1.2V左右。电流大，亮度高，寿命短。</li><li>LED数码管：有八段，a，b，c，d，e，f，g，dp。可以表示数字0-9，字母A-F；<br>分为共阳数码管和共阴数码管。</li><li>LCD显示设备：较好的人机交互体验</li></ul></li></ul><h2 id="3-5-典型处理器芯片-S3C2410-S3C2440"><a href="#3-5-典型处理器芯片-S3C2410-S3C2440" class="headerlink" title="3.5 典型处理器芯片[S3C2410/S3C2440]"></a>3.5 典型处理器芯片[S3C2410/S3C2440]</h2><p>芯片内部结构: </p><ul><li>S3C2410/S3C2440是三星公司基于ARM920T核的嵌入式处理器芯片。<br>采用哈弗体系结构，内部有MMU，具有16KB大小的指令Cache和16KB大小的数据Cache。</li><li>S3C2440在S3C2410的基础上增加了视频和音频接口。</li></ul><p>存储器控制组件:包括：<strong>存储器控制器、总线控制器、外部主控制器、NAND Flash 控制器</strong>等。<br>时钟和电源管理组件<br>S3C2410内部有时钟振荡电路。<br>电源管理模块：</p><ol><li>正常模式       </li><li>慢速模式：不使用PLL时钟，       </li><li>休眠模式：不使用内核时钟FCLK，外围时钟运行，       </li><li>掉电模式：断开内部电源，不产生功耗。</li></ol><ul><li>任何情况复位后均自动进入正常模式，掉电模式和休眠模式下，</li><li>任何外部中断均将返回正常模式。</li></ul><p>中断控制器及中断控制: 中断控制器 P156 表3-11<br>除屏蔽寄存器初始值为1外，其他寄存器的初始值均为0。</p><p>脉宽调制定时计数器PWM Timer<br>定时器的输入<strong>时钟频率=PCLK/（预分频值+1）×时钟因子</strong> </p><p>实时时钟RTC：实时时钟（Real-Time Clock，RTC）可以提供日历/时钟的内置硬件。<br>需要单独的供电引脚和单独的时钟源，采用<strong>32,768kHz</strong>晶体。</p><p>通用I/O接口GPIO：参考各个端口的寄存器</p><p>串行异步通讯接口UART：</p><ul><li>嵌入式系统使用串行异步通讯接口需要通讯双方波特率和传输格式一致。 </li><li>线路控制寄存器（奇偶校验、停止位、数据位）</li><li>UART控制寄存器 </li><li>状态寄存器 </li><li>数据寄存器 </li><li>波特率除数寄存器： </li><li>UBRDIVn=INT（UCLK/（波特率×16））-1（例3-7）</li></ul><p>I2C总线接口： 两种不同的地址形式：7位地址和10位地址。</p><p>看门狗定时器WDT：为了系统可靠的运行。一旦由于某种原因程序跑飞而死机，看门狗可以强行使系统重新复位。（例3-9）</p><p>模数转换器ADC：对模拟信号的采集</p><h2 id="3-6-嵌入式系统外部通讯接口"><a href="#3-6-嵌入式系统外部通讯接口" class="headerlink" title="3.6 嵌入式系统外部通讯接口"></a>3.6 嵌入式系统外部通讯接口</h2><h3 id="3-6-1-基于UART的RS-232-RS-485"><a href="#3-6-1-基于UART的RS-232-RS-485" class="headerlink" title="3.6.1 基于UART的RS-232/RS-485"></a>3.6.1 基于UART的RS-232/RS-485</h3><ol><li>RS-232接口：<ul><li>DB9是标准的RS-232连接器。DB9-2为发送引脚，DB9-3为接收引脚，DB9-5为公共地。传输距离大约15m左右。 </li><li>RS-232采用负逻辑传输：逻辑0：+3V~+15V，逻辑1：-15V~ -3V， </li><li>RS-232互联时需要交叉连接，即RXD连接到TXD，公共地互联。</li></ul></li><li>RS-485接口：<ul><li>工业控制领域、传输距离远、采用<strong>差分信号</strong>传输方式，抗共模干扰能力。传输距离可达1200m。</li><li>RS-485逻辑电平：当A的电位比B高200mV以上时为逻辑1，反之为逻辑0。</li><li>RS-485互联时同名端相连，A连A，B连B。</li></ul></li></ol><h3 id="3-6-2-CAN总线接口"><a href="#3-6-2-CAN总线接口" class="headerlink" title="3.6.2 CAN总线接口"></a>3.6.2 CAN总线接口</h3><p>CAN总线采用差分方式传输。<br>数据帧7部分组成：<strong>帧起始、仲裁域、控制域、数据域、CRC域、应答域、帧结尾</strong>。<br>CAN互联时采用<strong>同名端</strong>相连，CANL连CANL，CANH连CANH。</p><h3 id="3-6-3-以太网通讯接口"><a href="#3-6-3-以太网通讯接口" class="headerlink" title="3.6.3 以太网通讯接口"></a>3.6.3 以太网通讯接口</h3><h3 id="3-6-4-常用无线通讯接口"><a href="#3-6-4-常用无线通讯接口" class="headerlink" title="3.6.4 常用无线通讯接口"></a>3.6.4 常用无线通讯接口</h3><ol><li>PS模块：全球定位系统（Global Positioning System），简称GPS。民用精度100m，采用差分GPS技术后，精度5m。</li><li>北斗模块：北斗一代称为北斗导航实验系统（BDTS），北斗二代称为北斗卫星导航系统，是继美国GPS和俄国GLONASS之后第三个成熟的卫星导航系统。定位精度10m，授时精度50ns，测速精度0.2m/s。</li><li>GPRS模块：GPRS是通用分组无线服务的简称，是GSM移动电话用户可用的一种移动数据业务。</li><li>WIFI模块：<strong>802.11</strong>协议的无线局域网，无线WIFI模块内置TCP/IP协议栈，可以使有线数据到无线数据的传输。</li><li>蓝牙模块：短距离通讯（10m之内）的无线低速（1Mb/s）通讯技术。</li><li>其他（Zigbee、LoRa、433）</li></ol><h2 id="第四章：嵌入式系统软件"><a href="#第四章：嵌入式系统软件" class="headerlink" title="第四章：嵌入式系统软件"></a>第四章：嵌入式系统软件</h2><h2 id="4-1-嵌入式软件的组成"><a href="#4-1-嵌入式软件的组成" class="headerlink" title="4.1 嵌入式软件的组成"></a>4.1 嵌入式软件的组成</h2><ul><li>嵌入式软件的特点：<ul><li>软硬件一体化，软件固化存储</li><li>代码效率高、实时性要求高</li><li>软件可裁剪</li><li>安全性、可靠性要求高(容错设计)</li><li>软件开发难度大(软硬件、开发环境、调试技巧掌握)</li><li>面向客户、面向应用</li><li>软件产业高度分散(嵌入式针对性很强)</li><li>生命周期长(跟新替换同产品同步进行)</li></ul></li><li>嵌入式软件的结构：<ul><li><strong>轮询结构</strong>(没有中断)</li><li>带中断的轮询结构</li><li>监控式操作系统(µC/OS(内核+任务调度+任务通讯+中断管理))+应用软件</li><li>嵌入式操作系统(Android)+应用软件</li></ul></li><li>硬件抽象层HAL与板级支持包BSP<ul><li>概念：<ul><li><strong>硬件抽象层：Hardware Abstract Layer</strong><br>操作系统层和硬件之间设置的独立接口软件层，是所有直接依赖于硬件的软件，包括引导程序、硬件配置程序、硬件访问代码。</li><li><strong>板级支持包：Board Support Package</strong><br>由硬件制造商专门编写，屏蔽了其所支持的嵌入式操作系统和底层硬件平台的相关性。</li></ul></li><li>实例：<ul><li>开发和移植：最小系统调试。外围设备驱动程序调试</li></ul></li></ul></li><li>引导加载程序Bootloader<ul><li>概念和功能：嵌入式系统上电复位后首先运行引导加载程序，它负责系统的上电自检、硬件初始化、建立存储空间映射、配置系统参数、建立上层软件的运行环境、并加载和启动操作系统。</li><li>嵌入式操作系统的加载方式：<ul><li>ROM中直接运行操作系统</li><li>RAM中运行操作系统</li><li>外部存储器加载操作系统</li><li>通讯接口加载操作系统</li></ul></li></ul></li><li><p>引导加载程序的执行过程</p><ul><li>U-Boot：最强、最具弹性、应用最广、更新最快的开源BootLoader</li></ul></li><li>设备驱动程序：  <ul><li>以24C02为例：<ol><li>只能被高层软件调用而无法自行运行；</li><li>对上层软件屏蔽硬件细节，对下层硬件直接进行操作。</li></ol></li></ul></li></ul><h2 id="4-2-嵌入式操作系统"><a href="#4-2-嵌入式操作系统" class="headerlink" title="4.2 嵌入式操作系统"></a>4.2 嵌入式操作系统</h2><p>实时系统与实时操作系统</p><ul><li>实时系统：必须在有限和确定的时间内对外部事件作出响应的信息系统。 IEEE计算机协会实时系统技术委员会(IEEE-CT-TCRTS)：正确性不仅取决于计算的结果，而且取决于产生结果的时间的计算机系统。<br>实时系统对外界的响应是否正确不仅取决于功能正确性，而且取决于对事件处理的正确性。<br>实时系统中的任务分为三类： </li></ul><ol><li><strong>硬实时任务</strong>：也叫做强实时任务，任务必须在给定的时限内完成，超过时限将会导致任务失败或引起致命错误。工业控制和军工系统 </li><li><strong>软实时任务</strong>：也叫做弱实时任务，软实时任务仍然要求系统的响应越快越好，但偶尔超出时限并不会造成任务失败或出现致命错误。DVD播放机 </li><li><strong>准实时任务</strong>：通常允许偶尔错过最后期限，但若超过时限，所进行的操作或计算结果没有任何意义。 注意：硬实时、软实时与准实时的概念与时限的长短没有关系，而与其对超过实现的容忍程度有关。<br>实时系统特征：<strong>1. 时间约束性、2. 可预测性、3. 可靠性、4. 交互性</strong></li></ol><ul><li>实时操作系统：实时操作系统是不以在给定时间内完成更多的任务为目标，而是以响应外部事件尽可能快且响应时间具有确定性为目标的操作系统。<br>实时系统最关键的特性就是完成每次任务所需要的时间的一致性。如果一个实时操作系统能够完全满足确定性的时限要求，则称为硬实时操作系统，否则称为软实时操作系统。<br>实时操作系统完成每次任务所需时间的偏差称为抖动。<strong>硬实时操作系统的抖动比软实时系统小</strong>。</li><li>实时操作系统实时性指标：响应时间：系统从事件请求开始到任务完成的时间间隔。<ol><li><strong>中断延时时间</strong>：接收到可屏蔽中断请求信号到操作系统做出响应并转入中断服务程序所需要的最长时间。 </li><li><strong>任务切换时间</strong>：操作系统在两个独立且具有相同优先级的就绪态任务之间切换所需要的时间 </li><li><strong>任务抢占时间</strong>：系统将控制权从低优先级任务转移到高优先级任务所花费的时间</li></ol></li></ul><p>嵌入式操作系统概述</p><ul><li>特点：具有<strong>任务调度、同步机制、内存管理、中断处理、文件处理、</strong> <ol><li>代码固化存储，时空效率高 </li><li>可裁剪性 </li><li>实时性 </li><li>强稳定性，弱交互性 </li><li>硬件适应性</li></ol></li><li>分类：<ol><li>实时性：硬实时操作系统，弱实时操作系统(非实时操作系统) </li><li>开发方式：专用嵌入式环境开发的嵌入式操作系统，通用计算机操作系统移植的嵌入式操作系统 </li><li>商业模式：免费嵌入式操作系统（RTEMS、eCOS\FreeRTOS）、商业嵌入式操作系统（VxWorks、µC/OS）</li></ol></li><li>内核结构：<br><strong>单内核(宏内核)</strong>：操作系统把内核的各个功能模块（如进程管理、文件系统、设备管理、网络通信等）整合在一起，模块间的交互通过直接调用其他模块中的函数来实现，执行效率高，性能好。<br>例如：<strong>Unix，BSD Unix，Linux，MS-DOS、Windows 9x（Windows 95/98/Me），Windows CE，Android</strong><br><strong>微内核</strong>：仅将必须的基本功能（任务调度、任务键通讯、存储管理、中断处理）放入内核，运行在核心态；其他功能都在内核之外，由用户态服务来完成。<br>例如：<strong>AIX、Mach（早起Apple计算机操作系统内核）、Minix、VxWorks、QNX</strong><br>通用计算机采用微内核：<strong>Windows NT/XP/2000、Vista，Windows 7，MacOS X，ReactOS</strong></li><li>常用嵌入式操作系统：<ul><li>VxWorks：美国风河公司（09年成为英特尔的全资子公司），广泛应用于军用产品。收费</li><li>QNX：QNX软件公司（10年被黑莓收购），类Unix操作系统，</li><li>Nucleus PLUS：ATI公司的，代码使用ANSI C编写的</li></ul></li><li>嵌入式Windows操作系统家族：<ul><li>嵌入式操作系统EOS：Windows Embedded Compact(WEC)<br>Windows Embedded 系列<br>+设备平台（device platform）<ul><li>RTEMS：美国军方研制，用于国防系统，</li><li>TinyOS：无线传感器网络操作系统，美国加州大学伯克利分校研发，开源嵌入式操作系统</li><li>eCOS：嵌入式可配置操作系统，开源免费</li><li>FreeRTOS：开源免费操作系统</li></ul></li></ul></li><li>Linux内核<ul><li>Unix：诞生于美国电话电报公司（AT&amp;T）的贝尔实验室 Linux：属于类Unix，起源于芬兰赫尔辛基大学的学生: 林纳斯 托瓦斯。</li><li>Linux是一种自由软件（开源、免费、自由定制、自由传播）。 </li><li>中国天河一号巨型机系统内核为Linux。</li></ul></li></ul><p>嵌入式Linux操作系统</p><ul><li>结构与组成：<ul><li>结构：单内核。</li><li>组成：①初始化组件、②进程调度器、③内存管理、④虚拟文件系统、⑤网络接口、⑥进程间通讯、⑦可加载模块、⑧设备驱动程序</li></ul></li><li>实时化技术：<ol><li>内核补丁方式</li><li>双内核方式</li><li>超微内核方式</li></ol></li><li>系统的构建：<ul><li>基于通用Linux内核构建嵌入式Linux</li><li>基于嵌入式Linux发行版构建嵌入式Linux<br>µclinux<br>Monta Vista Linux<br>RTLinux<br>RTAI<br>Xenomai<br>Wind River Linux</li></ul></li></ul><p>Android操作系统</p><ul><li>系统特点：美国Google公司主导的一个开源项目。中文名字“安卓”， Android核心是以Linux内核为基础的开源操作系统。 主要应用于智能手机、平板电脑、车载导航、医疗仪器和智能家居等领域。</li><li>系统组成与结构：Android采用<strong>堆层式软件架构</strong>，<br><strong>分为四层</strong>：<ol><li>Linux内核层</li><li>系统运行库：<br>①Android运行环境：Dalvil虚拟机和核心库<br>②组件库：系统C库，媒体框架、surface manager 显示<br>管理库、SGL库、freetype库、SQLite库、WebKit库、<br>OpenGL|ES 3D库、OpenSSL库</li><li>应用程序框架：活动管理器、窗口管理器、内容提供器、视觉系统、通告管理器、包管理器、电话管理器、资源管理器、位置管理器、XMPP服务。 </li><li>应用程序：</li></ol></li><li>应用开发：配置开发环境<br>创建Android应用开发工程<br>运行应用程序</li></ul><p>iOS操作系统</p><ul><li>概述：苹果公司开发的操作系统，原名为iPhone OS，应用于iphone智能手机、平板电脑、和电视机顶盒。<br><strong>iOS同样属于类Unix的操作系统</strong>，</li><li>组成与结构：<ul><li>核心操作系统层</li><li>核心服务层</li><li>媒体层</li><li>触控界面层</li></ul></li><li>应用开发：Xcode</li></ul><h2 id="4-3-µC-OS嵌入式操作系统"><a href="#4-3-µC-OS嵌入式操作系统" class="headerlink" title="4.3 µC/OS嵌入式操作系统"></a>4.3 µC/OS嵌入式操作系统</h2><p>µC/OS操作系统概述：</p><ul><li>历史和发展：µC/OS是由美国Micriµm公司创始人拉伯罗斯（Jean J. Labrosse）开发的RTOS内核。<br>第一个版本：µC/OS，1992年<br>第二个版本：µC/OS II，1998年<br>第三个版本：µC/OS III，2010年</li><li>特点：<ol><li>公开源码的高质量实时内核：不免费，商业用途需要获得Micriµm公司许可。 </li><li>可移植： </li><li>可剪裁、可固化 </li><li>时间确定性 </li><li>多任务：µC/OS II可以管理<strong>64个任务，8个保留给系统</strong>，且不支持时间片轮转调度。 </li><li>抢占式内核 </li><li>多种系统服务：任务管理、时间管理、信号量、事件标志组、互斥信号量、消息队列、内存分区管理。</li></ol></li><li>组成和源代码结构：<strong>µC/OS-II内核负责管理用户任务</strong>，并为任务提供资源共享等服务机制。<br>µC/OS-II源代码主要组成：<ol><li>系统核心</li><li>任务管理 </li><li>时钟管理 </li><li>任务同步和任务间通讯 </li><li>内存管理 </li><li>处理器相关代码</li></ol></li></ul><hr><p>µC/OS-II任务及管理</p><ul><li><p>任务构成：µC/OS-II中，任务是操作系统的基本调度单位。 任务由三部分组成： </p><ol><li>程序代码：没有返回值的C函数， </li><li>任务堆栈：用于保存任务的工作环境， </li><li>任务控制块：保存任务状态和属性的数据结构</li></ol></li><li><p>任务的状态：µC/OS-II的任务处于5种状态：</p><ol><li><strong>休眠态</strong>：任务代码驻留在内存中但还没有交给内核调度的状态，调用创建任务后</li><li><strong>就绪态</strong>：任务已经具备运行条件但因优先级比正在运行的任务低而暂时不能运行的状态</li><li><strong>运行态</strong>：任务已经获得处理器的使用权而正在运行的状态，任何时刻系统中只有一个任务处于运行状态。</li><li><strong>等待态/挂起态</strong>：正在运行的任务因为某一事件发生而将处理器的使用权让给其它任务将自己挂起的状态。</li><li><strong>被中断态</strong>：处理器执行中断服务程序而被暂停运行的任务状态。</li></ol></li><li><p>任务调度：µC/OS-II可以管理<strong>64个任务</strong>（2.82版本后可以管理255个任务）， 0是最高优先级别，最低优先级由OS_LOWEST_PRIO定义， 8个保留给系统，最高优先级的0-3和最低优先级的4个OS_LOWEST_PRIO-3至OS_LOWEST_PRIO，即用户任务最多56个， 任务优先级具有唯一性，所以优先级作为任务的标识。<br><strong>空闲任务</strong>：idle task，必须使用空闲任务，并且是最低优先级。不能被挂起和删除。<br><strong>统计任务</strong>：可选的任务，统计当前处理器利用率。<br><strong>调度方式：</strong></p><ol><li><strong>任务级调度</strong>：内核通过调度OS_TASK_SW()进行任务级的任务切换，保存当前任务的上下文（程序计数器PC，通用寄存器和处理器的状态寄存器），并恢复新任务的上下文。 </li><li><strong>中断级调度</strong>：中断级通过调用OSIntExit()进行任务调度<br>临界区代码：</li></ol></li></ul><ol><li>利用宏OS_ENTER_CRITICAL（）和OS_EXIT_CRITICAL（）实现关中断和开中断</li><li>利用函数OSSchedlock（）和OSSchedUnlock（）给调度器上锁和解锁。</li></ol><ul><li>中断处理：中断服务程序执行步骤如下：<ol><li>保存全部CPU寄存器</li><li>调用OSIntEnter（）或OSIntNesting直接加1</li><li>执行用户中断服务程序代码</li><li>调用OSIntExit（）</li><li>回复所有CPU寄存器</li><li>执行中断返回指令<br>通过OSIntNesting标识当前是否处于中断或中断嵌套的层数，中断嵌套<strong>最多255层。 中断处理中不允许进行任务管理、事件管理、任务调度等</strong></li></ol></li></ul><p>µC/OS-II系统服务</p><ul><li>任务管理：<ul><li><strong>任务创建</strong>：OSTaskCreate（）或者调用OSTaskCreateExt（）<br>任务可以在调用OSStart（）之前或者之后被创建。<br>在任务调度前必须至少创建一个用户任务。</li><li><strong>任务删除</strong>：OSTaskDel (INT8U prio)函数用于删除任务 prio<br>任务可以删除其他任务也可以删除自身，<br>删除后转入休眠态，不被内核调度<br>如有共享资源访问可以调用OSTaskDelReg（）函数让任务使用完资源后再删除。</li><li><strong>任务挂起和恢复</strong>：OSTaskSuspend（） 可以挂起任务。可以挂起自身可其他任务，必须调用OSTaskResume（）进行任务的恢复。</li></ul></li><li><p>时钟节拍和时间管理：操作系统内核需要周期性的信号源用于时间延时和超时。用户必须在调用OSStart（）启动多任务调度以后再开启时钟节拍器。在调用OSStart（）后的第一件事就是初始化定时器中断。<br>任务延时：OSTimeDly()：延时时间是以节拍数来衡量的 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OSTimeDlyHMSM(CPU_INT16U   hours,</span><br><span class="line">CPU_INT16U   minutes,</span><br><span class="line">CPU_INT16U   seconds,</span><br><span class="line">CPU_INT32U   milli,</span><br><span class="line">OS_OPT       opt,</span><br><span class="line">OS_ERR      *p_err)：延时时间则是以具体时间大小来衡量的               </span><br><span class="line">*  hours        (0...99)</span><br><span class="line">*  minutes      (0...59) </span><br><span class="line">*  seconds      (0...59)</span><br><span class="line">*  milliseconds (0...999)</span><br></pre></td></tr></table></figure></li><li><p>任务间通讯和同步：任务间通讯常用的有： </p><ol><li><strong>信号量</strong>：    创建/删除/释放/等待/查询 </li><li>互斥信号量：创建/删除/释放/等待/查询 </li><li>事件标志组：创建/删除/释放/等待/查询 </li><li>消息邮箱：  创建/删除/释放/等待/查询 ‘</li><li>消息队列：  创建/删除/释放/等待/查询</li></ol></li></ul><hr><p>µC/OS-II应用程序设计</p><ul><li><strong>µC/OS初始化和main()函数结构</strong>：基于µC/OS II 的多任务系统中，引导加载程序执行完毕则调用主函数main（）。<br>主函数主要实现的功能包括：<ol><li>硬件初始化、</li><li>调用OSInit（）初始化µC/OS-II的内核，</li><li>创建任务、</li><li>创建任务间通讯或同步的内核对象、</li><li>应用程序相关的初始化、</li><li>调用OSStart（）启动多任务调度等。</li></ol></li><li><strong>用户任务的三种结构</strong>：任务可以是一个无限循环，也可以在任务完成后自我删除。</li><li>通常任务有三种结构：<ol><li><strong>单次执行任务</strong>：任务创建后处于就绪态并可以被执行，执行完相应的功能后则自我删除。 </li><li><strong>周期执行任务</strong>：任务通常采用循环结构，并在每次完成具体的功能后调用系统延时函数OSTimeDlyHMSM（）或者OSTimeDly（）等待下一个执行周期，并将处理器让给其它任务。 </li><li><strong>事件触发执行的任务</strong>：任务的实体代码只有在某种事件发生后才执行。在事件发生之前，任务被挂起。任务也采用循环结构，事件触发一次，任务执行一次。</li></ol></li></ul><hr><p><strong>应用程序设计实例</strong><br>µC/OS-III操作系统的改进和提高</p><p>µC/OS-II定位于8位/16位/低端32位处理器<br>µC/OS-III定位于高端32位处理器，在8位/16位上也可以运行。</p><p>µC/OS-III增加的主要特性：</p><ol><li>时间片轮转调度：允许给任务相同的优先级                           </li><li>内核对象的无限制：任务、信号量、互斥信号量、事件标志、消息队列、定时器等</li><li>任务消息和任务信号：任务本身即可以发送消息和信号量</li><li>时钟节拍：使用哈希散列表机制</li><li>可针对处理器体系结构进行优化</li><li>时间戳</li><li>增强内置性能测试功能：测试任务、CPU的占用情况</li></ol><h2 id="第五章：嵌入式系统开发"><a href="#第五章：嵌入式系统开发" class="headerlink" title="第五章：嵌入式系统开发"></a>第五章：嵌入式系统开发</h2><h2 id="5-1-开发嵌入式系统的基础知识"><a href="#5-1-开发嵌入式系统的基础知识" class="headerlink" title="5.1 开发嵌入式系统的基础知识"></a>5.1 开发嵌入式系统的基础知识</h2><h3 id="5-1-1嵌入式系统的开发过程："><a href="#5-1-1嵌入式系统的开发过程：" class="headerlink" title="5.1.1嵌入式系统的开发过程："></a>5.1.1嵌入式系统的开发过程：</h3><ul><li>需求分析与规格说明</li><li>系统设计</li><li>构建设计</li><li>系统集成和测试：测试（Test）的目的是验证模块/系统的功能和性能，发现错误。<br>调试（Debug）的任务是分析测试中发现的错误，检查原因、定位故障位置，采取适当的措施，修改软件/硬件，然后返回重新进行测试。</li></ul><h3 id="5-1-2开发平台和工具"><a href="#5-1-2开发平台和工具" class="headerlink" title="5.1.2开发平台和工具"></a>5.1.2开发平台和工具</h3><ul><li>嵌入式系统的开发特点：<br>宿主机-目标机的开发架构<br>嵌入式系统的开发平台多半不是最终的运行平台，因此嵌入式的开发通常需要构建一个宿主机-目标机的交叉编译及运行环境，用于编程、调试的计算机称为宿主机（Host），用于程序最终运行的称为目标机（Target）。与底层硬件控制程序的关系密切软硬件资源受限需要固化程序</li><li>开发平台和开发工具：集成开发环境（IDE）</li><li>典型开发平台</li><li><h3 id="5-1-3嵌入式系统的调试"><a href="#5-1-3嵌入式系统的调试" class="headerlink" title="5.1.3嵌入式系统的调试"></a>5.1.3嵌入式系统的调试</h3></li><li><p>在线仿真器（ICE）</p></li><li>片上调试技术（OCD）-JTAG：JTAG(Joint Test Action Group,联合测试工作组)是一种国际标准测试协议（IEEE 1149.1兼容），主要用于芯片内部测试。 标准的JTAG接口4线：TMS、TCK、TDI、TDO，分别为模式选择、时钟、数据输入和数据输出线。 信号线TRST（复位）是可选的。</li><li>驻留监控软件调试</li><li>指令集模拟器（ARMulator和SkyEye）</li></ul><h2 id="5-2-系统开发工具软件"><a href="#5-2-系统开发工具软件" class="headerlink" title="5.2 系统开发工具软件"></a>5.2 系统开发工具软件</h2><ul><li>ADS1.2工具软件</li><li>RVDS</li><li><p>GNU：<strong>GNU</strong>是“GNU is Not Unix”的递归缩写，常用于基于Linux操作系统的嵌入式软件工具套件简称。包括编译器、连接器、文本剪辑器、语法除错等工具。</p><ul><li><p><strong>GCC概述</strong>：针对Linux操作系统环境下应用程序的编译工具，可以将C语言、C++语言、汇编语言编写的源程序及库文件编译连接成执行文件。 从源文件生成执行文件的过程为：<strong>预处理、编译、汇编、连接</strong>。 </p><p>生成可执行文件时，无论工程目录中只有一个源文件还是多个源文件，所有被编译和连接的源文件中必须有且仅有一个main函数。 若仅仅是把源文件编译成目标文件，不进行连接操作，main函数就不是必须的。</p></li><li><p><strong>GCC命令和参数</strong>：基本命令格式为：<code>gcc [options] [filenames]</code><br>options代表编译器命令所需要的参数<br>filenames代表命令中所涉及的相关文件名称<br>针对ARM系列微处理器为核心的目标机，<strong>GCC的基本命令格式是</strong>：<code>arm-linux-gcc [options] [filenames]</code></p></li><li><p><strong>GDB</strong>： GDB是GNU开发工具套件中的程序调试工具，可以提供单步执行和断点执行功能，并观察程序执行时变量值的变化。</p></li><li><p><strong>GNU的使用</strong>：</p><ol><li>需要建立好交叉编译环境，并在宿主机上安装应用于目标机硬件平台的GCC，GDB等工具软件。</li><li>采用一个文本编辑器来编辑项目中所需要的源文件，源文件可以是C/C++/汇编语言 </li><li>利用与目标机硬件平台相关的GCC命令完成预处理、编译、汇编、连接工作。项目中由若干个源文件组成时，通常编写Makefile文件来确定源文件的连接顺序、若程序中只有一个源文件，则不需要Makefile文件，直接使用GCC命令来完成编译工作。 </li><li>利用GDB工具进行程序调试。注意：在编译时需要在命令中加入-g参数，以便生成调试信息。</li></ol></li></ul></li></ul><h2 id="5-3-系统开发示例"><a href="#5-3-系统开发示例" class="headerlink" title="5.3 系统开发示例"></a>5.3 系统开发示例</h2><ul><li>数字式电子钟</li><li>便携式心电记录仪</li><li>基于嵌入式Web服务器的应用设计</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;嵌入式系统开发技术&quot;&gt;&lt;a href=&quot;#嵌入式系统开发技术&quot; class=&quot;headerlink&quot; title=&quot;嵌入式系统开发技术&quot;&gt;&lt;/a&gt;嵌入式系统开发技术&lt;/h1&gt;&lt;p&gt;前言：写来给计算机三级整理用的，虽然意义不是很大。&lt;/p&gt;
&lt;h2 id=&quot;TOC&quot;
      
    
    </summary>
    
    
      <category term="嵌入式" scheme="http://yoursite.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Note of Effective C++</title>
    <link href="http://yoursite.com/2019/03/05/test/"/>
    <id>http://yoursite.com/2019/03/05/test/</id>
    <published>2019-03-05T08:44:47.000Z</published>
    <updated>2019-03-22T02:45:17.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Effective-C-浏览过程"><a href="#Effective-C-浏览过程" class="headerlink" title="Effective C++浏览过程"></a><em>Effective C++</em>浏览过程</h1><hr><p>[TOC]</p><h2 id="条款01：视C-为语言联邦"><a href="#条款01：视C-为语言联邦" class="headerlink" title="条款01：视C++为语言联邦"></a>条款01：视C++为语言联邦</h2><p>1.C：C++是以C为基础的语言。<br>2.Object-Oriented C++：C++中面向对象的内容。<br>3.Template C++：C++中泛型编程的内容。<br>4.STL：C++中的标准库。</p><h2 id="条款02：尽量用const，enum，inline来替换-include"><a href="#条款02：尽量用const，enum，inline来替换-include" class="headerlink" title="条款02：尽量用const，enum，inline来替换#include"></a>条款02：尽量用const，enum，inline来替换#include</h2><ul><li>对于单纯常量，最好用const或者enum来代替#include</li><li>对于宏定义（Marco），最好改用inline函数（template inline）替换#include</li></ul><h2 id="条款03：尽量使用const"><a href="#条款03：尽量使用const" class="headerlink" title="条款03：尽量使用const"></a>条款03：尽量使用const</h2><ul><li>如果关键字const出现在星号左边，则被指物是常量。</li><li>如果关键字const出现在星号右边，则被指针是常量。</li><li>STL中如果需要声明一个’T* const指针‘，则使用const_iterator。</li><li>成员函数其常量性的不同，也可以被重载 。</li></ul><h2 id="条款04：确定对象在使用前已被初始化"><a href="#条款04：确定对象在使用前已被初始化" class="headerlink" title="条款04：确定对象在使用前已被初始化"></a>条款04：确定对象在使用前已被初始化</h2><ul><li>初始化和赋值并不一样，比如构造函数中初始化发生在进入构造函数本体（即赋值语句）之前。所以构造函数最好使用成员初值列(member initalization list)，而非赋值操作(assignment)。其成员的初始化顺序与声明顺序相同。</li><li>为内置型对象（如int,double）进行手工初始化，因为C++不保证初始化它们。</li></ul><h2 id="条款05：了解C-隐式编写并调用了哪些函数"><a href="#条款05：了解C-隐式编写并调用了哪些函数" class="headerlink" title="条款05：了解C++隐式编写并调用了哪些函数"></a>条款05：了解C++隐式编写并调用了哪些函数</h2><p>+编译器会暗自给class创建default构造函数，copy构造函数，copy assignment操作符，以及析构函数。</p><h2 id="条款06：如果不想使用编译器自动生成的函数，就应该明确拒绝"><a href="#条款06：如果不想使用编译器自动生成的函数，就应该明确拒绝" class="headerlink" title="条款06：如果不想使用编译器自动生成的函数，就应该明确拒绝"></a>条款06：如果不想使用编译器自动生成的函数，就应该明确拒绝</h2><ul><li>可以将相应的成员函数声明为private来拒绝编译器自动提供的功能（比如copy构造函数或copy assignment操作符）。</li></ul><h2 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h2><ul><li>只有当class包含至少一个virtual函数时，才给它声明一个virtual析构函数。</li><li>如果class的设计目的不是作为base class使用或者具备多态性时(polymorphically)，就不该声明析构函数。</li></ul><h2 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h2><ul><li>不能让析构函数吐出异常，不然会带来“过早结束程序”或者“发生不明确行为”的风险。</li><li>如果客户需要对某个函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非析构函数）执行该操作。</li></ul><h2 id="条款09：绝不要在构造和析构函数中调用virtual函数"><a href="#条款09：绝不要在构造和析构函数中调用virtual函数" class="headerlink" title="条款09：绝不要在构造和析构函数中调用virtual函数"></a>条款09：绝不要在构造和析构函数中调用virtual函数</h2><ul><li>在构造和析构（连同它们调用的所有函数）中不要调用virtual函数，因为这类调用不会下降至derived class（派生类）。</li></ul><h2 id="条款10：令operator-返回一个-reference-to-this"><a href="#条款10：令operator-返回一个-reference-to-this" class="headerlink" title="条款10：令operator= 返回一个 reference to *this"></a>条款10：令operator= 返回一个 reference to *this</h2><ul><li>令赋值（assignment）操作符返回一个reference to *this ，这个协议被所有内置和标准程序库提供的类型如string，vector等等共同遵守。</li></ul><h2 id="条款11：在operator中处理“自我赋值”"><a href="#条款11：在operator中处理“自我赋值”" class="headerlink" title="条款11：在operator中处理“自我赋值”"></a>条款11：在operator中处理“自我赋值”</h2><ul><li>确保当对象自我赋值时能够有良好的行为（自我赋值时先赋值后销毁，而不是赋值一个已经被删除的对象）。比如比较“来源对象”和“目标对象”地址，copy-and-swap。</li><li>确保任何函数操作一个以上对象，其多个对象是同一对象时，其行为任然正确。</li></ul><h2 id="条款12：复制对象时不要忘记每一个成分"><a href="#条款12：复制对象时不要忘记每一个成分" class="headerlink" title="条款12：复制对象时不要忘记每一个成分"></a>条款12：复制对象时不要忘记每一个成分</h2><ul><li>cpoying函数应该保证复制“所有成员变量”及其“base class（基类）的成员变量即调用基类的copying函数”。</li><li>当copy构造函数和copy assignment操作符有相近代码时，建立一个新的成员函数供两者调用来消除重复代码，一般这个新的成员函数是名为init的private函数。</li></ul><h2 id="3-资源管理"><a href="#3-资源管理" class="headerlink" title="3.资源管理"></a>3.资源管理</h2><h2 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h2><ul><li>为了防止资源的泄漏，请使用RAII(Resource Acquisition Is Initialization)对象，他们在构造函数之中获得资源并在析构函数之中释放资源，避免对象结束时忘记释放资源导致内存泄漏。</li><li>两个常被使用的RAII classes是trl::shared_ptr和auto::ptr。前者通常是最佳选择，其copy行为比较直观。而auto_ptr进行复制操作时会让被复制对象（即原对象）指向null。</li></ul><h2 id="条款14：在资源管理类中小心copying行为"><a href="#条款14：在资源管理类中小心copying行为" class="headerlink" title="条款14：在资源管理类中小心copying行为"></a>条款14：在资源管理类中小心copying行为</h2><ul><li>复制RAII对象时必须一并复制它所管理的资源，而资源的copying行为决定RAII对象的copying行为。</li><li>常见的RAII class copying行为是：禁止复制（比如互斥锁Mutex Lock），引用计数法（trl::shared_ptr，用在希望保有资源知道它的最后一个对象被销毁）。</li></ul><h2 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h2><ul><li>APis往往要求访问原始资源（raw resource），所以每一个RAII class应该提供一个“获取其管理资源的方法”（比如trl::shared_ptr的get( ) 函数用以返回一个原始指针）。</li><li>对原始资源的访问有显式和隐式两种，显式较为安全，隐式对客户而言比较方便。</li></ul><h2 id="条款16：成对使用new和detele时要采取相同形式"><a href="#条款16：成对使用new和detele时要采取相同形式" class="headerlink" title="条款16：成对使用new和detele时要采取相同形式"></a>条款16：成对使用new和detele时要采取相同形式</h2><ul><li>如果在new表达式中使用了[ ]，必须在相应的delete表达式中也使用[ ]。</li></ul><h2 id="条款17：以独立语句将newed对象置入智能指针"><a href="#条款17：以独立语句将newed对象置入智能指针" class="headerlink" title="条款17：以独立语句将newed对象置入智能指针"></a>条款17：以独立语句将newed对象置入智能指针</h2><ul><li>以独立语句将newed对象置如智能指针之中，因为在复合语句中编译器对于多个操作有重新排列的自由度，有时其他操作导致的异常会影响到智能指针的创建。一旦异常被抛出可能会导致难以察觉的资源泄漏。</li></ul><h2 id="4-设计与声明"><a href="#4-设计与声明" class="headerlink" title="4.设计与声明"></a>4.设计与声明</h2><h2 id="条款18：让接口容易被使用，不易被误用"><a href="#条款18：让接口容易被使用，不易被误用" class="headerlink" title="条款18：让接口容易被使用，不易被误用"></a>条款18：让接口容易被使用，不易被误用</h2><ul><li>好的接口很容易被正确地使用，不容易被误用。应该在所有接口中努力达成这些性质。</li><li>“促进正确的使用”的方法包括接口的一致性，以及与内置类型的行为兼容。</li><li>“阻止误用”的方法包括建立新的类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。</li><li>trl::shared_ptr支持定制删除器（custom deleter）。这可以用来防范DLL问题（cross-DLL problem：发生在对象在一个DLL中被new创建，在另一个DLL中被delete销毁），还被用来自动解除互斥锁（mutex；见条款14），等等。</li></ul><h2 id="条款19：设计class犹如设计type"><a href="#条款19：设计class犹如设计type" class="headerlink" title="条款19：设计class犹如设计type"></a>条款19：设计class犹如设计type</h2><ul><li>新type的对象应该如何被创建和销毁？</li><li>对象的初始化和对象的赋值应该有什么样的差别？</li><li>新的type对象如果被passed by value（以值传递），意味着什么？</li><li>什么是新type的“合法值”？</li><li>你的新type需要配合某个继承图系吗（inheritance graph）？可能会受到“它们的函数是virtual或non-virtual”的影响</li><li>你的新type需要什么样的转换？</li><li>什么样的操作符和函数对此type是合理的？</li><li>什么样的标准函数应该被驳回？那些需要被声明为private（见条款6）。</li><li>谁会取用type的成员？这个问题会决定成员是public、private或protected。</li><li>什么是新type的“未声明接口“（undeclared interface）？</li><li>你的新type有多么一般化？如果很大（定义一整个家族），就应该定义一个新的class template。</li><li>你真的需要一个新type吗？</li></ul><h2 id="条款20：宁可用pass-by-reference-to-const替换pass-by-value"><a href="#条款20：宁可用pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款20：宁可用pass-by-reference-to-const替换pass-by-value"></a>条款20：宁可用pass-by-reference-to-const替换pass-by-value</h2><ul><li><p>尽量以pass-by-reference-to-conse替换pass-by-value，前者比较搞笑，并可避免切割问题（slicing problem：因为值传递在构造函数中，其特化信息（比如派生类对象被切除为基类）会被切除）。</p></li><li><p>以上规则不适用于内置类型，以及STL的迭代器和函数对象。对它们而言pass-by-value往往比较合适。</p></li></ul><h2 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款21：必须返回对象时，别妄想返回其reference</h2><ul><li>绝对不要返回pointer或reference指向一个local stack对象，或返回reference指向一个能heap-allocated对象，或返回pointer或reference指向一个local static 对象而有可能同时需要多个这样的对象，条款4中”合理返回reference指向一个local static对象“。</li></ul><h2 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款22：将成员变量声明为private</h2><ul><li>切记将成员变量声明为private，这可以赋予客户访问数据的一致性、可细微划分访问控制、承诺约束条件得到保证，并给class作者充分的实现弹性。</li><li>protected不比public更具封装性（比如在使用它的derived classes都会受到影响）。</li></ul><h2 id="条款23：宁可用non-member、non-friend替换member函数"><a href="#条款23：宁可用non-member、non-friend替换member函数" class="headerlink" title="条款23：宁可用non-member、non-friend替换member函数"></a>条款23：宁可用non-member、non-friend替换member函数</h2><ul><li>这样做可以增加封装性、包裹弹性（packing flexibility）和技能扩充性。</li><li>non-member、non-friend函数可以放在命名空间（namespace）中来方便使用。</li></ul><h2 id="条款24：若所有参数都需要类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数都需要类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数都需要类型转换，请为此采用non-member函数"></a>条款24：若所有参数都需要类型转换，请为此采用non-member函数</h2><ul><li>如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个non-member。（只有当参数位于参数列时，这个参数才是隐式类型的合格参与者）</li></ul><h2 id="条款25：考虑写一个不抛异常的swap函数"><a href="#条款25：考虑写一个不抛异常的swap函数" class="headerlink" title="条款25：考虑写一个不抛异常的swap函数"></a>条款25：考虑写一个不抛异常的swap函数</h2><ul><li>当std::swap对你写的类型效率不高时，提供一个swap成员函数，并保证这个函数不会抛出异常。</li><li>如果提供member的swap函数，也应该提供一个non-member的swap函数来调用前者。对于classes（而非template），也请特化std::swap。</li><li>调用swap时针对std::swap使用using声明式，然后调用swap并且不带任何”命名空间资格修饰“。</li><li>为”用户定义类型“进行std templates全特化是好的，但是不要在std中加入新的东西。</li><li>pimpl手法（pointer to implementation ）：通过一个私有的成员指针，将指针指向的类的内部实现数据进行隐藏（见条款31）。</li></ul><h2 id="条款26：尽可能延后变量定义式的出现时间"><a href="#条款26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款26：尽可能延后变量定义式的出现时间"></a>条款26：尽可能延后变量定义式的出现时间</h2><ul><li>尽可能延后变量定义式的出现，这样做可以增加程序的清晰度并改善程序效率。（在变量定义时直接在构造时指定初值）</li></ul><h2 id="条款27：尽量少做转型动作"><a href="#条款27：尽量少做转型动作" class="headerlink" title="条款27：尽量少做转型动作"></a>条款27：尽量少做转型动作</h2><ul><li>C++新式转型<ol><li>const_cast<t>(expression)</t></li><li>dynamic_cast<t>(expression)</t></li><li>reinterpret_cast<t>(expression)</t></li><li>static_cast<t>(expression)</t></li></ol></li><li>const_cast用来将对象的常量性转移（cast away the constness）。</li><li>dynamic_cast主要用来执行“安全向下转型”（safe downcasting），也就是用来决定某个对象是否归属继承体系中的某个类型。</li><li>reinterpret_cast执行低级转型，实际动作取决于编译器，比如将一个pointer to int 转型为一个int。</li><li><p>static_cast用来强迫隐式转换比如将non-const转换为const，将int转换为double。</p></li><li><p>如果可以，避免转型，特别是在注重效率的代码中避免使用例如dynamic_cast的转型，如果有设计需要转型，试着发展无需转型的代码设计。</p></li><li>如果转型是需要的，试着将它们隐藏于某个函数之后，而不需要让客户进行显示的转型。</li><li>宁可使用C++的新式转型，也不要使用旧式转型，因为前者容易辨识出来，并且也比较有分门别类的职责。</li></ul><h2 id="条款28：避免返回handles指向对象内部成分"><a href="#条款28：避免返回handles指向对象内部成分" class="headerlink" title="条款28：避免返回handles指向对象内部成分"></a>条款28：避免返回handles指向对象内部成分</h2><ul><li>避免返回handles（包括reference、指针和迭代器）指向对象内部。这样可以增加封装性，让const函数表现出const行为，同时将“虚吊号牌”（hanging handles）的可能性降到最低。</li></ul><h2 id="条款29：为“异常安全”的努力是值得的"><a href="#条款29：为“异常安全”的努力是值得的" class="headerlink" title="条款29：为“异常安全”的努力是值得的"></a>条款29：为“异常安全”的努力是值得的</h2><ul><li>当异常被抛出时，有异常安全的函数会：<ol><li>不泄露任何资源</li><li>不允许数据破坏</li></ol></li><li><p>异常安全函数（exception-safe functions）会提供下面三个保证之一：</p><ol><li>基本承诺：如果异常被抛出，程序内任何事物仍然处于有效状态下，所有对象都处于前后一致的状态下。</li><li>强烈保证：如果异常被抛出，程序状态不改变。如果函数成功，就是完全成功，如果函数失败，那就要返回“调用函数之前‘’的状态。</li><li>不抛掷（nothrow）保证：承诺绝不抛出异常，例如作用于内置类型（int，指针等等）身上的操作都提供nothrow保证。</li></ol></li><li><p>异常安全函数即使发生异常也不会发生泄漏或者允许任何数据结构被破坏。这样的函数分为三种：基本型，强烈型，不抛掷异常型。</p></li><li>“强烈保证”可以通过copy-and-swap来实现（在开始创建一个副本，对副本进行操作，最后让副本和本体进行替换），由于它会消耗时间和空间成本，所以并非都有实践意义。</li><li>函数提供的“异常安全保证”只等于其所调用各个函数中“异常安全”最低者。</li></ul><h2 id="条款30：透彻了解inling的里里外外"><a href="#条款30：透彻了解inling的里里外外" class="headerlink" title="条款30：透彻了解inling的里里外外"></a>条款30：透彻了解inling的里里外外</h2><ul><li>将大多数inline函数限制在小型、频繁被调用的函数上，可以使得调试和程序升级变得容易，同时也避免了代码的膨胀。</li><li>不要因为template出现在头文件，就将其声明为inline，template的具现化与inline无关。</li></ul><h2 id="条款31：将文件中的编译依存关系降到最低"><a href="#条款31：将文件中的编译依存关系降到最低" class="headerlink" title="条款31：将文件中的编译依存关系降到最低"></a>条款31：将文件中的编译依存关系降到最低</h2><ul><li>支持”编译依存性最小化”的一般构想是：相依于声明式而非定义式。基于此构想的两种手段是Handle classes和Interface classes。</li><li>程序头文件应该“完全且仅有声明式”的形式存在，这种做法不论是否涉及templates都适用。</li></ul><h2 id="继承与面向对象设计"><a href="#继承与面向对象设计" class="headerlink" title="继承与面向对象设计"></a>继承与面向对象设计</h2><h2 id="条款32：确定你的public继承有is-a的关系"><a href="#条款32：确定你的public继承有is-a的关系" class="headerlink" title="条款32：确定你的public继承有is-a的关系"></a>条款32：确定你的public继承有is-a的关系</h2><ul><li>“public继承”意味is-a，适用于base class的对象其也适用于derived class身上，因为derived class也是一个base class对象。</li></ul><h2 id="条款33：避免遮掩继承过来的名称"><a href="#条款33：避免遮掩继承过来的名称" class="headerlink" title="条款33：避免遮掩继承过来的名称"></a>条款33：避免遮掩继承过来的名称</h2><ul><li>derived classes内的名称会遮掩base class内的名称。</li><li>为了让被遮掩的名称重新使用，可以用using声明式或者inline转交函数（为了给不支持using的编译器使用）（forwarding functions）。</li></ul><h2 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h2><ul><li>接口继承和实现继承不同。在public继承之下，derived classes总是继承base class的接口。</li><li>pure virtual函数只是指定接口继承。$\bigstar$</li><li>简朴的（非纯虚函数）impure virtual函数具体指定接口继承和缺省实现继承。$\bigstar$</li><li>non-virtual函数具体指定接口继承以及强制性实现继承。</li></ul><h2 id="条款35：考虑virtual函数以外的选择"><a href="#条款35：考虑virtual函数以外的选择" class="headerlink" title="条款35：考虑virtual函数以外的选择"></a>条款35：考虑virtual函数以外的选择</h2><ul><li>几个virtual函数的替代方法：<ul><li>使用non-virtual-interface（NVI）手法，这是Template Method设计模型中一种特殊模式。它以public non-virtual成员函数包裹较低访问性（private或者protected）的virtual函数。</li><li>将virtual函数替换成“函数指针成员变量”，这是strategy设计模式的一种分解表达形式。</li><li>用trl::function成员变量替换virtual函数，因而允许使用任何可调用物（callable entity）搭配一个兼容于需求的签名式。这也是strategy设计模式的一种表现。</li><li>将继承体系内的virtual函数替换成另一个继承体系中的virtual函数。这也是strategy的一种体现。</li></ul></li><li>将机能从成员函数移到class外部函数，带来的一个缺点是，非成员函数无法访问class的non-public成员。</li><li>trl::function对象的行为就像是一般的函数指针，这样的对象可以接纳“给定目标签名式兼容”的所有可调用物（callable entities）。    </li></ul><h2 id="条款36：绝不重新定义继承过来的non-virtual函数"><a href="#条款36：绝不重新定义继承过来的non-virtual函数" class="headerlink" title="条款36：绝不重新定义继承过来的non-virtual函数"></a>条款36：绝不重新定义继承过来的non-virtual函数</h2><ul><li>绝对不要重新定义继承而来的non-virtual函数。如果需要就将其定义为virtual函数。</li></ul><h2 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款37：绝不重新定义继承而来的缺省参数值</h2><ul><li>绝对不要重新定义一个继承过来的缺省参数，因为缺省参数值都是静态绑定的，而virtual函数-需要覆写的东西-是动态绑定的。</li><li>复习：动态绑定和静态绑定。静态绑定指的是静态类型，动态绑定指的是目前所指的对象。比如Shape<em> pc = new circle。shape</em>是静态类型，circle是动态绑定，会影响virtual函数的调用情况。</li></ul><h2 id="条款38：通过复合塑模出has-a或“根据某物实现出”"><a href="#条款38：通过复合塑模出has-a或“根据某物实现出”" class="headerlink" title="条款38：通过复合塑模出has-a或“根据某物实现出”"></a>条款38：通过复合塑模出has-a或“根据某物实现出”</h2><ul><li>复合（composition）的意义和public继承完全不同。</li><li>在应用域（application domain），复合代表has-a（有一个）。在实现域（implementation domain），复合意味着is-implemented-in-terms-of（根据某物实现出）。</li></ul><h2 id="条款39：明智且谨慎地使用private继承"><a href="#条款39：明智且谨慎地使用private继承" class="headerlink" title="条款39：明智且谨慎地使用private继承"></a>条款39：明智且谨慎地使用private继承</h2><ul><li>private继承代表着is-implemented-in-terms-of（根据某物实现），它比复合的级别低。但是当derived class 需要访问protected base class的成员时，或者需要重新定义virtual函数时，这么设计是合理的。</li><li>和复合不同，private继承可以做到empty class继承最优化。这样可以使得空间最小化，有这类需求时可以使用private继承。EBO（empty base optimization），空白基类最优化。</li></ul><h2 id="条款40：明智且谨慎地使用多重继承"><a href="#条款40：明智且谨慎地使用多重继承" class="headerlink" title="条款40：明智且谨慎地使用多重继承"></a>条款40：明智且谨慎地使用多重继承</h2><ul><li>多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要。</li><li>virtual继承会增加大小、速度、初始化复杂度等等成本。如果virtual base class不带任何数据，则最有实用价值。</li><li>多重继承的确有正当用途。其中某一个情节设计“public继承某一个interface class”和“private继承某个协助实现的class”两者结合。</li></ul><h2 id="模版和泛型编程"><a href="#模版和泛型编程" class="headerlink" title="模版和泛型编程"></a>模版和泛型编程</h2><h2 id="条款41：了解隐式接口和编译器多态性"><a href="#条款41：了解隐式接口和编译器多态性" class="headerlink" title="条款41：了解隐式接口和编译器多态性"></a>条款41：了解隐式接口和编译器多态性</h2><ul><li>classes和templates都支持接口（interface）和多态（polymorphism）。</li><li>对classes而言接口是显式的（explict），以函数签名为中心。多态通过virtual函数发生于运行期。</li><li>对templates参数而言，接口是隐式的（implicit），基于有效表达式的。多态通过template具现化和函数重载解析发生于编译器。</li></ul><h2 id="条款42：了解typename的双重意义"><a href="#条款42：了解typename的双重意义" class="headerlink" title="条款42：了解typename的双重意义"></a>条款42：了解typename的双重意义</h2><ul><li>声明template参数时，前缀关键字typename和class可以互换。</li><li>用关键字typename表示嵌套从属类型名称（因为编译器不知道某个东西是不是类型，会默认这个名称不是一个类型），但不得在base class list或member initialization list内以它作为base class修饰符。</li></ul><h2 id="条款43：学习处理模板化基类的名称"><a href="#条款43：学习处理模板化基类的名称" class="headerlink" title="条款43：学习处理模板化基类的名称"></a>条款43：学习处理模板化基类的名称</h2><ul><li>对面”指涉base class members”之无效references，编译器的诊断时间可能发生在早期（当解析derived class template的定义式时），也可能发生在晚期（当templates被特定的template具现化时），一般C++偏向于早期。</li><li>可以在derived class templates内通过“this-&gt;”指涉base class templates内的成员名称，或由一个明白写出“base class资格修饰符”完成。</li></ul><h2 id="条款44：将与参数无关的代码抽离template"><a href="#条款44：将与参数无关的代码抽离template" class="headerlink" title="条款44：将与参数无关的代码抽离template"></a>条款44：将与参数无关的代码抽离template</h2><ul><li>template生成多个classes和多个函数，任何template代码都不应该和某个导致膨胀的template参数发生相依关系。</li><li>因非类型参数导致的代码膨胀往往可以消除，做法是以函数参数或者class成员变量替换template参数。</li><li>因类型参数（type parameters）导致的代码膨胀可以降低，做法是让带有完全相同的二进制表述和具体实现类型共享实现代码。</li></ul><h2 id="条款45：运用成员函数模版接受所有兼容类型"><a href="#条款45：运用成员函数模版接受所有兼容类型" class="headerlink" title="条款45：运用成员函数模版接受所有兼容类型"></a>条款45：运用成员函数模版接受所有兼容类型</h2><ul><li>使用member function templates（成员函数模版）生成“可以接受所有兼容类型”的函数。</li><li>如果你声明member function来实现“泛化copy构造”和“泛化assignment操作”，还是需要声明正常的copy构造函数和assignment操作（防止编译器自动生成，见条款5）。</li></ul><h2 id="条款46：需要类型转换时为模版定义非成员函数"><a href="#条款46：需要类型转换时为模版定义非成员函数" class="headerlink" title="条款46：需要类型转换时为模版定义非成员函数"></a>条款46：需要类型转换时为模版定义非成员函数</h2><ul><li>当我们编写一个class template，当它提供“与此template相关”的函数支持的“所有参数支持隐式转换”时，将这些函数定义为“class template内部的friend函数”（实现也放在声明中）。</li></ul><h2 id="条款47：请使用traits-classes表现类型信息"><a href="#条款47：请使用traits-classes表现类型信息" class="headerlink" title="条款47：请使用traits classes表现类型信息"></a>条款47：请使用traits classes表现类型信息</h2><ul><li>STL有5类迭代器：input（只能向前移动一步，读取一次），output（只能向前移动一步，写一次），forward（前两者的结合并能读写多次），bidrectional（比forward多了向后移动），random_access（能移动任意步）。（这些迭代器之间的继承关系是is-a）</li><li>traits classes使得“类型相关信息”在编译期可用。它们以template和“template特化”完成实现。</li><li>整合重载技术（overloading）后，traits classes可能在编译器对类型执行if…else测试。</li></ul><h2 id="条款48：认识template元编程（TMP：template-metaprogramming）"><a href="#条款48：认识template元编程（TMP：template-metaprogramming）" class="headerlink" title="条款48：认识template元编程（TMP：template metaprogramming）"></a>条款48：认识template元编程（TMP：template metaprogramming）</h2><ul><li>Template metaprogramming可将工作从运行期移到编译器，因而得到早起的错误侦测和运行效率。</li><li>TMP可被用来生成“基于政策选择组合”的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。</li></ul><h2 id="定制new和delete"><a href="#定制new和delete" class="headerlink" title="定制new和delete"></a>定制new和delete</h2><h2 id="条款49：了解new-header的行为"><a href="#条款49：了解new-header的行为" class="headerlink" title="条款49：了解new-header的行为"></a>条款49：了解new-header的行为</h2><ul><li>set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用。</li><li>Nothrow new 比较局限，因为它只适用于内存分配；后继的构造函数还是可能抛出异常。</li><li>template的set-new-header，为了让每一个class拥有实体互异的newHandlerSupport复件（实际上T不需要被使用）。</li></ul><h2 id="条款50：了解new和delete的合理替换时机"><a href="#条款50：了解new和delete的合理替换时机" class="headerlink" title="条款50：了解new和delete的合理替换时机"></a>条款50：了解new和delete的合理替换时机</h2><ul><li><p>替换new和delete的理由</p><ol><li>用来检测运用上的错误（new在区块前后放置特定的byte patterns即签名，delete通过检查）。</li><li>为了强化效能。</li><li>为了收集使用上的统计数据。</li></ol></li><li><p>有许多理由需要写自定的new和delete，包括改善效能、对heap运用错误进行调试、收集heap使用信息。</p></li></ul><h2 id="条款51：编写new和delete需要固守常规"><a href="#条款51：编写new和delete需要固守常规" class="headerlink" title="条款51：编写new和delete需要固守常规"></a>条款51：编写new和delete需要固守常规</h2><ul><li>operator new应该内含一个无穷循环，并在其中尝试内存分配，如果它无法满足内存需要，就调用new-handler。它应该有能力处理0 byte申请。Class专属版本则还应该处理“正确大小更大（错误）的申请”。</li><li>operator delete应该在收到null指针时不做任何事情。Class专属版本还应该处理“比正确大小更大的（错误）申请”。</li></ul><h2 id="条款52：写了placement-new也要写placement-delete"><a href="#条款52：写了placement-new也要写placement-delete" class="headerlink" title="条款52：写了placement new也要写placement delete"></a>条款52：写了placement new也要写placement delete</h2><ul><li>当你写一个placement operator new（除了接受size_t还有其他参数的new），请确定也写出对应的placement operator delete。如果没有这么做，你的程序可能会发生隐蔽的时断时续的内存泄漏。</li><li>当你声明placement new和placement delete，请不要无意识遮掩它们的正常版本。</li></ul><h2 id="杂项讨论"><a href="#杂项讨论" class="headerlink" title="杂项讨论"></a>杂项讨论</h2><h2 id="条款53：不要轻视编译器的警告"><a href="#条款53：不要轻视编译器的警告" class="headerlink" title="条款53：不要轻视编译器的警告"></a>条款53：不要轻视编译器的警告</h2><ul><li>严肃对待编译器发出的警告信息。努力在你的编译器的最高警告级别下获得“无任何警告”。</li><li>不要过度依赖编译器的报警能力，因为不同编译器对待事物的态度并不相同，一旦移植到另一个编译器上，可能警告会消失。</li></ul><p>##条款54：让自己熟悉包括TR1在内的标准库</p><ul><li>TR1：Technical Report 1。里面有新的语言特性</li><li>C++标准程序库的主要机能由STL、iostream、locales组成。并包含C99标准程序库。</li><li>TR1添加了智能指针、一般化函数指针（tr1::function）、hash-based容器、正则表达式以及另外10个组件的支持。</li><li>TR1只是一个规范。为了获得TR1提供的好处，你需要一份实物。一个好的实物来源是Boost。</li></ul><h2 id="条款55：让自己熟悉Boost"><a href="#条款55：让自己熟悉Boost" class="headerlink" title="条款55：让自己熟悉Boost"></a>条款55：让自己熟悉Boost</h2><ul><li>Boost是一个社群，也是一个网站。致力于免费、源码开放、同僚审核的C++程序库开发。Boost在C++标准化过程中扮演非常重要的角色。</li><li>Boost提供许多TR1组件实现品，以机其他许多程序库。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Effective-C-浏览过程&quot;&gt;&lt;a href=&quot;#Effective-C-浏览过程&quot; class=&quot;headerlink&quot; title=&quot;Effective C++浏览过程&quot;&gt;&lt;/a&gt;&lt;em&gt;Effective C++&lt;/em&gt;浏览过程&lt;/h1&gt;&lt;hr&gt;
&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/03/05/hello-world/"/>
    <id>http://yoursite.com/2019/03/05/hello-world/</id>
    <published>2019-03-05T06:47:06.805Z</published>
    <updated>2019-03-05T06:47:06.805Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
